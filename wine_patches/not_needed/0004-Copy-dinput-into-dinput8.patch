From 90c31b4ae86db24cb3076102cdea2945c1f4490f Mon Sep 17 00:00:00 2001
From: Andrew Wesie <awesie@gmail.com>
Date: Thu, 26 Jul 2018 11:22:24 -0500
Subject: [PATCH 4/9] Copy dinput into dinput8.

Some anti-cheat engines employ binary encryption by marking all pages of an
executable as NOACCESS and registering a vector exception handler. When the
page is accessed, it will determine if the access is authorized, and if so,
it will decrypt the page and mark it as readable.

In the exemplary anti-cheat, an access is authorized if the fauling EIP is
within the executable, the anti-cheat library, or another library that was
explicitly loaded by the anti-cheat engine using LoadLibrary. Dependencies
that are automatically loaded are *not* authorized.

In the exemplary game, dinput8.dll is loaded explicitly and is authorized.
However, on Wine, the real implementation lives within dinput.dll which is
not explicitly loaded by the game, and thus, not authorized. When the game
calls an API that lives within dinput.dll, it may access an encrypted page
and cause a crash.
---
 dlls/dinput8/Makefile.in           |   15 +-
 dlls/dinput8/config.c              |  459 +++++++++
 dlls/dinput8/data_formats.c        |  568 +++++++++++
 dlls/dinput8/device.c              | 1850 ++++++++++++++++++++++++++++++++++++
 dlls/dinput8/device_private.h      |  251 +++++
 dlls/dinput8/dinput8_main.c        | 1710 +++++++++++++++++++++++++++++++--
 dlls/dinput8/dinput_main.c         | 1843 +++++++++++++++++++++++++++++++++++
 dlls/dinput8/dinput_private.h      |   89 ++
 dlls/dinput8/effect_linuxinput.c   |  934 ++++++++++++++++++
 dlls/dinput8/joystick.c            | 1083 +++++++++++++++++++++
 dlls/dinput8/joystick_linux.c      |  937 ++++++++++++++++++
 dlls/dinput8/joystick_linuxinput.c | 1526 +++++++++++++++++++++++++++++
 dlls/dinput8/joystick_osx.c        | 1697 +++++++++++++++++++++++++++++++++
 dlls/dinput8/joystick_private.h    |  100 ++
 dlls/dinput8/keyboard.c            |  689 ++++++++++++++
 dlls/dinput8/mouse.c               |  940 ++++++++++++++++++
 dlls/dinput8/resource.h            |   35 +
 17 files changed, 14662 insertions(+), 64 deletions(-)
 create mode 100644 dlls/dinput8/config.c
 create mode 100644 dlls/dinput8/data_formats.c
 create mode 100644 dlls/dinput8/device.c
 create mode 100644 dlls/dinput8/device_private.h
 create mode 100644 dlls/dinput8/dinput_main.c
 create mode 100644 dlls/dinput8/dinput_private.h
 create mode 100644 dlls/dinput8/effect_linuxinput.c
 create mode 100644 dlls/dinput8/joystick.c
 create mode 100644 dlls/dinput8/joystick_linux.c
 create mode 100644 dlls/dinput8/joystick_linuxinput.c
 create mode 100644 dlls/dinput8/joystick_osx.c
 create mode 100644 dlls/dinput8/joystick_private.h
 create mode 100644 dlls/dinput8/keyboard.c
 create mode 100644 dlls/dinput8/mouse.c
 create mode 100644 dlls/dinput8/resource.h

diff --git a/dlls/dinput8/Makefile.in b/dlls/dinput8/Makefile.in
index 26672ae..f3863be 100644
--- a/dlls/dinput8/Makefile.in
+++ b/dlls/dinput8/Makefile.in
@@ -1,9 +1,20 @@
 MODULE    = dinput8.dll
 IMPORTLIB = dinput8
-IMPORTS   = uuid dxguid dinput ole32 advapi32
+IMPORTS   = dxguid uuid comctl32 ole32 user32 advapi32
+EXTRALIBS = $(IOKIT_LIBS) $(FORCEFEEDBACK_LIBS)
 
 C_SRCS = \
-	dinput8_main.c
+	dinput8_main.c \
+	config.c \
+	data_formats.c \
+    device.c \
+	effect_linuxinput.c \
+	joystick.c \
+	joystick_linux.c \
+	joystick_linuxinput.c \
+	joystick_osx.c \
+	keyboard.c \
+	mouse.c
 
 IDL_SRCS = dinput8.idl
 
diff --git a/dlls/dinput8/config.c b/dlls/dinput8/config.c
new file mode 100644
index 0000000..708f406
--- /dev/null
+++ b/dlls/dinput8/config.c
@@ -0,0 +1,459 @@
+/*
+ * Copyright (c) 2011 Lucas Fialho Zawacki
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define NONAMELESSUNION
+
+#include "wine/unicode.h"
+#include "objbase.h"
+#include "dinput_private.h"
+#include "device_private.h"
+#include "resource.h"
+
+typedef struct {
+    int nobjects;
+    IDirectInputDevice8W *lpdid;
+    DIDEVICEINSTANCEW ddi;
+    DIDEVICEOBJECTINSTANCEW ddo[256];
+} DeviceData;
+
+typedef struct {
+    int ndevices;
+    DeviceData *devices;
+} DIDevicesData;
+
+typedef struct {
+    IDirectInput8W *lpDI;
+    LPDIACTIONFORMATW lpdiaf;
+    LPDIACTIONFORMATW original_lpdiaf;
+    DIDevicesData devices_data;
+    int display_only;
+} ConfigureDevicesData;
+
+/*
+ * Enumeration callback functions
+ */
+static BOOL CALLBACK collect_objects(LPCDIDEVICEOBJECTINSTANCEW lpddo, LPVOID pvRef)
+{
+    DeviceData *data = (DeviceData*) pvRef;
+
+    data->ddo[data->nobjects] = *lpddo;
+
+    data->nobjects++;
+    return DIENUM_CONTINUE;
+}
+
+static BOOL CALLBACK count_devices(LPCDIDEVICEINSTANCEW lpddi, IDirectInputDevice8W *lpdid, DWORD dwFlags, DWORD dwRemaining, LPVOID pvRef)
+{
+    DIDevicesData *data = (DIDevicesData*) pvRef;
+
+    data->ndevices++;
+    return DIENUM_CONTINUE;
+}
+
+static BOOL CALLBACK collect_devices(LPCDIDEVICEINSTANCEW lpddi, IDirectInputDevice8W *lpdid, DWORD dwFlags, DWORD dwRemaining, LPVOID pvRef)
+{
+    DIDevicesData *data = (DIDevicesData*) pvRef;
+    DeviceData *device = &data->devices[data->ndevices];
+    device->lpdid = lpdid;
+    device->ddi = *lpddi;
+
+    IDirectInputDevice_AddRef(lpdid);
+
+    device->nobjects = 0;
+    IDirectInputDevice_EnumObjects(lpdid, collect_objects, (LPVOID) device, DIDFT_ALL);
+
+    data->ndevices++;
+    return DIENUM_CONTINUE;
+}
+
+/*
+ * Listview utility functions
+ */
+static void init_listview_columns(HWND dialog)
+{
+    HINSTANCE hinstance = (HINSTANCE) GetWindowLongPtrW(dialog, GWLP_HINSTANCE);
+    LVCOLUMNW listColumn;
+    RECT viewRect;
+    int width;
+    WCHAR column[MAX_PATH];
+
+    GetClientRect(GetDlgItem(dialog, IDC_DEVICEOBJECTSLIST), &viewRect);
+    width = (viewRect.right - viewRect.left)/2;
+
+    LoadStringW(hinstance, IDS_OBJECTCOLUMN, column, sizeof(column)/sizeof(column[0]));
+    listColumn.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;
+    listColumn.pszText = column;
+    listColumn.cchTextMax = lstrlenW(listColumn.pszText);
+    listColumn.cx = width;
+
+    SendDlgItemMessageW (dialog, IDC_DEVICEOBJECTSLIST, LVM_INSERTCOLUMNW, 0, (LPARAM) &listColumn);
+
+    LoadStringW(hinstance, IDS_ACTIONCOLUMN, column, sizeof(column)/sizeof(column[0]));
+    listColumn.cx = width;
+    listColumn.pszText = column;
+    listColumn.cchTextMax = lstrlenW(listColumn.pszText);
+
+    SendDlgItemMessageW(dialog, IDC_DEVICEOBJECTSLIST, LVM_INSERTCOLUMNW, 1, (LPARAM) &listColumn);
+}
+
+static int lv_get_cur_item(HWND dialog)
+{
+    return SendDlgItemMessageW(dialog, IDC_DEVICEOBJECTSLIST, LVM_GETNEXTITEM, -1, LVNI_SELECTED);
+}
+
+static int lv_get_item_data(HWND dialog, int index)
+{
+    LVITEMW item;
+
+    if (index < 0) return -1;
+
+    item.mask = LVIF_PARAM;
+    item.iItem = index;
+    item.iSubItem = 0;
+
+    SendDlgItemMessageW(dialog, IDC_DEVICEOBJECTSLIST, LVM_GETITEMW , 0, (LPARAM)&item);
+
+    return item.lParam;
+}
+
+static void lv_set_action(HWND dialog, int item, int action, LPDIACTIONFORMATW lpdiaf)
+{
+    static const WCHAR no_action[] = {'-','\0'};
+    const WCHAR *action_text = no_action;
+    LVITEMW lvItem;
+
+    if (item < 0) return;
+
+    if (action != -1)
+        action_text = lpdiaf->rgoAction[action].u.lptszActionName;
+
+    /* Keep the action and text in the listview item */
+    lvItem.iItem = item;
+
+    lvItem.mask = LVIF_PARAM;
+    lvItem.iSubItem = 0;
+    lvItem.lParam = (LPARAM) action;
+
+    /* Action index */
+    SendDlgItemMessageW(dialog, IDC_DEVICEOBJECTSLIST, LVM_SETITEMW, 0, (LPARAM) &lvItem);
+
+    lvItem.mask = LVIF_TEXT;
+    lvItem.iSubItem = 1;
+    lvItem.pszText = (WCHAR *)action_text;
+    lvItem.cchTextMax = lstrlenW(lvItem.pszText);
+
+    /* Text */
+    SendDlgItemMessageW(dialog, IDC_DEVICEOBJECTSLIST, LVM_SETITEMW, 0, (LPARAM) &lvItem);
+}
+
+/*
+ * Utility functions
+ */
+static DeviceData* get_cur_device(HWND dialog)
+{
+    ConfigureDevicesData *data = (ConfigureDevicesData*) GetWindowLongPtrW(dialog, DWLP_USER);
+    int sel = SendDlgItemMessageW(dialog, IDC_CONTROLLERCOMBO, CB_GETCURSEL, 0, 0);
+    return &data->devices_data.devices[sel];
+}
+
+static LPDIACTIONFORMATW get_cur_lpdiaf(HWND dialog)
+{
+    ConfigureDevicesData *data = (ConfigureDevicesData*) GetWindowLongPtrW(dialog, DWLP_USER);
+    return data->lpdiaf;
+}
+
+static int dialog_display_only(HWND dialog)
+{
+    ConfigureDevicesData *data = (ConfigureDevicesData*) GetWindowLongPtrW(dialog, DWLP_USER);
+    return data->display_only;
+}
+
+static void init_devices(HWND dialog, IDirectInput8W *lpDI, DIDevicesData *data, LPDIACTIONFORMATW lpdiaf)
+{
+    int i;
+
+    /* Count devices */
+    data->ndevices = 0;
+    IDirectInput8_EnumDevicesBySemantics(lpDI, NULL, lpdiaf, count_devices, (LPVOID) data, 0);
+
+    /* Allocate devices */
+    data->devices = HeapAlloc(GetProcessHeap(), 0, sizeof(DeviceData) * data->ndevices);
+
+    /* Collect and insert */
+    data->ndevices = 0;
+    IDirectInput8_EnumDevicesBySemantics(lpDI, NULL, lpdiaf, collect_devices, (LPVOID) data, 0);
+
+    for (i=0; i < data->ndevices; i++)
+        SendDlgItemMessageW(dialog, IDC_CONTROLLERCOMBO, CB_ADDSTRING, 0, (LPARAM) data->devices[i].ddi.tszProductName );
+}
+
+static void destroy_data(HWND dialog)
+{
+    int i;
+    ConfigureDevicesData *data = (ConfigureDevicesData*) GetWindowLongPtrW(dialog, DWLP_USER);
+    DIDevicesData *devices_data = &data->devices_data;
+
+    /* Free the devices */
+    for (i=0; i < devices_data->ndevices; i++)
+        IDirectInputDevice8_Release(devices_data->devices[i].lpdid);
+
+    HeapFree(GetProcessHeap(), 0, devices_data->devices);
+
+    /* Free the backup LPDIACTIONFORMATW  */
+    HeapFree(GetProcessHeap(), 0, data->original_lpdiaf->rgoAction);
+    HeapFree(GetProcessHeap(), 0, data->original_lpdiaf);
+}
+
+static void fill_device_object_list(HWND dialog)
+{
+    DeviceData *device = get_cur_device(dialog);
+    LPDIACTIONFORMATW lpdiaf = get_cur_lpdiaf(dialog);
+    LVITEMW item;
+    int i, j;
+
+    /* Clean the listview */
+    SendDlgItemMessageW(dialog, IDC_DEVICEOBJECTSLIST, LVM_DELETEALLITEMS, 0, 0);
+
+    /* Add each object */
+    for (i=0; i < device->nobjects; i++)
+    {
+        int action = -1;
+
+        item.mask = LVIF_TEXT | LVIF_PARAM;
+        item.iItem = i;
+        item.iSubItem = 0;
+        item.pszText = device->ddo[i].tszName;
+        item.cchTextMax = lstrlenW(item.pszText);
+
+        /* Add the item */
+        SendDlgItemMessageW(dialog, IDC_DEVICEOBJECTSLIST, LVM_INSERTITEMW, 0, (LPARAM) &item);
+
+        /* Search for an assigned action  for this device */
+        for (j=0; j < lpdiaf->dwNumActions; j++)
+        {
+            if (IsEqualGUID(&lpdiaf->rgoAction[j].guidInstance, &device->ddi.guidInstance) &&
+                lpdiaf->rgoAction[j].dwObjID == device->ddo[i].dwType)
+            {
+                action = j;
+                break;
+            }
+        }
+
+        lv_set_action(dialog, i, action, lpdiaf);
+    }
+}
+
+static void show_suitable_actions(HWND dialog)
+{
+    DeviceData *device = get_cur_device(dialog);
+    LPDIACTIONFORMATW lpdiaf = get_cur_lpdiaf(dialog);
+    int i, added = 0;
+    int obj = lv_get_cur_item(dialog);
+
+    if (obj < 0) return;
+
+    SendDlgItemMessageW(dialog, IDC_ACTIONLIST, LB_RESETCONTENT, 0, 0);
+
+    for (i=0; i < lpdiaf->dwNumActions; i++)
+    {
+        /* Skip keyboard actions for non keyboards */
+        if (GET_DIDEVICE_TYPE(device->ddi.dwDevType) != DI8DEVTYPE_KEYBOARD &&
+            (lpdiaf->rgoAction[i].dwSemantic & DIKEYBOARD_MASK) == DIKEYBOARD_MASK) continue;
+
+        /* Skip mouse actions for non mouses */
+        if (GET_DIDEVICE_TYPE(device->ddi.dwDevType) != DI8DEVTYPE_MOUSE &&
+            (lpdiaf->rgoAction[i].dwSemantic & DIMOUSE_MASK) == DIMOUSE_MASK) continue;
+
+        /* Add action string and index in the action format to the list entry */
+        if (DIDFT_GETINSTANCE(lpdiaf->rgoAction[i].dwSemantic) & DIDFT_GETTYPE(device->ddo[obj].dwType))
+        {
+            SendDlgItemMessageW(dialog, IDC_ACTIONLIST, LB_ADDSTRING, 0, (LPARAM)lpdiaf->rgoAction[i].u.lptszActionName);
+            SendDlgItemMessageW(dialog, IDC_ACTIONLIST, LB_SETITEMDATA, added, (LPARAM) i);
+            added++;
+        }
+    }
+}
+
+static void assign_action(HWND dialog)
+{
+    DeviceData *device = get_cur_device(dialog);
+    LPDIACTIONFORMATW lpdiaf = get_cur_lpdiaf(dialog);
+    LVFINDINFOW lvFind;
+    int sel = SendDlgItemMessageW(dialog, IDC_ACTIONLIST, LB_GETCURSEL, 0, 0);
+    int action = SendDlgItemMessageW(dialog, IDC_ACTIONLIST, LB_GETITEMDATA, sel, 0);
+    int obj = lv_get_cur_item(dialog);
+    int old_action = lv_get_item_data(dialog, obj);
+    int used_obj;
+
+    DIDEVICEOBJECTINSTANCEW ddo = device->ddo[obj];
+
+    if (old_action == action) return;
+
+    /* Clear old action */
+    if (old_action != -1)
+    {
+        lpdiaf->rgoAction[old_action].dwObjID = 0;
+        lpdiaf->rgoAction[old_action].guidInstance = GUID_NULL;
+        lpdiaf->rgoAction[old_action].dwHow = DIAH_UNMAPPED;
+    }
+
+    /* Find if action text is already set for other object and unset it */
+    lvFind.flags = LVFI_PARAM;
+    lvFind.lParam = action;
+
+    used_obj = SendDlgItemMessageW(dialog, IDC_DEVICEOBJECTSLIST, LVM_FINDITEMW, -1, (LPARAM) &lvFind);
+
+    lv_set_action(dialog, used_obj, -1, lpdiaf);
+
+    /* Set new action */
+    lpdiaf->rgoAction[action].dwObjID = ddo.dwType;
+    lpdiaf->rgoAction[action].guidInstance = device->ddi.guidInstance;
+    lpdiaf->rgoAction[action].dwHow = DIAH_USERCONFIG;
+
+    /* Set new action in the list */
+    lv_set_action(dialog, obj, action, lpdiaf);
+}
+
+static void copy_actions(LPDIACTIONFORMATW to, LPDIACTIONFORMATW from)
+{
+    DWORD i;
+    for (i=0; i < from->dwNumActions; i++)
+    {
+        to->rgoAction[i].guidInstance = from->rgoAction[i].guidInstance;
+        to->rgoAction[i].dwObjID = from->rgoAction[i].dwObjID;
+        to->rgoAction[i].dwHow = from->rgoAction[i].dwHow;
+        to->rgoAction[i].u.lptszActionName = from->rgoAction[i].u.lptszActionName;
+    }
+}
+
+static void reset_actions(HWND dialog)
+{
+    ConfigureDevicesData *data = (ConfigureDevicesData*) GetWindowLongPtrW(dialog, DWLP_USER);
+    LPDIACTIONFORMATW to = data->lpdiaf, from = data->original_lpdiaf;
+
+    copy_actions(to, from);
+}
+
+static INT_PTR CALLBACK ConfigureDevicesDlgProc(HWND dialog, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+    switch(uMsg)
+    {
+        case WM_INITDIALOG:
+        {
+            ConfigureDevicesData *data = (ConfigureDevicesData*) lParam;
+
+            /* Initialize action format and enumerate devices */
+            init_devices(dialog, data->lpDI, &data->devices_data, data->lpdiaf);
+
+            /* Store information in the window */
+            SetWindowLongPtrW(dialog, DWLP_USER, (LONG_PTR) data);
+
+            init_listview_columns(dialog);
+
+            /* Create a backup action format for CANCEL and RESET operations */
+            data->original_lpdiaf = HeapAlloc(GetProcessHeap(), 0, sizeof(*data->original_lpdiaf));
+            data->original_lpdiaf->dwNumActions = data->lpdiaf->dwNumActions;
+            data->original_lpdiaf->rgoAction = HeapAlloc(GetProcessHeap(), 0, sizeof(DIACTIONW)*data->lpdiaf->dwNumActions);
+            copy_actions(data->original_lpdiaf, data->lpdiaf);
+
+            /* Select the first device and show its actions */
+            SendDlgItemMessageW(dialog, IDC_CONTROLLERCOMBO, CB_SETCURSEL, 0, 0);
+            fill_device_object_list(dialog);
+
+            break;
+        }
+
+        case WM_NOTIFY:
+
+            switch (((LPNMHDR)lParam)->code)
+            {
+                case LVN_ITEMCHANGED:
+                    show_suitable_actions(dialog);
+                    break;
+            }
+            break;
+
+
+        case WM_COMMAND:
+
+            switch(LOWORD(wParam))
+            {
+
+                case IDC_ACTIONLIST:
+
+                    switch (HIWORD(wParam))
+                    {
+                        case LBN_DBLCLK:
+                            /* Ignore this if app did not ask for editing */
+                            if (dialog_display_only(dialog)) break;
+
+                            assign_action(dialog);
+                            break;
+                    }
+                    break;
+
+                case IDC_CONTROLLERCOMBO:
+
+                    switch (HIWORD(wParam))
+                    {
+                        case CBN_SELCHANGE:
+                            fill_device_object_list(dialog);
+                            break;
+                    }
+                    break;
+
+                case IDOK:
+                    EndDialog(dialog, 0);
+                    destroy_data(dialog);
+                    break;
+
+                case IDCANCEL:
+                    reset_actions(dialog);
+                    EndDialog(dialog, 0);
+                    destroy_data(dialog);
+                    break;
+
+                case IDC_RESET:
+                    reset_actions(dialog);
+                    fill_device_object_list(dialog);
+                    break;
+            }
+        break;
+    }
+
+    return FALSE;
+}
+
+HRESULT _configure_devices(IDirectInput8W *iface,
+                           LPDICONFIGUREDEVICESCALLBACK lpdiCallback,
+                           LPDICONFIGUREDEVICESPARAMSW lpdiCDParams,
+                           DWORD dwFlags,
+                           LPVOID pvRefData
+)
+{
+    ConfigureDevicesData data;
+    data.lpDI = iface;
+    data.lpdiaf = lpdiCDParams->lprgFormats;
+    data.display_only = !(dwFlags & DICD_EDIT);
+
+    InitCommonControls();
+
+    DialogBoxParamW(GetModuleHandleA("dinput.dll"), (LPCWSTR) MAKEINTRESOURCE(IDD_CONFIGUREDEVICES), lpdiCDParams->hwnd, ConfigureDevicesDlgProc, (LPARAM) &data);
+
+    return DI_OK;
+}
diff --git a/dlls/dinput8/data_formats.c b/dlls/dinput8/data_formats.c
new file mode 100644
index 0000000..9c9f00f
--- /dev/null
+++ b/dlls/dinput8/data_formats.c
@@ -0,0 +1,568 @@
+/*
+ * Copyright (c) 2004 Robert Reif
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep implib
+#endif
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "dinput.h"
+
+static const DIOBJECTDATAFORMAT dfDIJoystick[] = {
+  { &GUID_XAxis,DIJOFS_X,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_YAxis,DIJOFS_Y,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_ZAxis,DIJOFS_Z,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_RxAxis,DIJOFS_RX,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_RyAxis,DIJOFS_RY,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_RzAxis,DIJOFS_RZ,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_Slider,DIJOFS_SLIDER(0),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_Slider,DIJOFS_SLIDER(1),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_POV,DIJOFS_POV(0),DIDFT_OPTIONAL|DIDFT_POV|DIDFT_ANYINSTANCE,0},
+  { &GUID_POV,DIJOFS_POV(1),DIDFT_OPTIONAL|DIDFT_POV|DIDFT_ANYINSTANCE,0},
+  { &GUID_POV,DIJOFS_POV(2),DIDFT_OPTIONAL|DIDFT_POV|DIDFT_ANYINSTANCE,0},
+  { &GUID_POV,DIJOFS_POV(3),DIDFT_OPTIONAL|DIDFT_POV|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(0),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(1),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(2),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(3),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(4),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(5),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(6),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(7),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(8),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(9),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(10),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(11),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(12),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(13),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(14),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(15),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(16),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(17),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(18),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(19),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(20),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(21),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(22),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(23),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(24),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(25),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(26),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(27),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(28),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(29),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(30),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(31),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+};
+
+const DIDATAFORMAT c_dfDIJoystick = {
+    sizeof(DIDATAFORMAT),
+    sizeof(DIOBJECTDATAFORMAT),
+    DIDF_ABSAXIS,
+    sizeof(DIJOYSTATE),
+    ARRAY_SIZE(dfDIJoystick),
+    (LPDIOBJECTDATAFORMAT)dfDIJoystick
+};
+
+static const DIOBJECTDATAFORMAT dfDIJoystick2[] = {
+  { &GUID_XAxis,DIJOFS_X,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_YAxis,DIJOFS_Y,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_ZAxis,DIJOFS_Z,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_RxAxis,DIJOFS_RX,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_RyAxis,DIJOFS_RY,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_RzAxis,DIJOFS_RZ,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_Slider,DIJOFS_SLIDER(0),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_Slider,DIJOFS_SLIDER(1),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_POV,DIJOFS_POV(0),DIDFT_OPTIONAL|DIDFT_POV|DIDFT_ANYINSTANCE,0},
+  { &GUID_POV,DIJOFS_POV(1),DIDFT_OPTIONAL|DIDFT_POV|DIDFT_ANYINSTANCE,0},
+  { &GUID_POV,DIJOFS_POV(2),DIDFT_OPTIONAL|DIDFT_POV|DIDFT_ANYINSTANCE,0},
+  { &GUID_POV,DIJOFS_POV(3),DIDFT_OPTIONAL|DIDFT_POV|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(0),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(1),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(2),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(3),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(4),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(5),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(6),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(7),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(8),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(9),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(10),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(11),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(12),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(13),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(14),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(15),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(16),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(17),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(18),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(19),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(20),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(21),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(22),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(23),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(24),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(25),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(26),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(27),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(28),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(29),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(30),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(31),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(32),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(33),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(34),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(35),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(36),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(37),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(38),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(39),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(40),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(41),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(42),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(43),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(44),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(45),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(46),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(47),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(48),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(49),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(50),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(51),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(52),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(53),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(54),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(55),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(56),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(57),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(58),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(59),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(60),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(61),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(62),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(63),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(64),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(65),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(66),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(67),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(68),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(69),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(70),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(71),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(72),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(73),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(74),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(75),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(76),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(77),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(78),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(79),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(80),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(81),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(82),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(83),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(84),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(85),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(86),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(87),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(88),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(89),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(90),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(91),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(92),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(93),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(94),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(95),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(96),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(97),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(98),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(99),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(100),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(101),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(102),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(103),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(104),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(105),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(106),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(107),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(108),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(109),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(110),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(111),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(112),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(113),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(114),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(115),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(116),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(117),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(118),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(119),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(120),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(121),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(122),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(123),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(124),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(125),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(126),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { NULL,DIJOFS_BUTTON(127),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE,0},
+  { &GUID_XAxis,FIELD_OFFSET(DIJOYSTATE2,lVX),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_YAxis,FIELD_OFFSET(DIJOYSTATE2,lVY),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_ZAxis,FIELD_OFFSET(DIJOYSTATE2,lVZ),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_RxAxis,FIELD_OFFSET(DIJOYSTATE2,lVRx),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_RyAxis,FIELD_OFFSET(DIJOYSTATE2,lVRy),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_RzAxis,FIELD_OFFSET(DIJOYSTATE2,lVRz),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_Slider,FIELD_OFFSET(DIJOYSTATE2,rglVSlider[0]),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_Slider,FIELD_OFFSET(DIJOYSTATE2,rglVSlider[1]),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_XAxis,FIELD_OFFSET(DIJOYSTATE2,lAX),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_YAxis,FIELD_OFFSET(DIJOYSTATE2,lAY),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_ZAxis,FIELD_OFFSET(DIJOYSTATE2,lAZ),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_RxAxis,FIELD_OFFSET(DIJOYSTATE2,lARx),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_RyAxis,FIELD_OFFSET(DIJOYSTATE2,lARy),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_RzAxis,FIELD_OFFSET(DIJOYSTATE2,lARz),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_Slider,FIELD_OFFSET(DIJOYSTATE2,rglASlider[0]),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_Slider,FIELD_OFFSET(DIJOYSTATE2,rglASlider[1]),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_XAxis,FIELD_OFFSET(DIJOYSTATE2,lFX),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_YAxis,FIELD_OFFSET(DIJOYSTATE2,lFY),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_ZAxis,FIELD_OFFSET(DIJOYSTATE2,lFZ),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_RxAxis,FIELD_OFFSET(DIJOYSTATE2,lFRx),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_RyAxis,FIELD_OFFSET(DIJOYSTATE2,lFRy),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_RzAxis,FIELD_OFFSET(DIJOYSTATE2,lFRz),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_Slider,FIELD_OFFSET(DIJOYSTATE2,rglFSlider[0]),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+  { &GUID_Slider,FIELD_OFFSET(DIJOYSTATE2,rglFSlider[1]),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE,0},
+};
+
+const DIDATAFORMAT c_dfDIJoystick2 = {
+    sizeof(DIDATAFORMAT),
+    sizeof(DIOBJECTDATAFORMAT),
+    DIDF_ABSAXIS,
+    sizeof(DIJOYSTATE2),
+    ARRAY_SIZE(dfDIJoystick2),
+    (LPDIOBJECTDATAFORMAT)dfDIJoystick2
+};
+
+static const DIOBJECTDATAFORMAT dfDIMouse[] = {
+  { &GUID_XAxis,  DIMOFS_X, DIDFT_ANYINSTANCE | DIDFT_AXIS, 0 },
+  { &GUID_YAxis,  DIMOFS_Y, DIDFT_ANYINSTANCE | DIDFT_AXIS, 0 },
+  { &GUID_ZAxis,  DIMOFS_Z, DIDFT_OPTIONAL | DIDFT_ANYINSTANCE | DIDFT_AXIS, 0 },
+  { &GUID_Button, DIMOFS_BUTTON0, DIDFT_ANYINSTANCE | DIDFT_BUTTON, 0 },
+  { &GUID_Button, DIMOFS_BUTTON1, DIDFT_ANYINSTANCE | DIDFT_BUTTON, 0 },
+  { &GUID_Button, DIMOFS_BUTTON2, DIDFT_OPTIONAL | DIDFT_ANYINSTANCE | DIDFT_BUTTON, 0 },
+  { &GUID_Button, DIMOFS_BUTTON3, DIDFT_OPTIONAL | DIDFT_ANYINSTANCE | DIDFT_BUTTON, 0 }
+};
+
+const DIDATAFORMAT c_dfDIMouse = {
+    sizeof(DIDATAFORMAT),
+    sizeof(DIOBJECTDATAFORMAT),
+    DIDF_RELAXIS,
+    sizeof(DIMOUSESTATE),
+    ARRAY_SIZE(dfDIMouse),
+    (LPDIOBJECTDATAFORMAT)dfDIMouse
+};
+
+static const DIOBJECTDATAFORMAT dfDIMouse2[] = {
+  { &GUID_XAxis,  DIMOFS_X, DIDFT_ANYINSTANCE | DIDFT_AXIS, 0 },
+  { &GUID_YAxis,  DIMOFS_Y, DIDFT_ANYINSTANCE | DIDFT_AXIS, 0 },
+  { &GUID_ZAxis,  DIMOFS_Z, DIDFT_OPTIONAL | DIDFT_ANYINSTANCE | DIDFT_AXIS, 0 },
+  { &GUID_Button, DIMOFS_BUTTON0, DIDFT_ANYINSTANCE | DIDFT_BUTTON, 0 },
+  { &GUID_Button, DIMOFS_BUTTON1, DIDFT_ANYINSTANCE | DIDFT_BUTTON, 0 },
+  { &GUID_Button, DIMOFS_BUTTON2, DIDFT_OPTIONAL | DIDFT_ANYINSTANCE | DIDFT_BUTTON, 0 },
+  { &GUID_Button, DIMOFS_BUTTON3, DIDFT_OPTIONAL | DIDFT_ANYINSTANCE | DIDFT_BUTTON, 0 },
+  { &GUID_Button, DIMOFS_BUTTON4, DIDFT_OPTIONAL | DIDFT_ANYINSTANCE | DIDFT_BUTTON, 0 },
+  { &GUID_Button, DIMOFS_BUTTON5, DIDFT_OPTIONAL | DIDFT_ANYINSTANCE | DIDFT_BUTTON, 0 },
+  { &GUID_Button, DIMOFS_BUTTON6, DIDFT_OPTIONAL | DIDFT_ANYINSTANCE | DIDFT_BUTTON, 0 },
+  { &GUID_Button, DIMOFS_BUTTON7, DIDFT_OPTIONAL | DIDFT_ANYINSTANCE | DIDFT_BUTTON, 0 }
+};
+
+const DIDATAFORMAT c_dfDIMouse2 = {
+    sizeof(DIDATAFORMAT),
+    sizeof(DIOBJECTDATAFORMAT),
+    DIDF_RELAXIS,
+    sizeof(DIMOUSESTATE2),
+    ARRAY_SIZE(dfDIMouse2),
+    (LPDIOBJECTDATAFORMAT)dfDIMouse2
+};
+
+static const DIOBJECTDATAFORMAT dfDIKeyboard[] = {
+  { &GUID_Key,0,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(0),0},
+  { &GUID_Key,1,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(1),0},
+  { &GUID_Key,2,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(2),0},
+  { &GUID_Key,3,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(3),0},
+  { &GUID_Key,4,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(4),0},
+  { &GUID_Key,5,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(5),0},
+  { &GUID_Key,6,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(6),0},
+  { &GUID_Key,7,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(7),0},
+  { &GUID_Key,8,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(8),0},
+  { &GUID_Key,9,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(9),0},
+  { &GUID_Key,10,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(10),0},
+  { &GUID_Key,11,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(11),0},
+  { &GUID_Key,12,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(12),0},
+  { &GUID_Key,13,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(13),0},
+  { &GUID_Key,14,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(14),0},
+  { &GUID_Key,15,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(15),0},
+  { &GUID_Key,16,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(16),0},
+  { &GUID_Key,17,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(17),0},
+  { &GUID_Key,18,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(18),0},
+  { &GUID_Key,19,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(19),0},
+  { &GUID_Key,20,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(20),0},
+  { &GUID_Key,21,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(21),0},
+  { &GUID_Key,22,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(22),0},
+  { &GUID_Key,23,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(23),0},
+  { &GUID_Key,24,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(24),0},
+  { &GUID_Key,25,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(25),0},
+  { &GUID_Key,26,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(26),0},
+  { &GUID_Key,27,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(27),0},
+  { &GUID_Key,28,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(28),0},
+  { &GUID_Key,29,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(29),0},
+  { &GUID_Key,30,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(30),0},
+  { &GUID_Key,31,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(31),0},
+  { &GUID_Key,32,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(32),0},
+  { &GUID_Key,33,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(33),0},
+  { &GUID_Key,34,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(34),0},
+  { &GUID_Key,35,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(35),0},
+  { &GUID_Key,36,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(36),0},
+  { &GUID_Key,37,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(37),0},
+  { &GUID_Key,38,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(38),0},
+  { &GUID_Key,39,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(39),0},
+  { &GUID_Key,40,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(40),0},
+  { &GUID_Key,41,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(41),0},
+  { &GUID_Key,42,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(42),0},
+  { &GUID_Key,43,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(43),0},
+  { &GUID_Key,44,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(44),0},
+  { &GUID_Key,45,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(45),0},
+  { &GUID_Key,46,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(46),0},
+  { &GUID_Key,47,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(47),0},
+  { &GUID_Key,48,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(48),0},
+  { &GUID_Key,49,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(49),0},
+  { &GUID_Key,50,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(50),0},
+  { &GUID_Key,51,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(51),0},
+  { &GUID_Key,52,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(52),0},
+  { &GUID_Key,53,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(53),0},
+  { &GUID_Key,54,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(54),0},
+  { &GUID_Key,55,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(55),0},
+  { &GUID_Key,56,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(56),0},
+  { &GUID_Key,57,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(57),0},
+  { &GUID_Key,58,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(58),0},
+  { &GUID_Key,59,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(59),0},
+  { &GUID_Key,60,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(60),0},
+  { &GUID_Key,61,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(61),0},
+  { &GUID_Key,62,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(62),0},
+  { &GUID_Key,63,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(63),0},
+  { &GUID_Key,64,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(64),0},
+  { &GUID_Key,65,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(65),0},
+  { &GUID_Key,66,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(66),0},
+  { &GUID_Key,67,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(67),0},
+  { &GUID_Key,68,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(68),0},
+  { &GUID_Key,69,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(69),0},
+  { &GUID_Key,70,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(70),0},
+  { &GUID_Key,71,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(71),0},
+  { &GUID_Key,72,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(72),0},
+  { &GUID_Key,73,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(73),0},
+  { &GUID_Key,74,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(74),0},
+  { &GUID_Key,75,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(75),0},
+  { &GUID_Key,76,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(76),0},
+  { &GUID_Key,77,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(77),0},
+  { &GUID_Key,78,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(78),0},
+  { &GUID_Key,79,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(79),0},
+  { &GUID_Key,80,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(80),0},
+  { &GUID_Key,81,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(81),0},
+  { &GUID_Key,82,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(82),0},
+  { &GUID_Key,83,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(83),0},
+  { &GUID_Key,84,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(84),0},
+  { &GUID_Key,85,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(85),0},
+  { &GUID_Key,86,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(86),0},
+  { &GUID_Key,87,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(87),0},
+  { &GUID_Key,88,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(88),0},
+  { &GUID_Key,89,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(89),0},
+  { &GUID_Key,90,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(90),0},
+  { &GUID_Key,91,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(91),0},
+  { &GUID_Key,92,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(92),0},
+  { &GUID_Key,93,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(93),0},
+  { &GUID_Key,94,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(94),0},
+  { &GUID_Key,95,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(95),0},
+  { &GUID_Key,96,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(96),0},
+  { &GUID_Key,97,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(97),0},
+  { &GUID_Key,98,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(98),0},
+  { &GUID_Key,99,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(99),0},
+  { &GUID_Key,100,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(100),0},
+  { &GUID_Key,101,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(101),0},
+  { &GUID_Key,102,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(102),0},
+  { &GUID_Key,103,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(103),0},
+  { &GUID_Key,104,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(104),0},
+  { &GUID_Key,105,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(105),0},
+  { &GUID_Key,106,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(106),0},
+  { &GUID_Key,107,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(107),0},
+  { &GUID_Key,108,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(108),0},
+  { &GUID_Key,109,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(109),0},
+  { &GUID_Key,110,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(110),0},
+  { &GUID_Key,111,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(111),0},
+  { &GUID_Key,112,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(112),0},
+  { &GUID_Key,113,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(113),0},
+  { &GUID_Key,114,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(114),0},
+  { &GUID_Key,115,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(115),0},
+  { &GUID_Key,116,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(116),0},
+  { &GUID_Key,117,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(117),0},
+  { &GUID_Key,118,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(118),0},
+  { &GUID_Key,119,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(119),0},
+  { &GUID_Key,120,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(120),0},
+  { &GUID_Key,121,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(121),0},
+  { &GUID_Key,122,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(122),0},
+  { &GUID_Key,123,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(123),0},
+  { &GUID_Key,124,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(124),0},
+  { &GUID_Key,125,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(125),0},
+  { &GUID_Key,126,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(126),0},
+  { &GUID_Key,127,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(127),0},
+  { &GUID_Key,128,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(128),0},
+  { &GUID_Key,129,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(129),0},
+  { &GUID_Key,130,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(130),0},
+  { &GUID_Key,131,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(131),0},
+  { &GUID_Key,132,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(132),0},
+  { &GUID_Key,133,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(133),0},
+  { &GUID_Key,134,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(134),0},
+  { &GUID_Key,135,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(135),0},
+  { &GUID_Key,136,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(136),0},
+  { &GUID_Key,137,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(137),0},
+  { &GUID_Key,138,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(138),0},
+  { &GUID_Key,139,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(139),0},
+  { &GUID_Key,140,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(140),0},
+  { &GUID_Key,141,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(141),0},
+  { &GUID_Key,142,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(142),0},
+  { &GUID_Key,143,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(143),0},
+  { &GUID_Key,144,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(144),0},
+  { &GUID_Key,145,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(145),0},
+  { &GUID_Key,146,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(146),0},
+  { &GUID_Key,147,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(147),0},
+  { &GUID_Key,148,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(148),0},
+  { &GUID_Key,149,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(149),0},
+  { &GUID_Key,150,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(150),0},
+  { &GUID_Key,151,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(151),0},
+  { &GUID_Key,152,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(152),0},
+  { &GUID_Key,153,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(153),0},
+  { &GUID_Key,154,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(154),0},
+  { &GUID_Key,155,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(155),0},
+  { &GUID_Key,156,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(156),0},
+  { &GUID_Key,157,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(157),0},
+  { &GUID_Key,158,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(158),0},
+  { &GUID_Key,159,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(159),0},
+  { &GUID_Key,160,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(160),0},
+  { &GUID_Key,161,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(161),0},
+  { &GUID_Key,162,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(162),0},
+  { &GUID_Key,163,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(163),0},
+  { &GUID_Key,164,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(164),0},
+  { &GUID_Key,165,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(165),0},
+  { &GUID_Key,166,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(166),0},
+  { &GUID_Key,167,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(167),0},
+  { &GUID_Key,168,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(168),0},
+  { &GUID_Key,169,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(169),0},
+  { &GUID_Key,170,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(170),0},
+  { &GUID_Key,171,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(171),0},
+  { &GUID_Key,172,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(172),0},
+  { &GUID_Key,173,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(173),0},
+  { &GUID_Key,174,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(174),0},
+  { &GUID_Key,175,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(175),0},
+  { &GUID_Key,176,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(176),0},
+  { &GUID_Key,177,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(177),0},
+  { &GUID_Key,178,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(178),0},
+  { &GUID_Key,179,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(179),0},
+  { &GUID_Key,180,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(180),0},
+  { &GUID_Key,181,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(181),0},
+  { &GUID_Key,182,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(182),0},
+  { &GUID_Key,183,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(183),0},
+  { &GUID_Key,184,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(184),0},
+  { &GUID_Key,185,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(185),0},
+  { &GUID_Key,186,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(186),0},
+  { &GUID_Key,187,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(187),0},
+  { &GUID_Key,188,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(188),0},
+  { &GUID_Key,189,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(189),0},
+  { &GUID_Key,190,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(190),0},
+  { &GUID_Key,191,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(191),0},
+  { &GUID_Key,192,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(192),0},
+  { &GUID_Key,193,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(193),0},
+  { &GUID_Key,194,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(194),0},
+  { &GUID_Key,195,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(195),0},
+  { &GUID_Key,196,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(196),0},
+  { &GUID_Key,197,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(197),0},
+  { &GUID_Key,198,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(198),0},
+  { &GUID_Key,199,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(199),0},
+  { &GUID_Key,200,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(200),0},
+  { &GUID_Key,201,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(201),0},
+  { &GUID_Key,202,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(202),0},
+  { &GUID_Key,203,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(203),0},
+  { &GUID_Key,204,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(204),0},
+  { &GUID_Key,205,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(205),0},
+  { &GUID_Key,206,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(206),0},
+  { &GUID_Key,207,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(207),0},
+  { &GUID_Key,208,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(208),0},
+  { &GUID_Key,209,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(209),0},
+  { &GUID_Key,210,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(210),0},
+  { &GUID_Key,211,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(211),0},
+  { &GUID_Key,212,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(212),0},
+  { &GUID_Key,213,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(213),0},
+  { &GUID_Key,214,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(214),0},
+  { &GUID_Key,215,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(215),0},
+  { &GUID_Key,216,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(216),0},
+  { &GUID_Key,217,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(217),0},
+  { &GUID_Key,218,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(218),0},
+  { &GUID_Key,219,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(219),0},
+  { &GUID_Key,220,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(220),0},
+  { &GUID_Key,221,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(221),0},
+  { &GUID_Key,222,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(222),0},
+  { &GUID_Key,223,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(223),0},
+  { &GUID_Key,224,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(224),0},
+  { &GUID_Key,225,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(225),0},
+  { &GUID_Key,226,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(226),0},
+  { &GUID_Key,227,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(227),0},
+  { &GUID_Key,228,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(228),0},
+  { &GUID_Key,229,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(229),0},
+  { &GUID_Key,230,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(230),0},
+  { &GUID_Key,231,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(231),0},
+  { &GUID_Key,232,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(232),0},
+  { &GUID_Key,233,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(233),0},
+  { &GUID_Key,234,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(234),0},
+  { &GUID_Key,235,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(235),0},
+  { &GUID_Key,236,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(236),0},
+  { &GUID_Key,237,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(237),0},
+  { &GUID_Key,238,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(238),0},
+  { &GUID_Key,239,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(239),0},
+  { &GUID_Key,240,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(240),0},
+  { &GUID_Key,241,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(241),0},
+  { &GUID_Key,242,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(242),0},
+  { &GUID_Key,243,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(243),0},
+  { &GUID_Key,244,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(244),0},
+  { &GUID_Key,245,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(245),0},
+  { &GUID_Key,246,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(246),0},
+  { &GUID_Key,247,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(247),0},
+  { &GUID_Key,248,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(248),0},
+  { &GUID_Key,249,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(249),0},
+  { &GUID_Key,250,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(250),0},
+  { &GUID_Key,251,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(251),0},
+  { &GUID_Key,252,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(252),0},
+  { &GUID_Key,253,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(253),0},
+  { &GUID_Key,254,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(254),0},
+  { &GUID_Key,255,DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_MAKEINSTANCE(255),0}
+};
+
+const DIDATAFORMAT c_dfDIKeyboard = {
+    sizeof(DIDATAFORMAT),
+    sizeof(DIOBJECTDATAFORMAT),
+    DIDF_RELAXIS,
+    256,
+    ARRAY_SIZE(dfDIKeyboard),
+    (LPDIOBJECTDATAFORMAT)dfDIKeyboard
+};
diff --git a/dlls/dinput8/device.c b/dlls/dinput8/device.c
new file mode 100644
index 0000000..1336a8a
--- /dev/null
+++ b/dlls/dinput8/device.c
@@ -0,0 +1,1850 @@
+/*		DirectInput Device
+ *
+ * Copyright 1998 Marcus Meissner
+ * Copyright 1998,1999 Lionel Ulmer
+ *
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/* This file contains all the Device specific functions that can be used as stubs
+   by real device implementations.
+
+   It also contains all the helper functions.
+*/
+#include "config.h"
+
+#include <stdarg.h>
+#include <string.h>
+#include "wine/debug.h"
+#include "wine/unicode.h"
+#include "windef.h"
+#include "winbase.h"
+#include "winreg.h"
+#include "winuser.h"
+#include "winerror.h"
+#include "dinput.h"
+#include "device_private.h"
+#include "dinput_private.h"
+
+#define WM_WINE_NOTIFY_ACTIVITY WM_USER
+
+WINE_DEFAULT_DEBUG_CHANNEL(dinput);
+
+static inline IDirectInputDeviceImpl *impl_from_IDirectInputDevice8A(IDirectInputDevice8A *iface)
+{
+    return CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8A_iface);
+}
+static inline IDirectInputDeviceImpl *impl_from_IDirectInputDevice8W(IDirectInputDevice8W *iface)
+{
+    return CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8W_iface);
+}
+
+static inline IDirectInputDevice8A *IDirectInputDevice8A_from_impl(IDirectInputDeviceImpl *This)
+{
+    return &This->IDirectInputDevice8A_iface;
+}
+static inline IDirectInputDevice8W *IDirectInputDevice8W_from_impl(IDirectInputDeviceImpl *This)
+{
+    return &This->IDirectInputDevice8W_iface;
+}
+
+/******************************************************************************
+ *	Various debugging tools
+ */
+static void _dump_cooperativelevel_DI(DWORD dwFlags) {
+    if (TRACE_ON(dinput)) {
+	unsigned int   i;
+	static const struct {
+	    DWORD       mask;
+	    const char  *name;
+	} flags[] = {
+#define FE(x) { x, #x}
+	    FE(DISCL_BACKGROUND),
+	    FE(DISCL_EXCLUSIVE),
+	    FE(DISCL_FOREGROUND),
+	    FE(DISCL_NONEXCLUSIVE),
+	    FE(DISCL_NOWINKEY)
+#undef FE
+	};
+	TRACE(" cooperative level : ");
+	for (i = 0; i < (sizeof(flags) / sizeof(flags[0])); i++)
+	    if (flags[i].mask & dwFlags)
+		TRACE("%s ",flags[i].name);
+	TRACE("\n");
+    }
+}
+
+static void _dump_ObjectDataFormat_flags(DWORD dwFlags) {
+    unsigned int   i;
+    static const struct {
+        DWORD       mask;
+        const char  *name;
+    } flags[] = {
+#define FE(x) { x, #x}
+        FE(DIDOI_FFACTUATOR),
+        FE(DIDOI_FFEFFECTTRIGGER),
+        FE(DIDOI_POLLED),
+        FE(DIDOI_GUIDISUSAGE)
+#undef FE
+    };
+
+    if (!dwFlags) return;
+
+    TRACE("Flags:");
+
+    /* First the flags */
+    for (i = 0; i < (sizeof(flags) / sizeof(flags[0])); i++) {
+        if (flags[i].mask & dwFlags)
+        TRACE(" %s",flags[i].name);
+    }
+
+    /* Now specific values */
+#define FE(x) case x: TRACE(" "#x); break
+    switch (dwFlags & DIDOI_ASPECTMASK) {
+        FE(DIDOI_ASPECTACCEL);
+        FE(DIDOI_ASPECTFORCE);
+        FE(DIDOI_ASPECTPOSITION);
+        FE(DIDOI_ASPECTVELOCITY);
+    }
+#undef FE
+
+}
+
+static void _dump_EnumObjects_flags(DWORD dwFlags) {
+    if (TRACE_ON(dinput)) {
+	unsigned int   i;
+	DWORD type, instance;
+	static const struct {
+	    DWORD       mask;
+	    const char  *name;
+	} flags[] = {
+#define FE(x) { x, #x}
+	    FE(DIDFT_RELAXIS),
+	    FE(DIDFT_ABSAXIS),
+	    FE(DIDFT_PSHBUTTON),
+	    FE(DIDFT_TGLBUTTON),
+	    FE(DIDFT_POV),
+	    FE(DIDFT_COLLECTION),
+	    FE(DIDFT_NODATA),	    
+	    FE(DIDFT_FFACTUATOR),
+	    FE(DIDFT_FFEFFECTTRIGGER),
+	    FE(DIDFT_OUTPUT),
+	    FE(DIDFT_VENDORDEFINED),
+	    FE(DIDFT_ALIAS),
+	    FE(DIDFT_OPTIONAL)
+#undef FE
+	};
+	type = (dwFlags & 0xFF0000FF);
+	instance = ((dwFlags >> 8) & 0xFFFF);
+	TRACE("Type:");
+	if (type == DIDFT_ALL) {
+	    TRACE(" DIDFT_ALL");
+	} else {
+	    for (i = 0; i < (sizeof(flags) / sizeof(flags[0])); i++) {
+		if (flags[i].mask & type) {
+		    type &= ~flags[i].mask;
+		    TRACE(" %s",flags[i].name);
+		}
+	    }
+	    if (type) {
+                TRACE(" (unhandled: %08x)", type);
+	    }
+	}
+	TRACE(" / Instance: ");
+	if (instance == ((DIDFT_ANYINSTANCE >> 8) & 0xFFFF)) {
+	    TRACE("DIDFT_ANYINSTANCE");
+	} else {
+            TRACE("%3d", instance);
+	}
+    }
+}
+
+void _dump_DIPROPHEADER(LPCDIPROPHEADER diph) {
+    if (TRACE_ON(dinput)) {
+        TRACE("  - dwObj = 0x%08x\n", diph->dwObj);
+        TRACE("  - dwHow = %s\n",
+            ((diph->dwHow == DIPH_DEVICE) ? "DIPH_DEVICE" :
+            ((diph->dwHow == DIPH_BYOFFSET) ? "DIPH_BYOFFSET" :
+            ((diph->dwHow == DIPH_BYID)) ? "DIPH_BYID" : "unknown")));
+    }
+}
+
+void _dump_OBJECTINSTANCEA(const DIDEVICEOBJECTINSTANCEA *ddoi) {
+    TRACE("    - enumerating : %s ('%s') - %2d - 0x%08x - %s - 0x%x\n",
+        debugstr_guid(&ddoi->guidType), _dump_dinput_GUID(&ddoi->guidType), ddoi->dwOfs, ddoi->dwType, ddoi->tszName, ddoi->dwFlags);
+}
+
+void _dump_OBJECTINSTANCEW(const DIDEVICEOBJECTINSTANCEW *ddoi) {
+    TRACE("    - enumerating : %s ('%s'), - %2d - 0x%08x - %s - 0x%x\n",
+        debugstr_guid(&ddoi->guidType), _dump_dinput_GUID(&ddoi->guidType), ddoi->dwOfs, ddoi->dwType, debugstr_w(ddoi->tszName), ddoi->dwFlags);
+}
+
+/* This function is a helper to convert a GUID into any possible DInput GUID out there */
+const char *_dump_dinput_GUID(const GUID *guid) {
+    unsigned int i;
+    static const struct {
+	const GUID *guid;
+	const char *name;
+    } guids[] = {
+#define FE(x) { &x, #x}
+	FE(GUID_XAxis),
+	FE(GUID_YAxis),
+	FE(GUID_ZAxis),
+	FE(GUID_RxAxis),
+	FE(GUID_RyAxis),
+	FE(GUID_RzAxis),
+	FE(GUID_Slider),
+	FE(GUID_Button),
+	FE(GUID_Key),
+	FE(GUID_POV),
+	FE(GUID_Unknown),
+	FE(GUID_SysMouse),
+	FE(GUID_SysKeyboard),
+	FE(GUID_Joystick),
+	FE(GUID_ConstantForce),
+	FE(GUID_RampForce),
+	FE(GUID_Square),
+	FE(GUID_Sine),
+	FE(GUID_Triangle),
+	FE(GUID_SawtoothUp),
+	FE(GUID_SawtoothDown),
+	FE(GUID_Spring),
+	FE(GUID_Damper),
+	FE(GUID_Inertia),
+	FE(GUID_Friction),
+	FE(GUID_CustomForce)
+#undef FE
+    };
+    if (guid == NULL)
+	return "null GUID";
+    for (i = 0; i < (sizeof(guids) / sizeof(guids[0])); i++) {
+	if (IsEqualGUID(guids[i].guid, guid)) {
+	    return guids[i].name;
+	}
+    }
+    return debugstr_guid(guid);
+}
+
+void _dump_DIDATAFORMAT(const DIDATAFORMAT *df) {
+    unsigned int i;
+
+    TRACE("Dumping DIDATAFORMAT structure:\n");
+    TRACE("  - dwSize: %d\n", df->dwSize);
+    if (df->dwSize != sizeof(DIDATAFORMAT)) {
+        WARN("Non-standard DIDATAFORMAT structure size %d\n", df->dwSize);
+    }
+    TRACE("  - dwObjsize: %d\n", df->dwObjSize);
+    if (df->dwObjSize != sizeof(DIOBJECTDATAFORMAT)) {
+        WARN("Non-standard DIOBJECTDATAFORMAT structure size %d\n", df->dwObjSize);
+    }
+    TRACE("  - dwFlags: 0x%08x (", df->dwFlags);
+    switch (df->dwFlags) {
+        case DIDF_ABSAXIS: TRACE("DIDF_ABSAXIS"); break;
+	case DIDF_RELAXIS: TRACE("DIDF_RELAXIS"); break;
+	default: TRACE("unknown"); break;
+    }
+    TRACE(")\n");
+    TRACE("  - dwDataSize: %d\n", df->dwDataSize);
+    TRACE("  - dwNumObjs: %d\n", df->dwNumObjs);
+    
+    for (i = 0; i < df->dwNumObjs; i++) {
+	TRACE("  - Object %d:\n", i);
+	TRACE("      * GUID: %s ('%s')\n", debugstr_guid(df->rgodf[i].pguid), _dump_dinput_GUID(df->rgodf[i].pguid));
+        TRACE("      * dwOfs: %d\n", df->rgodf[i].dwOfs);
+        TRACE("      * dwType: 0x%08x\n", df->rgodf[i].dwType);
+	TRACE("        "); _dump_EnumObjects_flags(df->rgodf[i].dwType); TRACE("\n");
+        TRACE("      * dwFlags: 0x%08x\n", df->rgodf[i].dwFlags);
+	TRACE("        "); _dump_ObjectDataFormat_flags(df->rgodf[i].dwFlags); TRACE("\n");
+    }
+}
+
+/******************************************************************************
+ * Get the default and the app-specific config keys.
+ */
+BOOL get_app_key(HKEY *defkey, HKEY *appkey)
+{
+    char buffer[MAX_PATH+16];
+    DWORD len;
+
+    *appkey = 0;
+
+    /* @@ Wine registry key: HKCU\Software\Wine\DirectInput */
+    if (RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Wine\\DirectInput", defkey))
+        *defkey = 0;
+
+    len = GetModuleFileNameA(0, buffer, MAX_PATH);
+    if (len && len < MAX_PATH)
+    {
+        HKEY tmpkey;
+
+        /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe\DirectInput */
+        if (!RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Wine\\AppDefaults", &tmpkey))
+        {
+            char *p, *appname = buffer;
+            if ((p = strrchr(appname, '/'))) appname = p + 1;
+            if ((p = strrchr(appname, '\\'))) appname = p + 1;
+            strcat(appname, "\\DirectInput");
+
+            if (RegOpenKeyA(tmpkey, appname, appkey)) *appkey = 0;
+            RegCloseKey(tmpkey);
+        }
+    }
+
+    return *defkey || *appkey;
+}
+
+/******************************************************************************
+ * Get a config key from either the app-specific or the default config
+ */
+DWORD get_config_key( HKEY defkey, HKEY appkey, const char *name,
+                             char *buffer, DWORD size )
+{
+    if (appkey && !RegQueryValueExA( appkey, name, 0, NULL, (LPBYTE)buffer, &size ))
+        return 0;
+
+    if (defkey && !RegQueryValueExA( defkey, name, 0, NULL, (LPBYTE)buffer, &size ))
+        return 0;
+
+    return ERROR_FILE_NOT_FOUND;
+}
+
+/* Conversion between internal data buffer and external data buffer */
+void fill_DataFormat(void *out, DWORD size, const void *in, const DataFormat *df)
+{
+    int i;
+    const char *in_c = in;
+    char *out_c = out;
+
+    memset(out, 0, size);
+    if (df->dt == NULL) {
+	/* This means that the app uses Wine's internal data format */
+        memcpy(out, in, min(size, df->internal_format_size));
+    } else {
+	for (i = 0; i < df->size; i++) {
+	    if (df->dt[i].offset_in >= 0) {
+		switch (df->dt[i].size) {
+		    case 1:
+		        TRACE("Copying (c) to %d from %d (value %d)\n",
+                              df->dt[i].offset_out, df->dt[i].offset_in, *(in_c + df->dt[i].offset_in));
+			*(out_c + df->dt[i].offset_out) = *(in_c + df->dt[i].offset_in);
+			break;
+
+		    case 2:
+			TRACE("Copying (s) to %d from %d (value %d)\n",
+			      df->dt[i].offset_out, df->dt[i].offset_in, *((const short *)(in_c + df->dt[i].offset_in)));
+			*((short *)(out_c + df->dt[i].offset_out)) = *((const short *)(in_c + df->dt[i].offset_in));
+			break;
+
+		    case 4:
+			TRACE("Copying (i) to %d from %d (value %d)\n",
+                              df->dt[i].offset_out, df->dt[i].offset_in, *((const int *)(in_c + df->dt[i].offset_in)));
+                        *((int *)(out_c + df->dt[i].offset_out)) = *((const int *)(in_c + df->dt[i].offset_in));
+			break;
+
+		    default:
+			memcpy((out_c + df->dt[i].offset_out), (in_c + df->dt[i].offset_in), df->dt[i].size);
+			break;
+		}
+	    } else {
+		switch (df->dt[i].size) {
+		    case 1:
+		        TRACE("Copying (c) to %d default value %d\n",
+			      df->dt[i].offset_out, df->dt[i].value);
+			*(out_c + df->dt[i].offset_out) = (char) df->dt[i].value;
+			break;
+			
+		    case 2:
+			TRACE("Copying (s) to %d default value %d\n",
+			      df->dt[i].offset_out, df->dt[i].value);
+			*((short *) (out_c + df->dt[i].offset_out)) = (short) df->dt[i].value;
+			break;
+			
+		    case 4:
+			TRACE("Copying (i) to %d default value %d\n",
+			      df->dt[i].offset_out, df->dt[i].value);
+			*((int *) (out_c + df->dt[i].offset_out)) = df->dt[i].value;
+			break;
+			
+		    default:
+			memset((out_c + df->dt[i].offset_out), 0, df->dt[i].size);
+			break;
+		}
+	    }
+	}
+    }
+}
+
+void release_DataFormat(DataFormat * format)
+{
+    TRACE("Deleting DataFormat: %p\n", format);
+
+    HeapFree(GetProcessHeap(), 0, format->dt);
+    format->dt = NULL;
+    HeapFree(GetProcessHeap(), 0, format->offsets);
+    format->offsets = NULL;
+    HeapFree(GetProcessHeap(), 0, format->user_df);
+    format->user_df = NULL;
+}
+
+static inline LPDIOBJECTDATAFORMAT dataformat_to_odf(LPCDIDATAFORMAT df, int idx)
+{
+    if (idx < 0 || idx >= df->dwNumObjs) return NULL;
+    return (LPDIOBJECTDATAFORMAT)((LPBYTE)df->rgodf + idx * df->dwObjSize);
+}
+
+/* dataformat_to_odf_by_type
+ *  Find the Nth object of the selected type in the DataFormat
+ */
+LPDIOBJECTDATAFORMAT dataformat_to_odf_by_type(LPCDIDATAFORMAT df, int n, DWORD type)
+{
+    int i, nfound = 0;
+
+    for (i=0; i < df->dwNumObjs; i++)
+    {
+        LPDIOBJECTDATAFORMAT odf = dataformat_to_odf(df, i);
+
+        if (odf->dwType & type)
+        {
+            if (n == nfound)
+                return odf;
+
+            nfound++;
+        }
+    }
+
+    return NULL;
+}
+
+static HRESULT create_DataFormat(LPCDIDATAFORMAT asked_format, DataFormat *format)
+{
+    DataTransform *dt;
+    unsigned int i, j;
+    int same = 1;
+    int *done;
+    int index = 0;
+    DWORD next = 0;
+
+    if (!format->wine_df) return DIERR_INVALIDPARAM;
+    done = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, asked_format->dwNumObjs * sizeof(int));
+    dt = HeapAlloc(GetProcessHeap(), 0, asked_format->dwNumObjs * sizeof(DataTransform));
+    if (!dt || !done) goto failed;
+
+    if (!(format->offsets = HeapAlloc(GetProcessHeap(), 0, format->wine_df->dwNumObjs * sizeof(int))))
+        goto failed;
+
+    if (!(format->user_df = HeapAlloc(GetProcessHeap(), 0, asked_format->dwSize)))
+        goto failed;
+    memcpy(format->user_df, asked_format, asked_format->dwSize);
+
+    TRACE("Creating DataTransform :\n");
+    
+    for (i = 0; i < format->wine_df->dwNumObjs; i++)
+    {
+        format->offsets[i] = -1;
+
+	for (j = 0; j < asked_format->dwNumObjs; j++) {
+	    if (done[j] == 1)
+		continue;
+	    
+	    if (/* Check if the application either requests any GUID and if not, it if matches
+		 * the GUID of the Wine object.
+		 */
+		((asked_format->rgodf[j].pguid == NULL) ||
+		 (format->wine_df->rgodf[i].pguid == NULL) ||
+		 (IsEqualGUID(format->wine_df->rgodf[i].pguid, asked_format->rgodf[j].pguid)))
+		&&
+		(/* Then check if it accepts any instance id, and if not, if it matches Wine's
+		  * instance id.
+		  */
+		 ((asked_format->rgodf[j].dwType & DIDFT_INSTANCEMASK) == DIDFT_ANYINSTANCE) ||
+		 (DIDFT_GETINSTANCE(asked_format->rgodf[j].dwType) == 0x00FF) || /* This is mentioned in no DX docs, but it works fine - tested on WinXP */
+		 (DIDFT_GETINSTANCE(asked_format->rgodf[j].dwType) == DIDFT_GETINSTANCE(format->wine_df->rgodf[i].dwType)))
+		&&
+		( /* Then if the asked type matches the one Wine provides */
+                 DIDFT_GETTYPE(asked_format->rgodf[j].dwType) & format->wine_df->rgodf[i].dwType))
+            {
+		done[j] = 1;
+		
+		TRACE("Matching :\n");
+		TRACE("   - Asked (%d) :\n", j);
+		TRACE("       * GUID: %s ('%s')\n",
+		      debugstr_guid(asked_format->rgodf[j].pguid),
+		      _dump_dinput_GUID(asked_format->rgodf[j].pguid));
+                TRACE("       * Offset: %3d\n", asked_format->rgodf[j].dwOfs);
+                TRACE("       * dwType: 0x%08x\n", asked_format->rgodf[j].dwType);
+		TRACE("         "); _dump_EnumObjects_flags(asked_format->rgodf[j].dwType); TRACE("\n");
+                TRACE("       * dwFlags: 0x%08x\n", asked_format->rgodf[j].dwFlags);
+		TRACE("         "); _dump_ObjectDataFormat_flags(asked_format->rgodf[j].dwFlags); TRACE("\n");
+		
+		TRACE("   - Wine  (%d) :\n", i);
+		TRACE("       * GUID: %s ('%s')\n",
+                      debugstr_guid(format->wine_df->rgodf[i].pguid),
+                      _dump_dinput_GUID(format->wine_df->rgodf[i].pguid));
+                TRACE("       * Offset: %3d\n", format->wine_df->rgodf[i].dwOfs);
+                TRACE("       * dwType: 0x%08x\n", format->wine_df->rgodf[i].dwType);
+                TRACE("         "); _dump_EnumObjects_flags(format->wine_df->rgodf[i].dwType); TRACE("\n");
+                TRACE("       * dwFlags: 0x%08x\n", format->wine_df->rgodf[i].dwFlags);
+                TRACE("         "); _dump_ObjectDataFormat_flags(format->wine_df->rgodf[i].dwFlags); TRACE("\n");
+		
+                if (format->wine_df->rgodf[i].dwType & DIDFT_BUTTON)
+		    dt[index].size = sizeof(BYTE);
+		else
+		    dt[index].size = sizeof(DWORD);
+                dt[index].offset_in = format->wine_df->rgodf[i].dwOfs;
+                dt[index].offset_out = asked_format->rgodf[j].dwOfs;
+                format->offsets[i]   = asked_format->rgodf[j].dwOfs;
+		dt[index].value = 0;
+                next = next + dt[index].size;
+		
+                if (format->wine_df->rgodf[i].dwOfs != dt[index].offset_out)
+		    same = 0;
+		
+		index++;
+		break;
+	    }
+	}
+    }
+
+    TRACE("Setting to default value :\n");
+    for (j = 0; j < asked_format->dwNumObjs; j++) {
+	if (done[j] == 0) {
+	    TRACE("   - Asked (%d) :\n", j);
+	    TRACE("       * GUID: %s ('%s')\n",
+		  debugstr_guid(asked_format->rgodf[j].pguid),
+		  _dump_dinput_GUID(asked_format->rgodf[j].pguid));
+            TRACE("       * Offset: %3d\n", asked_format->rgodf[j].dwOfs);
+            TRACE("       * dwType: 0x%08x\n", asked_format->rgodf[j].dwType);
+	    TRACE("         "); _dump_EnumObjects_flags(asked_format->rgodf[j].dwType); TRACE("\n");
+            TRACE("       * dwFlags: 0x%08x\n", asked_format->rgodf[j].dwFlags);
+	    TRACE("         "); _dump_ObjectDataFormat_flags(asked_format->rgodf[j].dwFlags); TRACE("\n");
+	    
+	    if (asked_format->rgodf[j].dwType & DIDFT_BUTTON)
+		dt[index].size = sizeof(BYTE);
+	    else
+		dt[index].size = sizeof(DWORD);
+	    dt[index].offset_in  = -1;
+	    dt[index].offset_out = asked_format->rgodf[j].dwOfs;
+            if (asked_format->rgodf[j].dwType & DIDFT_POV)
+                dt[index].value = -1;
+            else
+                dt[index].value = 0;
+	    index++;
+
+	    same = 0;
+	}
+    }
+    
+    format->internal_format_size = format->wine_df->dwDataSize;
+    format->size = index;
+    if (same) {
+	HeapFree(GetProcessHeap(), 0, dt);
+        dt = NULL;
+    }
+    format->dt = dt;
+
+    HeapFree(GetProcessHeap(), 0, done);
+
+    return DI_OK;
+
+failed:
+    HeapFree(GetProcessHeap(), 0, done);
+    HeapFree(GetProcessHeap(), 0, dt);
+    format->dt = NULL;
+    HeapFree(GetProcessHeap(), 0, format->offsets);
+    format->offsets = NULL;
+    HeapFree(GetProcessHeap(), 0, format->user_df);
+    format->user_df = NULL;
+
+    return DIERR_OUTOFMEMORY;
+}
+
+/* find an object by its offset in a data format */
+static int offset_to_object(const DataFormat *df, int offset)
+{
+    int i;
+
+    if (!df->offsets) return -1;
+
+    for (i = 0; i < df->wine_df->dwNumObjs; i++)
+        if (df->offsets[i] == offset) return i;
+
+    return -1;
+}
+
+int id_to_object(LPCDIDATAFORMAT df, int id)
+{
+    int i;
+
+    id &= 0x00ffffff;
+    for (i = 0; i < df->dwNumObjs; i++)
+        if ((dataformat_to_odf(df, i)->dwType & 0x00ffffff) == id)
+            return i;
+
+    return -1;
+}
+
+static int id_to_offset(const DataFormat *df, int id)
+{
+    int obj = id_to_object(df->wine_df, id);
+
+    return obj >= 0 && df->offsets ? df->offsets[obj] : -1;
+}
+
+int find_property(const DataFormat *df, LPCDIPROPHEADER ph)
+{
+    switch (ph->dwHow)
+    {
+        case DIPH_BYID:     return id_to_object(df->wine_df, ph->dwObj);
+        case DIPH_BYOFFSET: return offset_to_object(df, ph->dwObj);
+    }
+    FIXME("Unhandled ph->dwHow=='%04X'\n", (unsigned int)ph->dwHow);
+
+    return -1;
+}
+
+static DWORD semantic_to_obj_id(IDirectInputDeviceImpl* This, DWORD dwSemantic)
+{
+    DWORD type = (0x0000ff00 & dwSemantic) >> 8;
+    DWORD offset = 0x000000ff & dwSemantic;
+    DWORD obj_instance = 0;
+    BOOL found = FALSE;
+    int i;
+
+    for (i = 0; i < This->data_format.wine_df->dwNumObjs; i++)
+    {
+        LPDIOBJECTDATAFORMAT odf = dataformat_to_odf(This->data_format.wine_df, i);
+
+        if (odf->dwOfs == offset)
+        {
+            obj_instance = DIDFT_GETINSTANCE(odf->dwType);
+            found = TRUE;
+            break;
+        }
+    }
+
+    if (!found) return 0;
+
+    if (type & DIDFT_AXIS)   type = DIDFT_RELAXIS;
+    if (type & DIDFT_BUTTON) type = DIDFT_PSHBUTTON;
+
+    return type | (0x0000ff00 & (obj_instance << 8));
+}
+
+/*
+ * get_mapping_key
+ * Retrieves an open registry key to save the mapping, parametrized for an username,
+ * specific device and specific action mapping guid.
+ */
+static HKEY get_mapping_key(const WCHAR *device, const WCHAR *username, const WCHAR *guid)
+{
+    static const WCHAR subkey[] = {
+        'S','o','f','t','w','a','r','e','\\',
+        'W','i','n','e','\\',
+        'D','i','r','e','c','t','I','n','p','u','t','\\',
+        'M','a','p','p','i','n','g','s','\\','%','s','\\','%','s','\\','%','s','\0'};
+    HKEY hkey;
+    WCHAR *keyname;
+
+    keyname = HeapAlloc(GetProcessHeap(), 0,
+        sizeof(WCHAR) * (lstrlenW(subkey) + strlenW(username) + strlenW(device) + strlenW(guid)));
+    sprintfW(keyname, subkey, username, device, guid);
+
+    /* The key used is HKCU\Software\Wine\DirectInput\Mappings\[username]\[device]\[mapping_guid] */
+    if (RegCreateKeyW(HKEY_CURRENT_USER, keyname, &hkey))
+        hkey = 0;
+
+    HeapFree(GetProcessHeap(), 0, keyname);
+
+    return hkey;
+}
+
+static HRESULT save_mapping_settings(IDirectInputDevice8W *iface, LPDIACTIONFORMATW lpdiaf, LPCWSTR lpszUsername)
+{
+    WCHAR *guid_str = NULL;
+    DIDEVICEINSTANCEW didev;
+    HKEY hkey;
+    int i;
+
+    didev.dwSize = sizeof(didev);
+    IDirectInputDevice8_GetDeviceInfo(iface, &didev);
+
+    if (StringFromCLSID(&lpdiaf->guidActionMap, &guid_str) != S_OK)
+        return DI_SETTINGSNOTSAVED;
+
+    hkey = get_mapping_key(didev.tszInstanceName, lpszUsername, guid_str);
+
+    if (!hkey)
+    {
+        CoTaskMemFree(guid_str);
+        return DI_SETTINGSNOTSAVED;
+    }
+
+    /* Write each of the actions mapped for this device.
+       Format is "dwSemantic"="dwObjID" and key is of type REG_DWORD
+    */
+    for (i = 0; i < lpdiaf->dwNumActions; i++)
+    {
+        static const WCHAR format[] = {'%','x','\0'};
+        WCHAR label[9];
+
+        if (IsEqualGUID(&didev.guidInstance, &lpdiaf->rgoAction[i].guidInstance) &&
+            lpdiaf->rgoAction[i].dwHow != DIAH_UNMAPPED)
+        {
+             sprintfW(label, format, lpdiaf->rgoAction[i].dwSemantic);
+             RegSetValueExW(hkey, label, 0, REG_DWORD, (const BYTE*) &lpdiaf->rgoAction[i].dwObjID, sizeof(DWORD));
+        }
+    }
+
+    RegCloseKey(hkey);
+    CoTaskMemFree(guid_str);
+
+    return DI_OK;
+}
+
+static BOOL load_mapping_settings(IDirectInputDeviceImpl *This, LPDIACTIONFORMATW lpdiaf, const WCHAR *username)
+{
+    HKEY hkey;
+    WCHAR *guid_str;
+    DIDEVICEINSTANCEW didev;
+    int i, mapped = 0;
+
+    didev.dwSize = sizeof(didev);
+    IDirectInputDevice8_GetDeviceInfo(&This->IDirectInputDevice8W_iface, &didev);
+
+    if (StringFromCLSID(&lpdiaf->guidActionMap, &guid_str) != S_OK)
+        return FALSE;
+
+    hkey = get_mapping_key(didev.tszInstanceName, username, guid_str);
+
+    if (!hkey)
+    {
+        CoTaskMemFree(guid_str);
+        return FALSE;
+    }
+
+    /* Try to read each action in the DIACTIONFORMAT from registry */
+    for (i = 0; i < lpdiaf->dwNumActions; i++)
+    {
+        static const WCHAR format[] = {'%','x','\0'};
+        DWORD id, size = sizeof(DWORD);
+        WCHAR label[9];
+
+        sprintfW(label, format, lpdiaf->rgoAction[i].dwSemantic);
+
+        if (!RegQueryValueExW(hkey, label, 0, NULL, (LPBYTE) &id, &size))
+        {
+            lpdiaf->rgoAction[i].dwObjID = id;
+            lpdiaf->rgoAction[i].guidInstance = didev.guidInstance;
+            lpdiaf->rgoAction[i].dwHow = DIAH_DEFAULT;
+            mapped += 1;
+        }
+    }
+
+    RegCloseKey(hkey);
+    CoTaskMemFree(guid_str);
+
+    return mapped > 0;
+}
+
+HRESULT _build_action_map(LPDIRECTINPUTDEVICE8W iface, LPDIACTIONFORMATW lpdiaf, LPCWSTR lpszUserName, DWORD dwFlags, DWORD devMask, LPCDIDATAFORMAT df)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8W(iface);
+    WCHAR username[MAX_PATH];
+    DWORD username_size = MAX_PATH;
+    int i;
+    BOOL load_success = FALSE, has_actions = FALSE;
+
+    /* Unless asked the contrary by these flags, try to load a previous mapping */
+    if (!(dwFlags & DIDBAM_HWDEFAULTS))
+    {
+        /* Retrieve logged user name if necessary */
+        if (lpszUserName == NULL)
+            GetUserNameW(username, &username_size);
+        else
+            lstrcpynW(username, lpszUserName, MAX_PATH);
+
+        load_success = load_mapping_settings(This, lpdiaf, username);
+    }
+
+    if (load_success) return DI_OK;
+
+    for (i=0; i < lpdiaf->dwNumActions; i++)
+    {
+        /* Don't touch a user configured action */
+        if (lpdiaf->rgoAction[i].dwHow == DIAH_USERCONFIG) continue;
+
+        if ((lpdiaf->rgoAction[i].dwSemantic & devMask) == devMask)
+        {
+            DWORD obj_id = semantic_to_obj_id(This, lpdiaf->rgoAction[i].dwSemantic);
+            DWORD type = DIDFT_GETTYPE(obj_id);
+            DWORD inst = DIDFT_GETINSTANCE(obj_id);
+
+            LPDIOBJECTDATAFORMAT odf;
+
+            if (type == DIDFT_PSHBUTTON) type = DIDFT_BUTTON;
+            if (type == DIDFT_RELAXIS) type = DIDFT_AXIS;
+
+            /* Make sure the object exists */
+            odf = dataformat_to_odf_by_type(df, inst, type);
+
+            if (odf != NULL)
+            {
+                lpdiaf->rgoAction[i].dwObjID = obj_id;
+                lpdiaf->rgoAction[i].guidInstance = This->guid;
+                lpdiaf->rgoAction[i].dwHow = DIAH_DEFAULT;
+                has_actions = TRUE;
+            }
+        }
+        else if (!(dwFlags & DIDBAM_PRESERVE))
+        {
+            /* We must clear action data belonging to other devices */
+            memset(&lpdiaf->rgoAction[i].guidInstance, 0, sizeof(GUID));
+            lpdiaf->rgoAction[i].dwHow = DIAH_UNMAPPED;
+        }
+    }
+
+    if (!has_actions) return DI_NOEFFECT;
+
+    return  IDirectInputDevice8WImpl_BuildActionMap(iface, lpdiaf, lpszUserName, dwFlags);
+}
+
+HRESULT _set_action_map(LPDIRECTINPUTDEVICE8W iface, LPDIACTIONFORMATW lpdiaf, LPCWSTR lpszUserName, DWORD dwFlags, LPCDIDATAFORMAT df)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8W(iface);
+    DIDATAFORMAT data_format;
+    DIOBJECTDATAFORMAT *obj_df = NULL;
+    DIPROPDWORD dp;
+    DIPROPRANGE dpr;
+    DIPROPSTRING dps;
+    WCHAR username[MAX_PATH];
+    DWORD username_size = MAX_PATH;
+    int i, action = 0, num_actions = 0;
+    unsigned int offset = 0;
+
+    if (This->acquired) return DIERR_ACQUIRED;
+
+    data_format.dwSize = sizeof(data_format);
+    data_format.dwObjSize = sizeof(DIOBJECTDATAFORMAT);
+    data_format.dwFlags = DIDF_RELAXIS;
+    data_format.dwDataSize = lpdiaf->dwDataSize;
+
+    /* Count the actions */
+    for (i=0; i < lpdiaf->dwNumActions; i++)
+        if (IsEqualGUID(&This->guid, &lpdiaf->rgoAction[i].guidInstance))
+            num_actions++;
+
+    if (num_actions == 0) return DI_NOEFFECT;
+
+    This->num_actions = num_actions;
+
+    /* Construct the dataformat and actionmap */
+    obj_df = HeapAlloc(GetProcessHeap(), 0, sizeof(DIOBJECTDATAFORMAT)*num_actions);
+    data_format.rgodf = (LPDIOBJECTDATAFORMAT)obj_df;
+    data_format.dwNumObjs = num_actions;
+
+    HeapFree(GetProcessHeap(), 0, This->action_map);
+    This->action_map = HeapAlloc(GetProcessHeap(), 0, sizeof(ActionMap)*num_actions);
+
+    for (i = 0; i < lpdiaf->dwNumActions; i++)
+    {
+        if (IsEqualGUID(&This->guid, &lpdiaf->rgoAction[i].guidInstance))
+        {
+            DWORD inst = DIDFT_GETINSTANCE(lpdiaf->rgoAction[i].dwObjID);
+            DWORD type = DIDFT_GETTYPE(lpdiaf->rgoAction[i].dwObjID);
+            LPDIOBJECTDATAFORMAT obj;
+
+            if (type == DIDFT_PSHBUTTON) type = DIDFT_BUTTON;
+            if (type == DIDFT_RELAXIS) type = DIDFT_AXIS;
+
+            obj = dataformat_to_odf_by_type(df, inst, type);
+
+            memcpy(&obj_df[action], obj, df->dwObjSize);
+
+            This->action_map[action].uAppData = lpdiaf->rgoAction[i].uAppData;
+            This->action_map[action].offset = offset;
+            obj_df[action].dwOfs = offset;
+            offset += (type & DIDFT_BUTTON) ? 1 : 4;
+
+            action++;
+        }
+    }
+
+    IDirectInputDevice8_SetDataFormat(iface, &data_format);
+
+    HeapFree(GetProcessHeap(), 0, obj_df);
+
+    /* Set the device properties according to the action format */
+    dpr.diph.dwSize = sizeof(DIPROPRANGE);
+    dpr.lMin = lpdiaf->lAxisMin;
+    dpr.lMax = lpdiaf->lAxisMax;
+    dpr.diph.dwHeaderSize = sizeof(DIPROPHEADER);
+    dpr.diph.dwHow = DIPH_DEVICE;
+    IDirectInputDevice8_SetProperty(iface, DIPROP_RANGE, &dpr.diph);
+
+    if (lpdiaf->dwBufferSize > 0)
+    {
+        dp.diph.dwSize = sizeof(DIPROPDWORD);
+        dp.dwData = lpdiaf->dwBufferSize;
+        dp.diph.dwHeaderSize = sizeof(DIPROPHEADER);
+        dp.diph.dwHow = DIPH_DEVICE;
+        IDirectInputDevice8_SetProperty(iface, DIPROP_BUFFERSIZE, &dp.diph);
+    }
+
+    /* Retrieve logged user name if necessary */
+    if (lpszUserName == NULL)
+        GetUserNameW(username, &username_size);
+    else
+        lstrcpynW(username, lpszUserName, MAX_PATH);
+
+    dps.diph.dwSize = sizeof(dps);
+    dps.diph.dwHeaderSize = sizeof(DIPROPHEADER);
+    dps.diph.dwObj = 0;
+    dps.diph.dwHow = DIPH_DEVICE;
+    if (dwFlags & DIDSAM_NOUSER)
+        dps.wsz[0] = '\0';
+    else
+        lstrcpynW(dps.wsz, username, sizeof(dps.wsz)/sizeof(WCHAR));
+    IDirectInputDevice8_SetProperty(iface, DIPROP_USERNAME, &dps.diph);
+
+    /* Save the settings to disk */
+    save_mapping_settings(iface, lpdiaf, username);
+
+    return DI_OK;
+}
+
+/******************************************************************************
+ *	queue_event - add new event to the ring queue
+ */
+
+void queue_event(LPDIRECTINPUTDEVICE8A iface, int inst_id, DWORD data, DWORD time, DWORD seq)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    int next_pos, ofs = id_to_offset(&This->data_format, inst_id);
+
+    /* Event is being set regardless of the queue state */
+    if (This->hEvent) SetEvent(This->hEvent);
+
+    PostMessageW(GetDesktopWindow(), WM_WINE_NOTIFY_ACTIVITY, 0, 0);
+
+    if (!This->queue_len || This->overflow || ofs < 0) return;
+
+    next_pos = (This->queue_head + 1) % This->queue_len;
+    if (next_pos == This->queue_tail)
+    {
+        TRACE(" queue overflowed\n");
+        This->overflow = TRUE;
+        return;
+    }
+
+    TRACE(" queueing %d at offset %d (queue head %d / size %d)\n",
+          data, ofs, This->queue_head, This->queue_len);
+
+    This->data_queue[This->queue_head].dwOfs       = ofs;
+    This->data_queue[This->queue_head].dwData      = data;
+    This->data_queue[This->queue_head].dwTimeStamp = time;
+    This->data_queue[This->queue_head].dwSequence  = seq;
+
+    /* Set uAppData by means of action mapping */
+    if (This->num_actions > 0)
+    {
+        int i;
+        for (i=0; i < This->num_actions; i++)
+        {
+            if (This->action_map[i].offset == ofs)
+            {
+                TRACE("Offset %d mapped to uAppData %lu\n", ofs, This->action_map[i].uAppData);
+                This->data_queue[This->queue_head].uAppData = This->action_map[i].uAppData;
+                break;
+            }
+        }
+    }
+
+    This->queue_head = next_pos;
+    /* Send event if asked */
+}
+
+/******************************************************************************
+ *	Acquire
+ */
+
+HRESULT WINAPI IDirectInputDevice2WImpl_Acquire(LPDIRECTINPUTDEVICE8W iface)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8W(iface);
+    HRESULT res;
+
+    TRACE("(%p)\n", This);
+
+    if (!This->data_format.user_df) return DIERR_INVALIDPARAM;
+    if (This->dwCoopLevel & DISCL_FOREGROUND && This->win != GetForegroundWindow())
+        return DIERR_OTHERAPPHASPRIO;
+
+    EnterCriticalSection(&This->crit);
+    res = This->acquired ? S_FALSE : DI_OK;
+    This->acquired = 1;
+    LeaveCriticalSection(&This->crit);
+
+    TRACE("=%d\n", res);
+    if (res == DI_OK)
+        check_dinput_hooks(iface, TRUE);
+
+    return res;
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_Acquire(LPDIRECTINPUTDEVICE8A iface)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_Acquire(IDirectInputDevice8W_from_impl(This));
+}
+
+
+/******************************************************************************
+ *	Unacquire
+ */
+
+HRESULT WINAPI IDirectInputDevice2WImpl_Unacquire(LPDIRECTINPUTDEVICE8W iface)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8W(iface);
+    HRESULT res;
+
+    TRACE("(%p)\n", This);
+
+    EnterCriticalSection(&This->crit);
+    res = !This->acquired ? DI_NOEFFECT : DI_OK;
+    This->acquired = 0;
+    LeaveCriticalSection(&This->crit);
+    if (res == DI_OK)
+        check_dinput_hooks(iface, FALSE);
+
+    return res;
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_Unacquire(LPDIRECTINPUTDEVICE8A iface)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_Unacquire(IDirectInputDevice8W_from_impl(This));
+}
+
+/******************************************************************************
+ *	IDirectInputDeviceA
+ */
+
+HRESULT WINAPI IDirectInputDevice2WImpl_SetDataFormat(LPDIRECTINPUTDEVICE8W iface, LPCDIDATAFORMAT df)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8W(iface);
+    HRESULT res = DI_OK;
+
+    if (!df) return E_POINTER;
+    TRACE("(%p) %p\n", This, df);
+    _dump_DIDATAFORMAT(df);
+
+    if (df->dwSize != sizeof(DIDATAFORMAT)) return DIERR_INVALIDPARAM;
+    if (This->acquired) return DIERR_ACQUIRED;
+
+    EnterCriticalSection(&This->crit);
+
+    release_DataFormat(&This->data_format);
+    res = create_DataFormat(df, &This->data_format);
+
+    LeaveCriticalSection(&This->crit);
+    return res;
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_SetDataFormat(LPDIRECTINPUTDEVICE8A iface, LPCDIDATAFORMAT df)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_SetDataFormat(IDirectInputDevice8W_from_impl(This), df);
+}
+
+/******************************************************************************
+  *     SetCooperativeLevel
+  *
+  *  Set cooperative level and the source window for the events.
+  */
+HRESULT WINAPI IDirectInputDevice2WImpl_SetCooperativeLevel(LPDIRECTINPUTDEVICE8W iface, HWND hwnd, DWORD dwflags)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(%p) %p,0x%08x\n", This, hwnd, dwflags);
+    _dump_cooperativelevel_DI(dwflags);
+
+    if ((dwflags & (DISCL_EXCLUSIVE | DISCL_NONEXCLUSIVE)) == 0 ||
+        (dwflags & (DISCL_EXCLUSIVE | DISCL_NONEXCLUSIVE)) == (DISCL_EXCLUSIVE | DISCL_NONEXCLUSIVE) ||
+        (dwflags & (DISCL_FOREGROUND | DISCL_BACKGROUND)) == 0 ||
+        (dwflags & (DISCL_FOREGROUND | DISCL_BACKGROUND)) == (DISCL_FOREGROUND | DISCL_BACKGROUND))
+        return DIERR_INVALIDPARAM;
+
+    if (hwnd && GetWindowLongW(hwnd, GWL_STYLE) & WS_CHILD) return E_HANDLE;
+
+    if (!hwnd && dwflags == (DISCL_NONEXCLUSIVE | DISCL_BACKGROUND))
+        hwnd = GetDesktopWindow();
+
+    if (!IsWindow(hwnd)) return E_HANDLE;
+
+    /* For security reasons native does not allow exclusive background level
+       for mouse and keyboard only */
+    if (dwflags & DISCL_EXCLUSIVE && dwflags & DISCL_BACKGROUND &&
+        (IsEqualGUID(&This->guid, &GUID_SysMouse) ||
+         IsEqualGUID(&This->guid, &GUID_SysKeyboard)))
+        return DIERR_UNSUPPORTED;
+
+    /* Store the window which asks for the mouse */
+    EnterCriticalSection(&This->crit);
+    This->win = hwnd;
+    This->dwCoopLevel = dwflags;
+    LeaveCriticalSection(&This->crit);
+
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_SetCooperativeLevel(LPDIRECTINPUTDEVICE8A iface, HWND hwnd, DWORD dwflags)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_SetCooperativeLevel(IDirectInputDevice8W_from_impl(This), hwnd, dwflags);
+}
+
+/******************************************************************************
+  *     SetEventNotification : specifies event to be sent on state change
+  */
+HRESULT WINAPI IDirectInputDevice2WImpl_SetEventNotification(LPDIRECTINPUTDEVICE8W iface, HANDLE event)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(%p) %p\n", This, event);
+
+    EnterCriticalSection(&This->crit);
+    This->hEvent = event;
+    LeaveCriticalSection(&This->crit);
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_SetEventNotification(LPDIRECTINPUTDEVICE8A iface, HANDLE event)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_SetEventNotification(IDirectInputDevice8W_from_impl(This), event);
+}
+
+
+ULONG WINAPI IDirectInputDevice2WImpl_Release(LPDIRECTINPUTDEVICE8W iface)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8W(iface);
+    ULONG ref = InterlockedDecrement(&(This->ref));
+
+    TRACE("(%p) releasing from %d\n", This, ref + 1);
+
+    if (ref) return ref;
+
+    IDirectInputDevice_Unacquire(iface);
+    /* Reset the FF state, free all effects, etc */
+    IDirectInputDevice8_SendForceFeedbackCommand(iface, DISFFC_RESET);
+
+    HeapFree(GetProcessHeap(), 0, This->data_queue);
+
+    /* Free data format */
+    HeapFree(GetProcessHeap(), 0, This->data_format.wine_df->rgodf);
+    HeapFree(GetProcessHeap(), 0, This->data_format.wine_df);
+    release_DataFormat(&This->data_format);
+
+    /* Free action mapping */
+    HeapFree(GetProcessHeap(), 0, This->action_map);
+
+    EnterCriticalSection( &This->dinput->crit );
+    list_remove( &This->entry );
+    LeaveCriticalSection( &This->dinput->crit );
+
+    IDirectInput_Release(&This->dinput->IDirectInput7A_iface);
+    This->crit.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection(&This->crit);
+
+    HeapFree(GetProcessHeap(), 0, This);
+
+    return DI_OK;
+}
+
+ULONG WINAPI IDirectInputDevice2AImpl_Release(LPDIRECTINPUTDEVICE8A iface)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_Release(IDirectInputDevice8W_from_impl(This));
+}
+
+HRESULT WINAPI IDirectInputDevice2WImpl_QueryInterface(LPDIRECTINPUTDEVICE8W iface, REFIID riid, LPVOID *ppobj)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(%p this=%p,%s,%p)\n", iface, This, debugstr_guid(riid), ppobj);
+    if (IsEqualGUID(&IID_IUnknown, riid) ||
+        IsEqualGUID(&IID_IDirectInputDeviceA,  riid) ||
+        IsEqualGUID(&IID_IDirectInputDevice2A, riid) ||
+        IsEqualGUID(&IID_IDirectInputDevice7A, riid) ||
+        IsEqualGUID(&IID_IDirectInputDevice8A, riid))
+    {
+        IDirectInputDevice2_AddRef(iface);
+        *ppobj = IDirectInputDevice8A_from_impl(This);
+        return DI_OK;
+    }
+    if (IsEqualGUID(&IID_IDirectInputDeviceW,  riid) ||
+        IsEqualGUID(&IID_IDirectInputDevice2W, riid) ||
+        IsEqualGUID(&IID_IDirectInputDevice7W, riid) ||
+        IsEqualGUID(&IID_IDirectInputDevice8W, riid))
+    {
+        IDirectInputDevice2_AddRef(iface);
+        *ppobj = IDirectInputDevice8W_from_impl(This);
+        return DI_OK;
+    }
+
+    WARN("Unsupported interface!\n");
+    return E_FAIL;
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_QueryInterface(LPDIRECTINPUTDEVICE8A iface, REFIID riid, LPVOID *ppobj)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_QueryInterface(IDirectInputDevice8W_from_impl(This), riid, ppobj);
+}
+
+ULONG WINAPI IDirectInputDevice2WImpl_AddRef(LPDIRECTINPUTDEVICE8W iface)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8W(iface);
+    return InterlockedIncrement(&This->ref);
+}
+
+ULONG WINAPI IDirectInputDevice2AImpl_AddRef(LPDIRECTINPUTDEVICE8A iface)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_AddRef(IDirectInputDevice8W_from_impl(This));
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_EnumObjects(LPDIRECTINPUTDEVICE8A iface,
+        LPDIENUMDEVICEOBJECTSCALLBACKA lpCallback, LPVOID lpvRef, DWORD dwFlags)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    DIDEVICEOBJECTINSTANCEA ddoi;
+    int i;
+
+    TRACE("(%p) %p,%p flags:%08x)\n", iface, lpCallback, lpvRef, dwFlags);
+    TRACE("  - flags = ");
+    _dump_EnumObjects_flags(dwFlags);
+    TRACE("\n");
+
+    /* Only the fields till dwFFMaxForce are relevant */
+    memset(&ddoi, 0, sizeof(ddoi));
+    ddoi.dwSize = FIELD_OFFSET(DIDEVICEOBJECTINSTANCEA, dwFFMaxForce);
+
+    for (i = 0; i < This->data_format.wine_df->dwNumObjs; i++)
+    {
+        LPDIOBJECTDATAFORMAT odf = dataformat_to_odf(This->data_format.wine_df, i);
+
+        if (dwFlags != DIDFT_ALL && !(dwFlags & DIDFT_GETTYPE(odf->dwType))) continue;
+        if (IDirectInputDevice_GetObjectInfo(iface, &ddoi, odf->dwType, DIPH_BYID) != DI_OK)
+            continue;
+
+	if (lpCallback(&ddoi, lpvRef) != DIENUM_CONTINUE) break;
+    }
+
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice2WImpl_EnumObjects(LPDIRECTINPUTDEVICE8W iface,
+        LPDIENUMDEVICEOBJECTSCALLBACKW lpCallback, LPVOID lpvRef, DWORD dwFlags)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8W(iface);
+    DIDEVICEOBJECTINSTANCEW ddoi;
+    int i;
+
+    TRACE("(%p) %p,%p flags:%08x)\n", iface, lpCallback, lpvRef, dwFlags);
+    TRACE("  - flags = ");
+    _dump_EnumObjects_flags(dwFlags);
+    TRACE("\n");
+
+    /* Only the fields till dwFFMaxForce are relevant */
+    memset(&ddoi, 0, sizeof(ddoi));
+    ddoi.dwSize = FIELD_OFFSET(DIDEVICEOBJECTINSTANCEW, dwFFMaxForce);
+
+    for (i = 0; i < This->data_format.wine_df->dwNumObjs; i++)
+    {
+        LPDIOBJECTDATAFORMAT odf = dataformat_to_odf(This->data_format.wine_df, i);
+
+        if (dwFlags != DIDFT_ALL && !(dwFlags & DIDFT_GETTYPE(odf->dwType))) continue;
+        if (IDirectInputDevice_GetObjectInfo(iface, &ddoi, odf->dwType, DIPH_BYID) != DI_OK)
+            continue;
+
+	if (lpCallback(&ddoi, lpvRef) != DIENUM_CONTINUE) break;
+    }
+
+    return DI_OK;
+}
+
+/******************************************************************************
+ *	GetProperty
+ */
+
+HRESULT WINAPI IDirectInputDevice2WImpl_GetProperty(LPDIRECTINPUTDEVICE8W iface, REFGUID rguid, LPDIPROPHEADER pdiph)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(%p) %s,%p\n", iface, debugstr_guid(rguid), pdiph);
+    _dump_DIPROPHEADER(pdiph);
+
+    if (!IS_DIPROP(rguid)) return DI_OK;
+
+    switch (LOWORD(rguid))
+    {
+        case (DWORD_PTR) DIPROP_BUFFERSIZE:
+        {
+            LPDIPROPDWORD pd = (LPDIPROPDWORD)pdiph;
+
+            if (pdiph->dwSize != sizeof(DIPROPDWORD)) return DIERR_INVALIDPARAM;
+
+            pd->dwData = This->queue_len;
+            TRACE("buffersize = %d\n", pd->dwData);
+            break;
+        }
+        case (DWORD_PTR) DIPROP_USERNAME:
+        {
+            LPDIPROPSTRING ps = (LPDIPROPSTRING)pdiph;
+            struct DevicePlayer *device_player;
+
+            if (pdiph->dwSize != sizeof(DIPROPSTRING)) return DIERR_INVALIDPARAM;
+
+            LIST_FOR_EACH_ENTRY(device_player, &This->dinput->device_players,
+                struct DevicePlayer, entry)
+            {
+                if (IsEqualGUID(&device_player->instance_guid, &This->guid))
+                {
+                    if (*device_player->username)
+                    {
+                        lstrcpynW(ps->wsz, device_player->username, sizeof(ps->wsz)/sizeof(WCHAR));
+                        return DI_OK;
+                    }
+                    else break;
+                }
+            }
+            return S_FALSE;
+        }
+        case (DWORD_PTR) DIPROP_VIDPID:
+            FIXME("DIPROP_VIDPID not implemented\n");
+            return DIERR_UNSUPPORTED;
+        default:
+            FIXME("Unknown property %s\n", debugstr_guid(rguid));
+            return DIERR_INVALIDPARAM;
+    }
+
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_GetProperty(LPDIRECTINPUTDEVICE8A iface, REFGUID rguid, LPDIPROPHEADER pdiph)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_GetProperty(IDirectInputDevice8W_from_impl(This), rguid, pdiph);
+}
+
+/******************************************************************************
+ *	SetProperty
+ */
+
+HRESULT WINAPI IDirectInputDevice2WImpl_SetProperty(
+        LPDIRECTINPUTDEVICE8W iface, REFGUID rguid, LPCDIPROPHEADER pdiph)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(%p) %s,%p\n", iface, debugstr_guid(rguid), pdiph);
+    _dump_DIPROPHEADER(pdiph);
+
+    if (!IS_DIPROP(rguid)) return DI_OK;
+
+    switch (LOWORD(rguid))
+    {
+        case (DWORD_PTR) DIPROP_AXISMODE:
+        {
+            LPCDIPROPDWORD pd = (LPCDIPROPDWORD)pdiph;
+
+            if (pdiph->dwSize != sizeof(DIPROPDWORD)) return DIERR_INVALIDPARAM;
+            if (pdiph->dwHow == DIPH_DEVICE && pdiph->dwObj) return DIERR_INVALIDPARAM;
+            if (This->acquired) return DIERR_ACQUIRED;
+            if (pdiph->dwHow != DIPH_DEVICE) return DIERR_UNSUPPORTED;
+            if (!This->data_format.user_df) return DI_OK;
+
+            TRACE("Axis mode: %s\n", pd->dwData == DIPROPAXISMODE_ABS ? "absolute" :
+                                                                        "relative");
+
+            EnterCriticalSection(&This->crit);
+            This->data_format.user_df->dwFlags &= ~DIDFT_AXIS;
+            This->data_format.user_df->dwFlags |= pd->dwData == DIPROPAXISMODE_ABS ?
+                                                  DIDF_ABSAXIS : DIDF_RELAXIS;
+            LeaveCriticalSection(&This->crit);
+            break;
+        }
+        case (DWORD_PTR) DIPROP_BUFFERSIZE:
+        {
+            LPCDIPROPDWORD pd = (LPCDIPROPDWORD)pdiph;
+
+            if (pdiph->dwSize != sizeof(DIPROPDWORD)) return DIERR_INVALIDPARAM;
+            if (This->acquired) return DIERR_ACQUIRED;
+
+            TRACE("buffersize = %d\n", pd->dwData);
+
+            EnterCriticalSection(&This->crit);
+            HeapFree(GetProcessHeap(), 0, This->data_queue);
+
+            This->data_queue = !pd->dwData ? NULL : HeapAlloc(GetProcessHeap(), 0,
+                                pd->dwData * sizeof(DIDEVICEOBJECTDATA));
+            This->queue_head = This->queue_tail = This->overflow = 0;
+            This->queue_len  = pd->dwData;
+
+            LeaveCriticalSection(&This->crit);
+            break;
+        }
+        case (DWORD_PTR) DIPROP_USERNAME:
+        {
+            LPCDIPROPSTRING ps = (LPCDIPROPSTRING)pdiph;
+            struct DevicePlayer *device_player;
+            BOOL found = FALSE;
+
+            if (pdiph->dwSize != sizeof(DIPROPSTRING)) return DIERR_INVALIDPARAM;
+
+            LIST_FOR_EACH_ENTRY(device_player, &This->dinput->device_players,
+                struct DevicePlayer, entry)
+            {
+                if (IsEqualGUID(&device_player->instance_guid, &This->guid))
+                {
+                    found = TRUE;
+                    break;
+                }
+            }
+            if (!found && (device_player =
+                    HeapAlloc(GetProcessHeap(), 0, sizeof(struct DevicePlayer))))
+            {
+                list_add_tail(&This->dinput->device_players, &device_player->entry);
+                device_player->instance_guid = This->guid;
+            }
+            if (device_player)
+                lstrcpynW(device_player->username, ps->wsz,
+                    sizeof(device_player->username)/sizeof(WCHAR));
+            break;
+        }
+        default:
+            WARN("Unknown property %s\n", debugstr_guid(rguid));
+            return DIERR_UNSUPPORTED;
+    }
+
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_SetProperty(
+        LPDIRECTINPUTDEVICE8A iface, REFGUID rguid, LPCDIPROPHEADER pdiph)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_SetProperty(IDirectInputDevice8W_from_impl(This), rguid, pdiph);
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_GetObjectInfo(
+	LPDIRECTINPUTDEVICE8A iface,
+	LPDIDEVICEOBJECTINSTANCEA pdidoi,
+	DWORD dwObj,
+	DWORD dwHow)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    DIDEVICEOBJECTINSTANCEW didoiW;
+    HRESULT res;
+
+    if (!pdidoi ||
+        (pdidoi->dwSize != sizeof(DIDEVICEOBJECTINSTANCEA) &&
+         pdidoi->dwSize != sizeof(DIDEVICEOBJECTINSTANCE_DX3A)))
+        return DIERR_INVALIDPARAM;
+
+    didoiW.dwSize = sizeof(didoiW);
+    res = IDirectInputDevice2WImpl_GetObjectInfo(IDirectInputDevice8W_from_impl(This), &didoiW, dwObj, dwHow);
+    if (res == DI_OK)
+    {
+        DWORD dwSize = pdidoi->dwSize;
+
+        memset(pdidoi, 0, pdidoi->dwSize);
+        pdidoi->dwSize   = dwSize;
+        pdidoi->guidType = didoiW.guidType;
+        pdidoi->dwOfs    = didoiW.dwOfs;
+        pdidoi->dwType   = didoiW.dwType;
+        pdidoi->dwFlags  = didoiW.dwFlags;
+    }
+
+    return res;
+}
+
+HRESULT WINAPI IDirectInputDevice2WImpl_GetObjectInfo(
+	LPDIRECTINPUTDEVICE8W iface,
+	LPDIDEVICEOBJECTINSTANCEW pdidoi,
+	DWORD dwObj,
+	DWORD dwHow)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8W(iface);
+    DWORD dwSize;
+    LPDIOBJECTDATAFORMAT odf;
+    int idx = -1;
+
+    TRACE("(%p) %d(0x%08x) -> %p\n", This, dwHow, dwObj, pdidoi);
+
+    if (!pdidoi ||
+        (pdidoi->dwSize != sizeof(DIDEVICEOBJECTINSTANCEW) &&
+         pdidoi->dwSize != sizeof(DIDEVICEOBJECTINSTANCE_DX3W)))
+        return DIERR_INVALIDPARAM;
+
+    switch (dwHow)
+    {
+    case DIPH_BYOFFSET:
+        if (!This->data_format.offsets) break;
+        for (idx = This->data_format.wine_df->dwNumObjs - 1; idx >= 0; idx--)
+            if (This->data_format.offsets[idx] == dwObj) break;
+        break;
+    case DIPH_BYID:
+        dwObj &= 0x00ffffff;
+        for (idx = This->data_format.wine_df->dwNumObjs - 1; idx >= 0; idx--)
+            if ((dataformat_to_odf(This->data_format.wine_df, idx)->dwType & 0x00ffffff) == dwObj)
+                break;
+        break;
+
+    case DIPH_BYUSAGE:
+        FIXME("dwHow = DIPH_BYUSAGE not implemented\n");
+        break;
+    default:
+        WARN("invalid parameter: dwHow = %08x\n", dwHow);
+        return DIERR_INVALIDPARAM;
+    }
+    if (idx < 0) return DIERR_OBJECTNOTFOUND;
+
+    odf = dataformat_to_odf(This->data_format.wine_df, idx);
+    dwSize = pdidoi->dwSize; /* save due to memset below */
+    memset(pdidoi, 0, pdidoi->dwSize);
+    pdidoi->dwSize   = dwSize;
+    if (odf->pguid) pdidoi->guidType = *odf->pguid;
+    pdidoi->dwOfs    = This->data_format.offsets ? This->data_format.offsets[idx] : odf->dwOfs;
+    pdidoi->dwType   = odf->dwType;
+    pdidoi->dwFlags  = odf->dwFlags;
+
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice2WImpl_GetDeviceData(LPDIRECTINPUTDEVICE8W iface, DWORD dodsize,
+                                                      LPDIDEVICEOBJECTDATA dod, LPDWORD entries, DWORD flags)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8W(iface);
+    HRESULT ret = DI_OK;
+    int len;
+
+    TRACE("(%p) %p -> %p(%d) x%d, 0x%08x\n",
+          This, dod, entries, entries ? *entries : 0, dodsize, flags);
+
+    if (This->dinput->dwVersion == 0x0800 || dodsize == sizeof(DIDEVICEOBJECTDATA_DX3))
+    {
+        if (!This->queue_len) return DIERR_NOTBUFFERED;
+        if (!This->acquired) return DIERR_NOTACQUIRED;
+    }
+
+    if (!This->queue_len)
+        return DI_OK;
+    if (dodsize < sizeof(DIDEVICEOBJECTDATA_DX3))
+        return DIERR_INVALIDPARAM;
+
+    IDirectInputDevice2_Poll(iface);
+    EnterCriticalSection(&This->crit);
+
+    len = This->queue_head - This->queue_tail;
+    if (len < 0) len += This->queue_len;
+
+    if ((*entries != INFINITE) && (len > *entries)) len = *entries;
+
+    if (dod)
+    {
+        int i;
+        for (i = 0; i < len; i++)
+        {
+            int n = (This->queue_tail + i) % This->queue_len;
+            memcpy((char *)dod + dodsize * i, This->data_queue + n, dodsize);
+        }
+    }
+    *entries = len;
+
+    if (This->overflow && This->dinput->dwVersion == 0x0800)
+        ret = DI_BUFFEROVERFLOW;
+
+    if (!(flags & DIGDD_PEEK))
+    {
+        /* Advance reading position */
+        This->queue_tail = (This->queue_tail + len) % This->queue_len;
+        This->overflow = FALSE;
+    }
+
+    LeaveCriticalSection(&This->crit);
+
+    TRACE("Returning %d events queued\n", *entries);
+    return ret;
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_GetDeviceData(LPDIRECTINPUTDEVICE8A iface, DWORD dodsize,
+                                                      LPDIDEVICEOBJECTDATA dod, LPDWORD entries, DWORD flags)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_GetDeviceData(IDirectInputDevice8W_from_impl(This), dodsize, dod, entries, flags);
+}
+
+HRESULT WINAPI IDirectInputDevice2WImpl_RunControlPanel(LPDIRECTINPUTDEVICE8W iface, HWND hwndOwner, DWORD dwFlags)
+{
+    FIXME("(this=%p,%p,0x%08x): stub!\n", iface, hwndOwner, dwFlags);
+
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_RunControlPanel(LPDIRECTINPUTDEVICE8A iface, HWND hwndOwner, DWORD dwFlags)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_RunControlPanel(IDirectInputDevice8W_from_impl(This), hwndOwner, dwFlags);
+}
+
+HRESULT WINAPI IDirectInputDevice2WImpl_Initialize(LPDIRECTINPUTDEVICE8W iface, HINSTANCE hinst, DWORD dwVersion,
+                                                   REFGUID rguid)
+{
+    FIXME("(this=%p,%p,%d,%s): stub!\n", iface, hinst, dwVersion, debugstr_guid(rguid));
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_Initialize(LPDIRECTINPUTDEVICE8A iface, HINSTANCE hinst, DWORD dwVersion,
+                                                   REFGUID rguid)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_Initialize(IDirectInputDevice8W_from_impl(This), hinst, dwVersion, rguid);
+}
+
+/******************************************************************************
+ *	IDirectInputDevice2A
+ */
+
+HRESULT WINAPI IDirectInputDevice2WImpl_CreateEffect(LPDIRECTINPUTDEVICE8W iface, REFGUID rguid, LPCDIEFFECT lpeff,
+                                                     LPDIRECTINPUTEFFECT *ppdef, LPUNKNOWN pUnkOuter)
+{
+    FIXME("(this=%p,%s,%p,%p,%p): stub!\n", iface, debugstr_guid(rguid), lpeff, ppdef, pUnkOuter);
+
+    FIXME("not available in the generic implementation\n");
+    *ppdef = NULL;
+    return DIERR_UNSUPPORTED;
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_CreateEffect(LPDIRECTINPUTDEVICE8A iface, REFGUID rguid, LPCDIEFFECT lpeff,
+                                                     LPDIRECTINPUTEFFECT *ppdef, LPUNKNOWN pUnkOuter)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_CreateEffect(IDirectInputDevice8W_from_impl(This), rguid, lpeff, ppdef, pUnkOuter);
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_EnumEffects(
+	LPDIRECTINPUTDEVICE8A iface,
+	LPDIENUMEFFECTSCALLBACKA lpCallback,
+	LPVOID lpvRef,
+	DWORD dwFlags)
+{
+    FIXME("(this=%p,%p,%p,0x%08x): stub!\n",
+	  iface, lpCallback, lpvRef, dwFlags);
+    
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice2WImpl_EnumEffects(
+	LPDIRECTINPUTDEVICE8W iface,
+	LPDIENUMEFFECTSCALLBACKW lpCallback,
+	LPVOID lpvRef,
+	DWORD dwFlags)
+{
+    FIXME("(this=%p,%p,%p,0x%08x): stub!\n",
+	  iface, lpCallback, lpvRef, dwFlags);
+    
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_GetEffectInfo(
+	LPDIRECTINPUTDEVICE8A iface,
+	LPDIEFFECTINFOA lpdei,
+	REFGUID rguid)
+{
+    FIXME("(this=%p,%p,%s): stub!\n",
+	  iface, lpdei, debugstr_guid(rguid));
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice2WImpl_GetEffectInfo(
+	LPDIRECTINPUTDEVICE8W iface,
+	LPDIEFFECTINFOW lpdei,
+	REFGUID rguid)
+{
+    FIXME("(this=%p,%p,%s): stub!\n",
+	  iface, lpdei, debugstr_guid(rguid));
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice2WImpl_GetForceFeedbackState(LPDIRECTINPUTDEVICE8W iface, LPDWORD pdwOut)
+{
+    FIXME("(this=%p,%p): stub!\n", iface, pdwOut);
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_GetForceFeedbackState(LPDIRECTINPUTDEVICE8A iface, LPDWORD pdwOut)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_GetForceFeedbackState(IDirectInputDevice8W_from_impl(This), pdwOut);
+}
+
+HRESULT WINAPI IDirectInputDevice2WImpl_SendForceFeedbackCommand(LPDIRECTINPUTDEVICE8W iface, DWORD dwFlags)
+{
+    TRACE("(%p) 0x%08x:\n", iface, dwFlags);
+    return DI_NOEFFECT;
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_SendForceFeedbackCommand(LPDIRECTINPUTDEVICE8A iface, DWORD dwFlags)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_SendForceFeedbackCommand(IDirectInputDevice8W_from_impl(This), dwFlags);
+}
+
+HRESULT WINAPI IDirectInputDevice2WImpl_EnumCreatedEffectObjects(LPDIRECTINPUTDEVICE8W iface,
+        LPDIENUMCREATEDEFFECTOBJECTSCALLBACK lpCallback, LPVOID lpvRef, DWORD dwFlags)
+{
+    FIXME("(this=%p,%p,%p,0x%08x): stub!\n", iface, lpCallback, lpvRef, dwFlags);
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_EnumCreatedEffectObjects(LPDIRECTINPUTDEVICE8A iface,
+        LPDIENUMCREATEDEFFECTOBJECTSCALLBACK lpCallback, LPVOID lpvRef, DWORD dwFlags)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_EnumCreatedEffectObjects(IDirectInputDevice8W_from_impl(This), lpCallback, lpvRef, dwFlags);
+}
+
+HRESULT WINAPI IDirectInputDevice2WImpl_Escape(LPDIRECTINPUTDEVICE8W iface, LPDIEFFESCAPE lpDIEEsc)
+{
+    FIXME("(this=%p,%p): stub!\n", iface, lpDIEEsc);
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_Escape(LPDIRECTINPUTDEVICE8A iface, LPDIEFFESCAPE lpDIEEsc)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_Escape(IDirectInputDevice8W_from_impl(This), lpDIEEsc);
+}
+
+HRESULT WINAPI IDirectInputDevice2WImpl_Poll(LPDIRECTINPUTDEVICE8W iface)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    if (!This->acquired) return DIERR_NOTACQUIRED;
+
+    check_dinput_events();
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_Poll(LPDIRECTINPUTDEVICE8A iface)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_Poll(IDirectInputDevice8W_from_impl(This));
+}
+
+HRESULT WINAPI IDirectInputDevice2WImpl_SendDeviceData(LPDIRECTINPUTDEVICE8W iface, DWORD cbObjectData,
+                                                       LPCDIDEVICEOBJECTDATA rgdod, LPDWORD pdwInOut,
+                                                       DWORD dwFlags)
+{
+    FIXME("(this=%p,0x%08x,%p,%p,0x%08x): stub!\n", iface, cbObjectData, rgdod, pdwInOut, dwFlags);
+
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice2AImpl_SendDeviceData(LPDIRECTINPUTDEVICE8A iface, DWORD cbObjectData,
+                                                       LPCDIDEVICEOBJECTDATA rgdod, LPDWORD pdwInOut,
+                                                       DWORD dwFlags)
+{
+    IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return IDirectInputDevice2WImpl_SendDeviceData(IDirectInputDevice8W_from_impl(This), cbObjectData, rgdod,
+                                                   pdwInOut, dwFlags);
+}
+
+HRESULT WINAPI IDirectInputDevice7AImpl_EnumEffectsInFile(LPDIRECTINPUTDEVICE8A iface,
+							  LPCSTR lpszFileName,
+							  LPDIENUMEFFECTSINFILECALLBACK pec,
+							  LPVOID pvRef,
+							  DWORD dwFlags)
+{
+    FIXME("(%p)->(%s,%p,%p,%08x): stub !\n", iface, lpszFileName, pec, pvRef, dwFlags);
+    
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice7WImpl_EnumEffectsInFile(LPDIRECTINPUTDEVICE8W iface,
+							  LPCWSTR lpszFileName,
+							  LPDIENUMEFFECTSINFILECALLBACK pec,
+							  LPVOID pvRef,
+							  DWORD dwFlags)
+{
+    FIXME("(%p)->(%s,%p,%p,%08x): stub !\n", iface, debugstr_w(lpszFileName), pec, pvRef, dwFlags);
+    
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice7AImpl_WriteEffectToFile(LPDIRECTINPUTDEVICE8A iface,
+							  LPCSTR lpszFileName,
+							  DWORD dwEntries,
+							  LPDIFILEEFFECT rgDiFileEft,
+							  DWORD dwFlags)
+{
+    FIXME("(%p)->(%s,%08x,%p,%08x): stub !\n", iface, lpszFileName, dwEntries, rgDiFileEft, dwFlags);
+    
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice7WImpl_WriteEffectToFile(LPDIRECTINPUTDEVICE8W iface,
+							  LPCWSTR lpszFileName,
+							  DWORD dwEntries,
+							  LPDIFILEEFFECT rgDiFileEft,
+							  DWORD dwFlags)
+{
+    FIXME("(%p)->(%s,%08x,%p,%08x): stub !\n", iface, debugstr_w(lpszFileName), dwEntries, rgDiFileEft, dwFlags);
+    
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice8WImpl_BuildActionMap(LPDIRECTINPUTDEVICE8W iface,
+						       LPDIACTIONFORMATW lpdiaf,
+						       LPCWSTR lpszUserName,
+						       DWORD dwFlags)
+{
+    FIXME("(%p)->(%p,%s,%08x): semi-stub !\n", iface, lpdiaf, debugstr_w(lpszUserName), dwFlags);
+#define X(x) if (dwFlags & x) FIXME("\tdwFlags =|"#x"\n");
+	X(DIDBAM_DEFAULT)
+	X(DIDBAM_PRESERVE)
+	X(DIDBAM_INITIALIZE)
+	X(DIDBAM_HWDEFAULTS)
+#undef X
+  
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice8AImpl_GetImageInfo(LPDIRECTINPUTDEVICE8A iface,
+						     LPDIDEVICEIMAGEINFOHEADERA lpdiDevImageInfoHeader)
+{
+    FIXME("(%p)->(%p): stub !\n", iface, lpdiDevImageInfoHeader);
+    
+    return DI_OK;
+}
+
+HRESULT WINAPI IDirectInputDevice8WImpl_GetImageInfo(LPDIRECTINPUTDEVICE8W iface,
+						     LPDIDEVICEIMAGEINFOHEADERW lpdiDevImageInfoHeader)
+{
+    FIXME("(%p)->(%p): stub !\n", iface, lpdiDevImageInfoHeader);
+    
+    return DI_OK;
+}
diff --git a/dlls/dinput8/device_private.h b/dlls/dinput8/device_private.h
new file mode 100644
index 0000000..52bbec4
--- /dev/null
+++ b/dlls/dinput8/device_private.h
@@ -0,0 +1,251 @@
+/*
+ * Copyright 2000 Lionel Ulmer
+ * Copyright 2000-2001 TransGaming Technologies Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_DLLS_DINPUT_DINPUTDEVICE_PRIVATE_H
+#define __WINE_DLLS_DINPUT_DINPUTDEVICE_PRIVATE_H
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "dinput.h"
+#include "wine/list.h"
+#include "dinput_private.h"
+
+typedef struct
+{
+    int size;
+    int offset_in;
+    int offset_out;
+    int value;
+} DataTransform;
+
+typedef struct
+{
+    int                         size;
+    int                         internal_format_size;
+    DataTransform              *dt;
+
+    int                        *offsets;     /* object offsets */
+    LPDIDATAFORMAT              wine_df;     /* wine internal data format */
+    LPDIDATAFORMAT              user_df;     /* user defined data format */
+} DataFormat;
+
+typedef struct
+{
+    unsigned int offset;
+    UINT_PTR uAppData;
+} ActionMap;
+
+/* Device implementation */
+typedef struct IDirectInputDeviceImpl IDirectInputDeviceImpl;
+struct IDirectInputDeviceImpl
+{
+    IDirectInputDevice8A        IDirectInputDevice8A_iface;
+    IDirectInputDevice8W        IDirectInputDevice8W_iface;
+    LONG                        ref;
+    GUID                        guid;
+    CRITICAL_SECTION            crit;
+    IDirectInputImpl           *dinput;
+    struct list                 entry;       /* entry into IDirectInput devices list */
+    HANDLE                      hEvent;
+    DWORD                       dwCoopLevel;
+    HWND                        win;
+    int                         acquired;
+    DI_EVENT_PROC               event_proc;  /* function to receive mouse & keyboard events */
+
+    LPDIDEVICEOBJECTDATA        data_queue;  /* buffer for 'GetDeviceData'.                 */
+    int                         queue_len;   /* size of the queue - set in 'SetProperty'    */
+    int                         queue_head;  /* position to write new event into queue      */
+    int                         queue_tail;  /* next event to read from queue               */
+    BOOL                        overflow;    /* return DI_BUFFEROVERFLOW in 'GetDeviceData' */
+
+    DataFormat                  data_format; /* user data format and wine to user format converter */
+
+    /* Action mapping */
+    int                         num_actions; /* number of actions mapped */
+    ActionMap                  *action_map;  /* array of mappings */
+};
+
+extern BOOL get_app_key(HKEY*, HKEY*) DECLSPEC_HIDDEN;
+extern DWORD get_config_key(HKEY, HKEY, const char*, char*, DWORD) DECLSPEC_HIDDEN;
+
+/* Routines to do DataFormat / WineFormat conversions */
+extern void fill_DataFormat(void *out, DWORD size, const void *in, const DataFormat *df)  DECLSPEC_HIDDEN;
+extern void release_DataFormat(DataFormat *df)  DECLSPEC_HIDDEN;
+extern void queue_event(LPDIRECTINPUTDEVICE8A iface, int inst_id, DWORD data, DWORD time, DWORD seq) DECLSPEC_HIDDEN;
+/* Helper functions to work with data format */
+extern int id_to_object(LPCDIDATAFORMAT df, int id) DECLSPEC_HIDDEN;
+extern int find_property(const DataFormat *df, LPCDIPROPHEADER ph) DECLSPEC_HIDDEN;
+
+/* Common joystick stuff */
+typedef struct
+{
+    LONG lDevMin;
+    LONG lDevMax;
+    LONG lMin;
+    LONG lMax;
+    LONG lDeadZone;
+    LONG lSaturation;
+} ObjProps;
+
+extern DWORD joystick_map_pov(const POINTL *p) DECLSPEC_HIDDEN;
+extern LONG joystick_map_axis(ObjProps *props, int val) DECLSPEC_HIDDEN;
+
+typedef struct
+{
+    struct list entry;
+    LPDIRECTINPUTEFFECT ref;
+} effect_list_item;
+
+extern const GUID DInput_Wine_Keyboard_GUID DECLSPEC_HIDDEN;
+extern const GUID DInput_Wine_Mouse_GUID DECLSPEC_HIDDEN;
+
+/* Various debug tools */
+extern void _dump_DIPROPHEADER(LPCDIPROPHEADER diph)  DECLSPEC_HIDDEN;
+extern void _dump_OBJECTINSTANCEA(const DIDEVICEOBJECTINSTANCEA *ddoi)  DECLSPEC_HIDDEN;
+extern void _dump_OBJECTINSTANCEW(const DIDEVICEOBJECTINSTANCEW *ddoi)  DECLSPEC_HIDDEN;
+extern void _dump_DIDATAFORMAT(const DIDATAFORMAT *df)  DECLSPEC_HIDDEN;
+extern const char *_dump_dinput_GUID(const GUID *guid)  DECLSPEC_HIDDEN;
+
+extern LPDIOBJECTDATAFORMAT dataformat_to_odf_by_type(LPCDIDATAFORMAT df, int n, DWORD type)   DECLSPEC_HIDDEN;
+
+extern HRESULT _build_action_map(LPDIRECTINPUTDEVICE8W iface, LPDIACTIONFORMATW lpdiaf, LPCWSTR lpszUserName, DWORD dwFlags, DWORD devMask, LPCDIDATAFORMAT df)  DECLSPEC_HIDDEN;
+extern HRESULT _set_action_map(LPDIRECTINPUTDEVICE8W iface, LPDIACTIONFORMATW lpdiaf, LPCWSTR lpszUserName, DWORD dwFlags, LPCDIDATAFORMAT df) DECLSPEC_HIDDEN;
+
+/* And the stubs */
+extern HRESULT WINAPI IDirectInputDevice2AImpl_Acquire(LPDIRECTINPUTDEVICE8A iface) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_Acquire(LPDIRECTINPUTDEVICE8W iface) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_Unacquire(LPDIRECTINPUTDEVICE8A iface) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_Unacquire(LPDIRECTINPUTDEVICE8W iface) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_SetDataFormat(LPDIRECTINPUTDEVICE8A iface, LPCDIDATAFORMAT df) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_SetDataFormat(LPDIRECTINPUTDEVICE8W iface, LPCDIDATAFORMAT df) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_SetCooperativeLevel(LPDIRECTINPUTDEVICE8A iface, HWND hwnd, DWORD dwflags) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_SetCooperativeLevel(LPDIRECTINPUTDEVICE8W iface, HWND hwnd, DWORD dwflags) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_SetEventNotification(LPDIRECTINPUTDEVICE8A iface, HANDLE hnd) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_SetEventNotification(LPDIRECTINPUTDEVICE8W iface, HANDLE hnd) DECLSPEC_HIDDEN;
+extern ULONG WINAPI IDirectInputDevice2AImpl_Release(LPDIRECTINPUTDEVICE8A iface)  DECLSPEC_HIDDEN;
+extern ULONG WINAPI IDirectInputDevice2WImpl_Release(LPDIRECTINPUTDEVICE8W iface) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_QueryInterface(LPDIRECTINPUTDEVICE8A iface, REFIID riid, LPVOID *ppobj) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_QueryInterface(LPDIRECTINPUTDEVICE8W iface, REFIID riid, LPVOID *ppobj) DECLSPEC_HIDDEN;
+extern ULONG WINAPI IDirectInputDevice2AImpl_AddRef(LPDIRECTINPUTDEVICE8A iface) DECLSPEC_HIDDEN;
+extern ULONG WINAPI IDirectInputDevice2WImpl_AddRef(LPDIRECTINPUTDEVICE8W iface) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_EnumObjects(
+	LPDIRECTINPUTDEVICE8A iface,
+	LPDIENUMDEVICEOBJECTSCALLBACKA lpCallback,
+	LPVOID lpvRef,
+	DWORD dwFlags)  DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_EnumObjects(
+	LPDIRECTINPUTDEVICE8W iface,
+	LPDIENUMDEVICEOBJECTSCALLBACKW lpCallback,
+	LPVOID lpvRef,
+	DWORD dwFlags)  DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_GetProperty(LPDIRECTINPUTDEVICE8A iface, REFGUID rguid, LPDIPROPHEADER pdiph) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_GetProperty(LPDIRECTINPUTDEVICE8W iface, REFGUID rguid, LPDIPROPHEADER pdiph) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_SetProperty(LPDIRECTINPUTDEVICE8A iface, REFGUID rguid, LPCDIPROPHEADER pdiph) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_SetProperty(LPDIRECTINPUTDEVICE8W iface, REFGUID rguid, LPCDIPROPHEADER pdiph) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_GetObjectInfo(
+	LPDIRECTINPUTDEVICE8A iface,
+	LPDIDEVICEOBJECTINSTANCEA pdidoi,
+	DWORD dwObj,
+	DWORD dwHow)  DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_GetObjectInfo(LPDIRECTINPUTDEVICE8W iface, 
+							     LPDIDEVICEOBJECTINSTANCEW pdidoi,
+							     DWORD dwObj,
+							     DWORD dwHow) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_GetDeviceData(LPDIRECTINPUTDEVICE8A iface, DWORD dodsize, LPDIDEVICEOBJECTDATA dod,
+                                                             LPDWORD entries, DWORD flags) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_GetDeviceData(LPDIRECTINPUTDEVICE8W iface, DWORD dodsize, LPDIDEVICEOBJECTDATA dod,
+                                                             LPDWORD entries, DWORD flags) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_RunControlPanel(LPDIRECTINPUTDEVICE8A iface, HWND hwndOwner, DWORD dwFlags) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_RunControlPanel(LPDIRECTINPUTDEVICE8W iface, HWND hwndOwner, DWORD dwFlags) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_Initialize(LPDIRECTINPUTDEVICE8A iface, HINSTANCE hinst, DWORD dwVersion,
+                                                          REFGUID rguid) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_Initialize(LPDIRECTINPUTDEVICE8W iface, HINSTANCE hinst, DWORD dwVersion,
+                                                          REFGUID rguid) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_CreateEffect(LPDIRECTINPUTDEVICE8A iface, REFGUID rguid, LPCDIEFFECT lpeff,
+                                                            LPDIRECTINPUTEFFECT *ppdef, LPUNKNOWN pUnkOuter) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_CreateEffect(LPDIRECTINPUTDEVICE8W iface, REFGUID rguid, LPCDIEFFECT lpeff,
+                                                            LPDIRECTINPUTEFFECT *ppdef, LPUNKNOWN pUnkOuter) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_EnumEffects(
+	LPDIRECTINPUTDEVICE8A iface,
+	LPDIENUMEFFECTSCALLBACKA lpCallback,
+	LPVOID lpvRef,
+	DWORD dwFlags)  DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_EnumEffects(
+	LPDIRECTINPUTDEVICE8W iface,
+	LPDIENUMEFFECTSCALLBACKW lpCallback,
+	LPVOID lpvRef,
+	DWORD dwFlags)  DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_GetEffectInfo(
+	LPDIRECTINPUTDEVICE8A iface,
+	LPDIEFFECTINFOA lpdei,
+	REFGUID rguid)  DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_GetEffectInfo(
+	LPDIRECTINPUTDEVICE8W iface,
+	LPDIEFFECTINFOW lpdei,
+	REFGUID rguid)  DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_GetForceFeedbackState(LPDIRECTINPUTDEVICE8A iface, LPDWORD pdwOut) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_GetForceFeedbackState(LPDIRECTINPUTDEVICE8W iface, LPDWORD pdwOut) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_SendForceFeedbackCommand(LPDIRECTINPUTDEVICE8A iface, DWORD dwFlags) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_SendForceFeedbackCommand(LPDIRECTINPUTDEVICE8W iface, DWORD dwFlags) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_EnumCreatedEffectObjects(LPDIRECTINPUTDEVICE8A iface,
+                                                                        LPDIENUMCREATEDEFFECTOBJECTSCALLBACK lpCallback,
+                                                                        LPVOID lpvRef, DWORD dwFlags) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_EnumCreatedEffectObjects(LPDIRECTINPUTDEVICE8W iface,
+                                                                        LPDIENUMCREATEDEFFECTOBJECTSCALLBACK lpCallback,
+                                                                        LPVOID lpvRef, DWORD dwFlags) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_Escape(LPDIRECTINPUTDEVICE8A iface, LPDIEFFESCAPE lpDIEEsc) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_Escape(LPDIRECTINPUTDEVICE8W iface, LPDIEFFESCAPE lpDIEEsc) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_Poll(LPDIRECTINPUTDEVICE8A iface) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_Poll(LPDIRECTINPUTDEVICE8W iface) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2AImpl_SendDeviceData(LPDIRECTINPUTDEVICE8A iface, DWORD cbObjectData,
+                                                              LPCDIDEVICEOBJECTDATA rgdod, LPDWORD pdwInOut, DWORD dwFlags) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice2WImpl_SendDeviceData(LPDIRECTINPUTDEVICE8W iface, DWORD cbObjectData,
+                                                              LPCDIDEVICEOBJECTDATA rgdod, LPDWORD pdwInOut, DWORD dwFlags) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice7AImpl_EnumEffectsInFile(LPDIRECTINPUTDEVICE8A iface,
+								 LPCSTR lpszFileName,
+								 LPDIENUMEFFECTSINFILECALLBACK pec,
+								 LPVOID pvRef,
+								 DWORD dwFlags)  DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice7WImpl_EnumEffectsInFile(LPDIRECTINPUTDEVICE8W iface,
+								 LPCWSTR lpszFileName,
+								 LPDIENUMEFFECTSINFILECALLBACK pec,
+								 LPVOID pvRef,
+								 DWORD dwFlags)  DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice7AImpl_WriteEffectToFile(LPDIRECTINPUTDEVICE8A iface,
+								 LPCSTR lpszFileName,
+								 DWORD dwEntries,
+								 LPDIFILEEFFECT rgDiFileEft,
+								 DWORD dwFlags)  DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice7WImpl_WriteEffectToFile(LPDIRECTINPUTDEVICE8W iface,
+								 LPCWSTR lpszFileName,
+								 DWORD dwEntries,
+								 LPDIFILEEFFECT rgDiFileEft,
+								 DWORD dwFlags)  DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice8WImpl_BuildActionMap(LPDIRECTINPUTDEVICE8W iface,
+							      LPDIACTIONFORMATW lpdiaf,
+							      LPCWSTR lpszUserName,
+							      DWORD dwFlags) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice8AImpl_GetImageInfo(LPDIRECTINPUTDEVICE8A iface,
+							    LPDIDEVICEIMAGEINFOHEADERA lpdiDevImageInfoHeader) DECLSPEC_HIDDEN;
+extern HRESULT WINAPI IDirectInputDevice8WImpl_GetImageInfo(LPDIRECTINPUTDEVICE8W iface,
+							    LPDIDEVICEIMAGEINFOHEADERW lpdiDevImageInfoHeader) DECLSPEC_HIDDEN;
+
+#endif /* __WINE_DLLS_DINPUT_DINPUTDEVICE_PRIVATE_H */
diff --git a/dlls/dinput8/dinput8_main.c b/dlls/dinput8/dinput8_main.c
index 9824c76..c4e0077 100644
--- a/dlls/dinput8/dinput8_main.c
+++ b/dlls/dinput8/dinput8_main.c
@@ -24,37 +24,1398 @@
 #include <string.h>
 
 #define COBJMACROS
+#define NONAMELESSUNION
 
 #include "wine/debug.h"
+#include "wine/unicode.h"
 #include "windef.h"
 #include "winbase.h"
 #include "winerror.h"
 #include "objbase.h"
 #include "rpcproxy.h"
-#include "dinput.h"
+#include "initguid.h"
+#include "dinput_private.h"
+#include "device_private.h"
+#include "dinputd.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(dinput);
 
 static HINSTANCE instance;
-static LONG dll_count;
 
-/*
- * Dll lifetime tracking declaration
+static const IDirectInput7AVtbl ddi7avt;
+static const IDirectInput7WVtbl ddi7wvt;
+static const IDirectInput8AVtbl ddi8avt;
+static const IDirectInput8WVtbl ddi8wvt;
+static const IDirectInputJoyConfig8Vtbl JoyConfig8vt;
+
+static inline IDirectInputImpl *impl_from_IDirectInput7A( IDirectInput7A *iface )
+{
+    return CONTAINING_RECORD( iface, IDirectInputImpl, IDirectInput7A_iface );
+}
+
+static inline IDirectInputImpl *impl_from_IDirectInput7W( IDirectInput7W *iface )
+{
+    return CONTAINING_RECORD( iface, IDirectInputImpl, IDirectInput7W_iface );
+}
+
+static inline IDirectInputImpl *impl_from_IDirectInput8A( IDirectInput8A *iface )
+{
+    return CONTAINING_RECORD( iface, IDirectInputImpl, IDirectInput8A_iface );
+}
+
+static inline IDirectInputImpl *impl_from_IDirectInput8W( IDirectInput8W *iface )
+{
+    return CONTAINING_RECORD( iface, IDirectInputImpl, IDirectInput8W_iface );
+}
+
+static inline IDirectInputDeviceImpl *impl_from_IDirectInputDevice8W(IDirectInputDevice8W *iface)
+{
+    return CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8W_iface);
+}
+
+static const struct dinput_device *dinput_devices[] =
+{
+    &mouse_device,
+    &keyboard_device,
+    &joystick_linuxinput_device,
+    &joystick_linux_device,
+    &joystick_osx_device
+};
+
+static HINSTANCE DINPUT_instance = NULL;
+
+static BOOL check_hook_thread(void);
+static CRITICAL_SECTION dinput_hook_crit;
+static struct list direct_input_list = LIST_INIT( direct_input_list );
+
+static HRESULT initialize_directinput_instance(IDirectInputImpl *This, DWORD dwVersion);
+static void uninitialize_directinput_instance(IDirectInputImpl *This);
+
+static HRESULT create_directinput_instance(REFIID riid, LPVOID *ppDI, IDirectInputImpl **out)
+{
+    IDirectInputImpl *This = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IDirectInputImpl) );
+    HRESULT hr;
+
+    if (!This)
+        return E_OUTOFMEMORY;
+
+    This->IDirectInput7A_iface.lpVtbl = &ddi7avt;
+    This->IDirectInput7W_iface.lpVtbl = &ddi7wvt;
+    This->IDirectInput8A_iface.lpVtbl = &ddi8avt;
+    This->IDirectInput8W_iface.lpVtbl = &ddi8wvt;
+    This->IDirectInputJoyConfig8_iface.lpVtbl = &JoyConfig8vt;
+
+    hr = IDirectInput_QueryInterface( &This->IDirectInput7A_iface, riid, ppDI );
+    if (FAILED(hr))
+    {
+        HeapFree( GetProcessHeap(), 0, This );
+        return hr;
+    }
+
+    if (out) *out = This;
+    return DI_OK;
+}
+
+
+static const char *_dump_DIDEVTYPE_value(DWORD dwDevType, DWORD dwVersion)
+{
+    if (dwVersion < 0x0800) {
+        switch (dwDevType) {
+            case 0: return "All devices";
+            case DIDEVTYPE_MOUSE: return "DIDEVTYPE_MOUSE";
+            case DIDEVTYPE_KEYBOARD: return "DIDEVTYPE_KEYBOARD";
+            case DIDEVTYPE_JOYSTICK: return "DIDEVTYPE_JOYSTICK";
+            case DIDEVTYPE_DEVICE: return "DIDEVTYPE_DEVICE";
+            default: return "Unknown";
+        }
+    } else {
+        switch (dwDevType) {
+            case DI8DEVCLASS_ALL: return "All devices";
+            case DI8DEVCLASS_POINTER: return "DI8DEVCLASS_POINTER";
+            case DI8DEVCLASS_KEYBOARD: return "DI8DEVCLASS_KEYBOARD";
+            case DI8DEVCLASS_DEVICE: return "DI8DEVCLASS_DEVICE";
+            case DI8DEVCLASS_GAMECTRL: return "DI8DEVCLASS_GAMECTRL";
+            default: return "Unknown";
+        }
+    }
+}
+
+static void _dump_EnumDevices_dwFlags(DWORD dwFlags)
+{
+    if (TRACE_ON(dinput)) {
+	unsigned int   i;
+	static const struct {
+	    DWORD       mask;
+	    const char  *name;
+	} flags[] = {
+#define FE(x) { x, #x}
+	    FE(DIEDFL_ALLDEVICES),
+	    FE(DIEDFL_ATTACHEDONLY),
+	    FE(DIEDFL_FORCEFEEDBACK),
+	    FE(DIEDFL_INCLUDEALIASES),
+            FE(DIEDFL_INCLUDEPHANTOMS),
+            FE(DIEDFL_INCLUDEHIDDEN)
+#undef FE
+	};
+	TRACE(" flags: ");
+	if (dwFlags == 0) {
+	    TRACE("DIEDFL_ALLDEVICES\n");
+	    return;
+	}
+	for (i = 0; i < (sizeof(flags) / sizeof(flags[0])); i++)
+	    if (flags[i].mask & dwFlags)
+		TRACE("%s ",flags[i].name);
+    }
+    TRACE("\n");
+}
+
+static void _dump_diactionformatA(LPDIACTIONFORMATA lpdiActionFormat)
+{
+    unsigned int i;
+
+    TRACE("diaf.dwSize = %d\n", lpdiActionFormat->dwSize);
+    TRACE("diaf.dwActionSize = %d\n", lpdiActionFormat->dwActionSize);
+    TRACE("diaf.dwDataSize = %d\n", lpdiActionFormat->dwDataSize);
+    TRACE("diaf.dwNumActions = %d\n", lpdiActionFormat->dwNumActions);
+    TRACE("diaf.rgoAction = %p\n", lpdiActionFormat->rgoAction);
+    TRACE("diaf.guidActionMap = %s\n", debugstr_guid(&lpdiActionFormat->guidActionMap));
+    TRACE("diaf.dwGenre = 0x%08x\n", lpdiActionFormat->dwGenre);
+    TRACE("diaf.dwBufferSize = %d\n", lpdiActionFormat->dwBufferSize);
+    TRACE("diaf.lAxisMin = %d\n", lpdiActionFormat->lAxisMin);
+    TRACE("diaf.lAxisMax = %d\n", lpdiActionFormat->lAxisMax);
+    TRACE("diaf.hInstString = %p\n", lpdiActionFormat->hInstString);
+    TRACE("diaf.ftTimeStamp ...\n");
+    TRACE("diaf.dwCRC = 0x%x\n", lpdiActionFormat->dwCRC);
+    TRACE("diaf.tszActionMap = %s\n", debugstr_a(lpdiActionFormat->tszActionMap));
+    for (i = 0; i < lpdiActionFormat->dwNumActions; i++)
+    {
+        TRACE("diaf.rgoAction[%u]:\n", i);
+        TRACE("\tuAppData=0x%lx\n", lpdiActionFormat->rgoAction[i].uAppData);
+        TRACE("\tdwSemantic=0x%08x\n", lpdiActionFormat->rgoAction[i].dwSemantic);
+        TRACE("\tdwFlags=0x%x\n", lpdiActionFormat->rgoAction[i].dwFlags);
+        TRACE("\tszActionName=%s\n", debugstr_a(lpdiActionFormat->rgoAction[i].u.lptszActionName));
+        TRACE("\tguidInstance=%s\n", debugstr_guid(&lpdiActionFormat->rgoAction[i].guidInstance));
+        TRACE("\tdwObjID=0x%x\n", lpdiActionFormat->rgoAction[i].dwObjID);
+        TRACE("\tdwHow=0x%x\n", lpdiActionFormat->rgoAction[i].dwHow);
+    }
+}
+
+void _copy_diactionformatAtoW(LPDIACTIONFORMATW to, LPDIACTIONFORMATA from)
+{
+    int i;
+
+    to->dwSize = sizeof(DIACTIONFORMATW);
+    to->dwActionSize = sizeof(DIACTIONW);
+    to->dwDataSize = from->dwDataSize;
+    to->dwNumActions = from->dwNumActions;
+    to->guidActionMap = from->guidActionMap;
+    to->dwGenre = from->dwGenre;
+    to->dwBufferSize = from->dwBufferSize;
+    to->lAxisMin = from->lAxisMin;
+    to->lAxisMax = from->lAxisMax;
+    to->dwCRC = from->dwCRC;
+    to->ftTimeStamp = from->ftTimeStamp;
+
+    for (i=0; i < to->dwNumActions; i++)
+    {
+        to->rgoAction[i].uAppData = from->rgoAction[i].uAppData;
+        to->rgoAction[i].dwSemantic = from->rgoAction[i].dwSemantic;
+        to->rgoAction[i].dwFlags = from->rgoAction[i].dwFlags;
+        to->rgoAction[i].guidInstance = from->rgoAction[i].guidInstance;
+        to->rgoAction[i].dwObjID = from->rgoAction[i].dwObjID;
+        to->rgoAction[i].dwHow = from->rgoAction[i].dwHow;
+    }
+}
+
+void _copy_diactionformatWtoA(LPDIACTIONFORMATA to, LPDIACTIONFORMATW from)
+{
+    int i;
+
+    to->dwSize = sizeof(DIACTIONFORMATA);
+    to->dwActionSize = sizeof(DIACTIONA);
+    to->dwDataSize = from->dwDataSize;
+    to->dwNumActions = from->dwNumActions;
+    to->guidActionMap = from->guidActionMap;
+    to->dwGenre = from->dwGenre;
+    to->dwBufferSize = from->dwBufferSize;
+    to->lAxisMin = from->lAxisMin;
+    to->lAxisMax = from->lAxisMax;
+    to->dwCRC = from->dwCRC;
+    to->ftTimeStamp = from->ftTimeStamp;
+
+    for (i=0; i < to->dwNumActions; i++)
+    {
+        to->rgoAction[i].uAppData = from->rgoAction[i].uAppData;
+        to->rgoAction[i].dwSemantic = from->rgoAction[i].dwSemantic;
+        to->rgoAction[i].dwFlags = from->rgoAction[i].dwFlags;
+        to->rgoAction[i].guidInstance = from->rgoAction[i].guidInstance;
+        to->rgoAction[i].dwObjID = from->rgoAction[i].dwObjID;
+        to->rgoAction[i].dwHow = from->rgoAction[i].dwHow;
+    }
+}
+
+/* diactionformat_priority
+ *
+ *  Given a DIACTIONFORMAT structure and a DI genre, returns the enumeration
+ *  priority. Joysticks should pass the game genre, and mouse or keyboard their
+ *  respective DI*_MASK
+ */
+static DWORD diactionformat_priorityA(LPDIACTIONFORMATA lpdiaf, DWORD genre)
+{
+    int i;
+    DWORD priorityFlags = 0;
+
+    /* If there's at least one action for the device it's priority 1 */
+    for(i=0; i < lpdiaf->dwNumActions; i++)
+        if ((lpdiaf->rgoAction[i].dwSemantic & genre) == genre)
+            priorityFlags |= DIEDBS_MAPPEDPRI1;
+
+    return priorityFlags;
+}
+
+static DWORD diactionformat_priorityW(LPDIACTIONFORMATW lpdiaf, DWORD genre)
+{
+    int i;
+    DWORD priorityFlags = 0;
+
+    /* If there's at least one action for the device it's priority 1 */
+    for(i=0; i < lpdiaf->dwNumActions; i++)
+        if ((lpdiaf->rgoAction[i].dwSemantic & genre) == genre)
+            priorityFlags |= DIEDBS_MAPPEDPRI1;
+
+    return priorityFlags;
+}
+
+#if defined __i386__ && defined _MSC_VER
+__declspec(naked) BOOL enum_callback_wrapper(void *callback, const void *instance, void *ref)
+{
+    __asm
+    {
+        push ebp
+        mov ebp, esp
+        push [ebp+16]
+        push [ebp+12]
+        call [ebp+8]
+        leave
+        ret
+    }
+}
+#elif defined __i386__ && defined __GNUC__
+extern BOOL enum_callback_wrapper(void *callback, const void *instance, void *ref);
+__ASM_GLOBAL_FUNC( enum_callback_wrapper,
+    "pushl %ebp\n\t"
+    __ASM_CFI(".cfi_adjust_cfa_offset 4\n\t")
+    __ASM_CFI(".cfi_rel_offset %ebp,0\n\t")
+    "movl %esp,%ebp\n\t"
+    __ASM_CFI(".cfi_def_cfa_register %ebp\n\t")
+    "pushl 16(%ebp)\n\t"
+    "pushl 12(%ebp)\n\t"
+    "call *8(%ebp)\n\t"
+    "leave\n\t"
+    __ASM_CFI(".cfi_def_cfa %esp,4\n\t")
+    __ASM_CFI(".cfi_same_value %ebp\n\t")
+    "ret" )
+#else
+#define enum_callback_wrapper(callback, instance, ref) (callback)((instance), (ref))
+#endif
+
+/******************************************************************************
+ *	IDirectInputA_EnumDevices
+ */
+static HRESULT WINAPI IDirectInputAImpl_EnumDevices(
+	LPDIRECTINPUT7A iface, DWORD dwDevType, LPDIENUMDEVICESCALLBACKA lpCallback,
+	LPVOID pvRef, DWORD dwFlags)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7A(iface);
+    DIDEVICEINSTANCEA devInstance;
+    unsigned int i;
+    int j;
+    HRESULT r;
+
+    TRACE("(this=%p,0x%04x '%s',%p,%p,0x%04x)\n",
+	  This, dwDevType, _dump_DIDEVTYPE_value(dwDevType, This->dwVersion),
+	  lpCallback, pvRef, dwFlags);
+    _dump_EnumDevices_dwFlags(dwFlags);
+
+    if (!lpCallback ||
+        dwFlags & ~(DIEDFL_ATTACHEDONLY | DIEDFL_FORCEFEEDBACK | DIEDFL_INCLUDEALIASES | DIEDFL_INCLUDEPHANTOMS | DIEDFL_INCLUDEHIDDEN) ||
+        (dwDevType > DI8DEVCLASS_GAMECTRL && dwDevType < DI8DEVTYPE_DEVICE) || dwDevType > DI8DEVTYPE_SUPPLEMENTAL)
+        return DIERR_INVALIDPARAM;
+
+    if (!This->initialized)
+        return DIERR_NOTINITIALIZED;
+
+    for (i = 0; i < ARRAY_SIZE(dinput_devices); i++) {
+        if (!dinput_devices[i]->enum_deviceA) continue;
+        for (j = 0, r = S_OK; SUCCEEDED(r); j++) {
+            devInstance.dwSize = sizeof(devInstance);
+            TRACE("  - checking device %u ('%s')\n", i, dinput_devices[i]->name);
+            r = dinput_devices[i]->enum_deviceA(dwDevType, dwFlags, &devInstance, This->dwVersion, j);
+            if (r == S_OK)
+                if (enum_callback_wrapper(lpCallback, &devInstance, pvRef) == DIENUM_STOP)
+                    return S_OK;
+        }
+    }
+
+    return S_OK;
+}
+/******************************************************************************
+ *	IDirectInputW_EnumDevices
+ */
+static HRESULT WINAPI IDirectInputWImpl_EnumDevices(
+	LPDIRECTINPUT7W iface, DWORD dwDevType, LPDIENUMDEVICESCALLBACKW lpCallback,
+	LPVOID pvRef, DWORD dwFlags) 
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7W( iface );
+    DIDEVICEINSTANCEW devInstance;
+    unsigned int i;
+    int j;
+    HRESULT r;
+
+    TRACE("(this=%p,0x%04x '%s',%p,%p,0x%04x)\n",
+	  This, dwDevType, _dump_DIDEVTYPE_value(dwDevType, This->dwVersion),
+	  lpCallback, pvRef, dwFlags);
+    _dump_EnumDevices_dwFlags(dwFlags);
+
+    if (!lpCallback ||
+        dwFlags & ~(DIEDFL_ATTACHEDONLY | DIEDFL_FORCEFEEDBACK | DIEDFL_INCLUDEALIASES | DIEDFL_INCLUDEPHANTOMS | DIEDFL_INCLUDEHIDDEN) ||
+        (dwDevType > DI8DEVCLASS_GAMECTRL && dwDevType < DI8DEVTYPE_DEVICE) || dwDevType > DI8DEVTYPE_SUPPLEMENTAL)
+        return DIERR_INVALIDPARAM;
+
+    if (!This->initialized)
+        return DIERR_NOTINITIALIZED;
+
+    for (i = 0; i < ARRAY_SIZE(dinput_devices); i++) {
+        if (!dinput_devices[i]->enum_deviceW) continue;
+        for (j = 0, r = S_OK; SUCCEEDED(r); j++) {
+            devInstance.dwSize = sizeof(devInstance);
+            TRACE("  - checking device %u ('%s')\n", i, dinput_devices[i]->name);
+            r = dinput_devices[i]->enum_deviceW(dwDevType, dwFlags, &devInstance, This->dwVersion, j);
+            if (r == S_OK)
+                if (enum_callback_wrapper(lpCallback, &devInstance, pvRef) == DIENUM_STOP)
+                    return S_OK;
+        }
+    }
+
+    return S_OK;
+}
+
+static ULONG WINAPI IDirectInputAImpl_AddRef(LPDIRECTINPUT7A iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7A( iface );
+    ULONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE( "(%p) incrementing from %d\n", This, ref - 1);
+    return ref;
+}
+
+static ULONG WINAPI IDirectInputWImpl_AddRef(LPDIRECTINPUT7W iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7W( iface );
+    return IDirectInputAImpl_AddRef( &This->IDirectInput7A_iface );
+}
+
+static ULONG WINAPI IDirectInputAImpl_Release(LPDIRECTINPUT7A iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7A( iface );
+    ULONG ref = InterlockedDecrement( &This->ref );
+
+    TRACE( "(%p) releasing from %d\n", This, ref + 1 );
+
+    if (ref == 0)
+    {
+        uninitialize_directinput_instance( This );
+        HeapFree( GetProcessHeap(), 0, This );
+    }
+
+    return ref;
+}
+
+static ULONG WINAPI IDirectInputWImpl_Release(LPDIRECTINPUT7W iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7W( iface );
+    return IDirectInputAImpl_Release( &This->IDirectInput7A_iface );
+}
+
+static HRESULT WINAPI IDirectInputAImpl_QueryInterface(LPDIRECTINPUT7A iface, REFIID riid, LPVOID *ppobj)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7A( iface );
+
+    TRACE( "(%p)->(%s,%p)\n", This, debugstr_guid(riid), ppobj );
+
+    if (!riid || !ppobj)
+        return E_POINTER;
+
+    if (IsEqualGUID( &IID_IUnknown, riid ) ||
+        IsEqualGUID( &IID_IDirectInputA,  riid ) ||
+        IsEqualGUID( &IID_IDirectInput2A, riid ) ||
+        IsEqualGUID( &IID_IDirectInput7A, riid ))
+    {
+        *ppobj = &This->IDirectInput7A_iface;
+        IUnknown_AddRef( (IUnknown*)*ppobj );
+
+        return DI_OK;
+    }
+
+    if (IsEqualGUID( &IID_IDirectInputW,  riid ) ||
+        IsEqualGUID( &IID_IDirectInput2W, riid ) ||
+        IsEqualGUID( &IID_IDirectInput7W, riid ))
+    {
+        *ppobj = &This->IDirectInput7W_iface;
+        IUnknown_AddRef( (IUnknown*)*ppobj );
+
+        return DI_OK;
+    }
+
+    if (IsEqualGUID( &IID_IDirectInput8A, riid ))
+    {
+        *ppobj = &This->IDirectInput8A_iface;
+        IUnknown_AddRef( (IUnknown*)*ppobj );
+
+        return DI_OK;
+    }
+
+    if (IsEqualGUID( &IID_IDirectInput8W, riid ))
+    {
+        *ppobj = &This->IDirectInput8W_iface;
+        IUnknown_AddRef( (IUnknown*)*ppobj );
+
+        return DI_OK;
+    }
+
+    if (IsEqualGUID( &IID_IDirectInputJoyConfig8, riid ))
+    {
+        *ppobj = &This->IDirectInputJoyConfig8_iface;
+        IUnknown_AddRef( (IUnknown*)*ppobj );
+
+        return DI_OK;
+    }
+
+    FIXME( "Unsupported interface: %s\n", debugstr_guid(riid));
+    *ppobj = NULL;
+    return E_NOINTERFACE;
+}
+
+static HRESULT WINAPI IDirectInputWImpl_QueryInterface(LPDIRECTINPUT7W iface, REFIID riid, LPVOID *ppobj)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7W( iface );
+    return IDirectInputAImpl_QueryInterface( &This->IDirectInput7A_iface, riid, ppobj );
+}
+
+static HRESULT initialize_directinput_instance(IDirectInputImpl *This, DWORD dwVersion)
+{
+    if (!This->initialized)
+    {
+        This->dwVersion = dwVersion;
+        This->evsequence = 1;
+
+        InitializeCriticalSection( &This->crit );
+        This->crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": IDirectInputImpl*->crit");
+
+        list_init( &This->devices_list );
+        list_init( &This->device_players );
+
+        /* Add self to the list of the IDirectInputs */
+        EnterCriticalSection( &dinput_hook_crit );
+        list_add_head( &direct_input_list, &This->entry );
+        LeaveCriticalSection( &dinput_hook_crit );
+
+        This->initialized = TRUE;
+
+        if (!check_hook_thread())
+        {
+            uninitialize_directinput_instance( This );
+            return DIERR_GENERIC;
+        }
+    }
+
+    return DI_OK;
+}
+
+static void uninitialize_directinput_instance(IDirectInputImpl *This)
+{
+    if (This->initialized)
+    {
+        struct DevicePlayer *device_player, *device_player2;
+        /* Remove self from the list of the IDirectInputs */
+        EnterCriticalSection( &dinput_hook_crit );
+        list_remove( &This->entry );
+        LeaveCriticalSection( &dinput_hook_crit );
+
+        LIST_FOR_EACH_ENTRY_SAFE( device_player, device_player2,
+                &This->device_players, struct DevicePlayer, entry )
+            HeapFree(GetProcessHeap(), 0, device_player);
+
+        check_hook_thread();
+
+        This->crit.DebugInfo->Spare[0] = 0;
+        DeleteCriticalSection( &This->crit );
+
+        This->initialized = FALSE;
+    }
+}
+
+enum directinput_versions
+{
+    DIRECTINPUT_VERSION_300 = 0x0300,
+    DIRECTINPUT_VERSION_500 = 0x0500,
+    DIRECTINPUT_VERSION_50A = 0x050A,
+    DIRECTINPUT_VERSION_5B2 = 0x05B2,
+    DIRECTINPUT_VERSION_602 = 0x0602,
+    DIRECTINPUT_VERSION_61A = 0x061A,
+    DIRECTINPUT_VERSION_700 = 0x0700,
+};
+
+static HRESULT WINAPI IDirectInputAImpl_Initialize(LPDIRECTINPUT7A iface, HINSTANCE hinst, DWORD version)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7A( iface );
+
+    TRACE("(%p)->(%p, 0x%04x)\n", iface, hinst, version);
+
+    if (!hinst)
+        return DIERR_INVALIDPARAM;
+    else if (version == 0)
+        return DIERR_NOTINITIALIZED;
+    else if (version > DIRECTINPUT_VERSION_700)
+        return DIERR_OLDDIRECTINPUTVERSION;
+    else if (version != DIRECTINPUT_VERSION_300 && version != DIRECTINPUT_VERSION_500 &&
+             version != DIRECTINPUT_VERSION_50A && version != DIRECTINPUT_VERSION_5B2 &&
+             version != DIRECTINPUT_VERSION_602 && version != DIRECTINPUT_VERSION_61A &&
+             version != DIRECTINPUT_VERSION_700 && version != DIRECTINPUT_VERSION)
+        return DIERR_BETADIRECTINPUTVERSION;
+
+    return initialize_directinput_instance(This, version);
+}
+
+static HRESULT WINAPI IDirectInputWImpl_Initialize(LPDIRECTINPUT7W iface, HINSTANCE hinst, DWORD x)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7W( iface );
+    return IDirectInputAImpl_Initialize( &This->IDirectInput7A_iface, hinst, x );
+}
+
+static HRESULT WINAPI IDirectInputAImpl_GetDeviceStatus(LPDIRECTINPUT7A iface, REFGUID rguid)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7A( iface );
+    HRESULT hr;
+    LPDIRECTINPUTDEVICEA device;
+
+    TRACE( "(%p)->(%s)\n", This, debugstr_guid(rguid) );
+
+    if (!rguid) return E_POINTER;
+    if (!This->initialized)
+        return DIERR_NOTINITIALIZED;
+
+    hr = IDirectInput_CreateDevice( iface, rguid, &device, NULL );
+    if (hr != DI_OK) return DI_NOTATTACHED;
+
+    IUnknown_Release( device );
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI IDirectInputWImpl_GetDeviceStatus(LPDIRECTINPUT7W iface, REFGUID rguid)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7W( iface );
+    return IDirectInputAImpl_GetDeviceStatus( &This->IDirectInput7A_iface, rguid );
+}
+
+static HRESULT WINAPI IDirectInputAImpl_RunControlPanel(LPDIRECTINPUT7A iface,
+							HWND hwndOwner,
+							DWORD dwFlags)
+{
+    WCHAR control_exeW[] = {'c','o','n','t','r','o','l','.','e','x','e',0};
+    STARTUPINFOW si = {0};
+    PROCESS_INFORMATION pi;
+
+    IDirectInputImpl *This = impl_from_IDirectInput7A( iface );
+
+    TRACE( "(%p)->(%p, %08x)\n", This, hwndOwner, dwFlags );
+
+    if (hwndOwner && !IsWindow(hwndOwner))
+        return E_HANDLE;
+
+    if (dwFlags)
+        return DIERR_INVALIDPARAM;
+
+    if (!This->initialized)
+        return DIERR_NOTINITIALIZED;
+
+    if (!CreateProcessW(NULL, control_exeW, NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL, &si, &pi))
+        return HRESULT_FROM_WIN32(GetLastError());
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI IDirectInputWImpl_RunControlPanel(LPDIRECTINPUT7W iface, HWND hwndOwner, DWORD dwFlags)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7W( iface );
+    return IDirectInputAImpl_RunControlPanel( &This->IDirectInput7A_iface, hwndOwner, dwFlags );
+}
+
+static HRESULT WINAPI IDirectInput2AImpl_FindDevice(LPDIRECTINPUT7A iface, REFGUID rguid,
+						    LPCSTR pszName, LPGUID pguidInstance)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7A( iface );
+
+    FIXME( "(%p)->(%s, %s, %p): stub\n", This, debugstr_guid(rguid), pszName, pguidInstance );
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI IDirectInput2WImpl_FindDevice(LPDIRECTINPUT7W iface, REFGUID rguid,
+						    LPCWSTR pszName, LPGUID pguidInstance)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7W( iface );
+
+    FIXME( "(%p)->(%s, %s, %p): stub\n", This, debugstr_guid(rguid), debugstr_w(pszName), pguidInstance );
+
+    return DI_OK;
+}
+
+static HRESULT create_device(IDirectInputImpl *This, REFGUID rguid, REFIID riid, LPVOID *pvOut, BOOL unicode)
+{
+    unsigned int i;
+
+    if (pvOut)
+        *pvOut = NULL;
+
+    if (!rguid || !pvOut)
+        return E_POINTER;
+
+    if (!This->initialized)
+        return DIERR_NOTINITIALIZED;
+
+    /* Loop on all the devices to see if anyone matches the given GUID */
+    for (i = 0; i < ARRAY_SIZE(dinput_devices); i++)
+    {
+        HRESULT ret;
+
+        if (!dinput_devices[i]->create_device) continue;
+        if ((ret = dinput_devices[i]->create_device(This, rguid, riid, pvOut, unicode)) == DI_OK)
+            return DI_OK;
+    }
+
+    WARN("invalid device GUID %s\n", debugstr_guid(rguid));
+    return DIERR_DEVICENOTREG;
+}
+
+static HRESULT WINAPI IDirectInput7AImpl_CreateDeviceEx(LPDIRECTINPUT7A iface, REFGUID rguid,
+                                                        REFIID riid, LPVOID* pvOut, LPUNKNOWN lpUnknownOuter)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7A( iface );
+
+    TRACE("(%p)->(%s, %s, %p, %p)\n", This, debugstr_guid(rguid), debugstr_guid(riid), pvOut, lpUnknownOuter);
+
+    return create_device(This, rguid, riid, pvOut, FALSE);
+}
+
+static HRESULT WINAPI IDirectInput7WImpl_CreateDeviceEx(LPDIRECTINPUT7W iface, REFGUID rguid,
+                                                        REFIID riid, LPVOID* pvOut, LPUNKNOWN lpUnknownOuter)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7W( iface );
+
+    TRACE("(%p)->(%s, %s, %p, %p)\n", This, debugstr_guid(rguid), debugstr_guid(riid), pvOut, lpUnknownOuter);
+
+    return create_device(This, rguid, riid, pvOut, TRUE);
+}
+
+static HRESULT WINAPI IDirectInputAImpl_CreateDevice(LPDIRECTINPUT7A iface, REFGUID rguid,
+                                                     LPDIRECTINPUTDEVICEA* pdev, LPUNKNOWN punk)
+{
+    return IDirectInput7AImpl_CreateDeviceEx(iface, rguid, NULL, (LPVOID*)pdev, punk);
+}
+
+static HRESULT WINAPI IDirectInputWImpl_CreateDevice(LPDIRECTINPUT7W iface, REFGUID rguid,
+                                                     LPDIRECTINPUTDEVICEW* pdev, LPUNKNOWN punk)
+{
+    return IDirectInput7WImpl_CreateDeviceEx(iface, rguid, NULL, (LPVOID*)pdev, punk);
+}
+
+/*******************************************************************************
+ *      DirectInput8
+ */
+
+static ULONG WINAPI IDirectInput8AImpl_AddRef(LPDIRECTINPUT8A iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+    return IDirectInputAImpl_AddRef( &This->IDirectInput7A_iface );
+}
+
+static ULONG WINAPI IDirectInput8WImpl_AddRef(LPDIRECTINPUT8W iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W( iface );
+    return IDirectInputAImpl_AddRef( &This->IDirectInput7A_iface );
+}
+
+static HRESULT WINAPI IDirectInput8AImpl_QueryInterface(LPDIRECTINPUT8A iface, REFIID riid, LPVOID *ppobj)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+    return IDirectInputAImpl_QueryInterface( &This->IDirectInput7A_iface, riid, ppobj );
+}
+
+static HRESULT WINAPI IDirectInput8WImpl_QueryInterface(LPDIRECTINPUT8W iface, REFIID riid, LPVOID *ppobj)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W( iface );
+    return IDirectInputAImpl_QueryInterface( &This->IDirectInput7A_iface, riid, ppobj );
+}
+
+static ULONG WINAPI IDirectInput8AImpl_Release(LPDIRECTINPUT8A iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+    return IDirectInputAImpl_Release( &This->IDirectInput7A_iface );
+}
+
+static ULONG WINAPI IDirectInput8WImpl_Release(LPDIRECTINPUT8W iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W( iface );
+    return IDirectInputAImpl_Release( &This->IDirectInput7A_iface );
+}
+
+static HRESULT WINAPI IDirectInput8AImpl_CreateDevice(LPDIRECTINPUT8A iface, REFGUID rguid,
+                                                      LPDIRECTINPUTDEVICE8A* pdev, LPUNKNOWN punk)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+    return IDirectInput7AImpl_CreateDeviceEx( &This->IDirectInput7A_iface, rguid, NULL, (LPVOID*)pdev, punk );
+}
+
+static HRESULT WINAPI IDirectInput8WImpl_CreateDevice(LPDIRECTINPUT8W iface, REFGUID rguid,
+                                                      LPDIRECTINPUTDEVICE8W* pdev, LPUNKNOWN punk)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W( iface );
+    return IDirectInput7WImpl_CreateDeviceEx( &This->IDirectInput7W_iface, rguid, NULL, (LPVOID*)pdev, punk );
+}
+
+static HRESULT WINAPI IDirectInput8AImpl_EnumDevices(LPDIRECTINPUT8A iface, DWORD dwDevType, LPDIENUMDEVICESCALLBACKA lpCallback,
+                                                     LPVOID pvRef, DWORD dwFlags)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+    return IDirectInputAImpl_EnumDevices( &This->IDirectInput7A_iface, dwDevType, lpCallback, pvRef, dwFlags );
+}
+
+static HRESULT WINAPI IDirectInput8WImpl_EnumDevices(LPDIRECTINPUT8W iface, DWORD dwDevType, LPDIENUMDEVICESCALLBACKW lpCallback,
+                                                     LPVOID pvRef, DWORD dwFlags)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W( iface );
+    return IDirectInputWImpl_EnumDevices( &This->IDirectInput7W_iface, dwDevType, lpCallback, pvRef, dwFlags );
+}
+
+static HRESULT WINAPI IDirectInput8AImpl_GetDeviceStatus(LPDIRECTINPUT8A iface, REFGUID rguid)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+    return IDirectInputAImpl_GetDeviceStatus( &This->IDirectInput7A_iface, rguid );
+}
+
+static HRESULT WINAPI IDirectInput8WImpl_GetDeviceStatus(LPDIRECTINPUT8W iface, REFGUID rguid)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W( iface );
+    return IDirectInputAImpl_GetDeviceStatus( &This->IDirectInput7A_iface, rguid );
+}
+
+static HRESULT WINAPI IDirectInput8AImpl_RunControlPanel(LPDIRECTINPUT8A iface, HWND hwndOwner, DWORD dwFlags)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+    return IDirectInputAImpl_RunControlPanel( &This->IDirectInput7A_iface, hwndOwner, dwFlags );
+}
+
+static HRESULT WINAPI IDirectInput8WImpl_RunControlPanel(LPDIRECTINPUT8W iface, HWND hwndOwner, DWORD dwFlags)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W( iface );
+    return IDirectInputAImpl_RunControlPanel( &This->IDirectInput7A_iface, hwndOwner, dwFlags );
+}
+
+static HRESULT WINAPI IDirectInput8AImpl_Initialize(LPDIRECTINPUT8A iface, HINSTANCE hinst, DWORD version)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+
+    TRACE("(%p)->(%p, 0x%04x)\n", iface, hinst, version);
+
+    if (!hinst)
+        return DIERR_INVALIDPARAM;
+    else if (version == 0)
+        return DIERR_NOTINITIALIZED;
+    else if (version < DIRECTINPUT_VERSION)
+        return DIERR_BETADIRECTINPUTVERSION;
+    else if (version > DIRECTINPUT_VERSION)
+        return DIERR_OLDDIRECTINPUTVERSION;
+
+    return initialize_directinput_instance(This, version);
+}
+
+static HRESULT WINAPI IDirectInput8WImpl_Initialize(LPDIRECTINPUT8W iface, HINSTANCE hinst, DWORD version)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W( iface );
+    return IDirectInput8AImpl_Initialize( &This->IDirectInput8A_iface, hinst, version );
+}
+
+static HRESULT WINAPI IDirectInput8AImpl_FindDevice(LPDIRECTINPUT8A iface, REFGUID rguid, LPCSTR pszName, LPGUID pguidInstance)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+    return IDirectInput2AImpl_FindDevice( &This->IDirectInput7A_iface, rguid, pszName, pguidInstance );
+}
+
+static HRESULT WINAPI IDirectInput8WImpl_FindDevice(LPDIRECTINPUT8W iface, REFGUID rguid, LPCWSTR pszName, LPGUID pguidInstance)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W( iface );
+    return IDirectInput2WImpl_FindDevice( &This->IDirectInput7W_iface, rguid, pszName, pguidInstance );
+}
+
+static BOOL should_enumerate_device(const WCHAR *username, DWORD dwFlags,
+    struct list *device_players, REFGUID guid)
+{
+    BOOL should_enumerate = TRUE;
+    struct DevicePlayer *device_player;
+
+    /* Check if user owns this device */
+    if (dwFlags & DIEDBSFL_THISUSER && username && *username)
+    {
+        should_enumerate = FALSE;
+        LIST_FOR_EACH_ENTRY(device_player, device_players, struct DevicePlayer, entry)
+        {
+            if (IsEqualGUID(&device_player->instance_guid, guid))
+            {
+                if (*device_player->username && !lstrcmpW(username, device_player->username))
+                    return TRUE; /* Device username matches */
+                break;
+            }
+        }
+    }
+
+    /* Check if this device is not owned by anyone */
+    if (dwFlags & DIEDBSFL_AVAILABLEDEVICES) {
+        BOOL found = FALSE;
+        should_enumerate = FALSE;
+        LIST_FOR_EACH_ENTRY(device_player, device_players, struct DevicePlayer, entry)
+        {
+            if (IsEqualGUID(&device_player->instance_guid, guid))
+            {
+                if (*device_player->username)
+                    found = TRUE;
+                break;
+            }
+        }
+        if (!found)
+            return TRUE; /* Device does not have a username */
+    }
+
+    return should_enumerate;
+}
+
+static HRESULT WINAPI IDirectInput8AImpl_EnumDevicesBySemantics(
+      LPDIRECTINPUT8A iface, LPCSTR ptszUserName, LPDIACTIONFORMATA lpdiActionFormat,
+      LPDIENUMDEVICESBYSEMANTICSCBA lpCallback,
+      LPVOID pvRef, DWORD dwFlags
+)
+{
+    static REFGUID guids[2] = { &GUID_SysKeyboard, &GUID_SysMouse };
+    static const DWORD actionMasks[] = { DIKEYBOARD_MASK, DIMOUSE_MASK };
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+    DIDEVICEINSTANCEA didevi;
+    LPDIRECTINPUTDEVICE8A lpdid;
+    DWORD callbackFlags;
+    int i, j;
+    int device_count = 0;
+    int remain;
+    DIDEVICEINSTANCEA *didevis = 0;
+    WCHAR *username_w = 0;
+
+    FIXME("(this=%p,%s,%p,%p,%p,%04x): semi-stub\n", This, debugstr_a(ptszUserName), lpdiActionFormat,
+          lpCallback, pvRef, dwFlags);
+#define X(x) if (dwFlags & x) FIXME("\tdwFlags |= "#x"\n");
+	X(DIEDBSFL_ATTACHEDONLY)
+	X(DIEDBSFL_THISUSER)
+	X(DIEDBSFL_FORCEFEEDBACK)
+	X(DIEDBSFL_AVAILABLEDEVICES)
+	X(DIEDBSFL_MULTIMICEKEYBOARDS)
+	X(DIEDBSFL_NONGAMINGDEVICES)
+#undef X
+
+    _dump_diactionformatA(lpdiActionFormat);
+
+    didevi.dwSize = sizeof(didevi);
+
+    if (ptszUserName)
+    {
+        int len = MultiByteToWideChar(CP_ACP, 0, ptszUserName, -1, 0, 0);
+
+        username_w = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR)*len);
+        MultiByteToWideChar(CP_ACP, 0, ptszUserName, -1, username_w, len);
+    }
+
+    /* Enumerate all the joysticks */
+    for (i = 0; i < ARRAY_SIZE(dinput_devices); i++)
+    {
+        HRESULT enumSuccess;
+
+        if (!dinput_devices[i]->enum_deviceA) continue;
+
+        for (j = 0, enumSuccess = S_OK; SUCCEEDED(enumSuccess); j++)
+        {
+            TRACE(" - checking device %u ('%s')\n", i, dinput_devices[i]->name);
+
+            /* Default behavior is to enumerate attached game controllers */
+            enumSuccess = dinput_devices[i]->enum_deviceA(DI8DEVCLASS_GAMECTRL, DIEDFL_ATTACHEDONLY | dwFlags, &didevi, This->dwVersion, j);
+            if (enumSuccess == S_OK &&
+                should_enumerate_device(username_w, dwFlags, &This->device_players, &didevi.guidInstance))
+            {
+                if (device_count++)
+                    didevis = HeapReAlloc(GetProcessHeap(), 0, didevis, sizeof(DIDEVICEINSTANCEA)*device_count);
+                else
+                    didevis = HeapAlloc(GetProcessHeap(), 0, sizeof(DIDEVICEINSTANCEA)*device_count);
+                didevis[device_count-1] = didevi;
+            }
+        }
+    }
+
+    remain = device_count;
+    /* Add keyboard and mouse to remaining device count */
+    if (!(dwFlags & DIEDBSFL_FORCEFEEDBACK))
+    {
+        for (i = 0; i < sizeof(guids) / sizeof(guids[0]); i++)
+        {
+            if (should_enumerate_device(username_w, dwFlags, &This->device_players, guids[i]))
+                remain++;
+        }
+    }
+
+    for (i = 0; i < device_count; i++)
+    {
+        callbackFlags = diactionformat_priorityA(lpdiActionFormat, lpdiActionFormat->dwGenre);
+        IDirectInput_CreateDevice(iface, &didevis[i].guidInstance, &lpdid, NULL);
+
+        if (lpCallback(&didevis[i], lpdid, callbackFlags, --remain, pvRef) == DIENUM_STOP)
+        {
+            HeapFree(GetProcessHeap(), 0, didevis);
+            HeapFree(GetProcessHeap(), 0, username_w);
+            return DI_OK;
+        }
+    }
+
+    HeapFree(GetProcessHeap(), 0, didevis);
+
+    if (dwFlags & DIEDBSFL_FORCEFEEDBACK)
+    {
+        HeapFree(GetProcessHeap(), 0, username_w);
+        return DI_OK;
+    }
+
+    /* Enumerate keyboard and mouse */
+    for(i=0; i < sizeof(guids)/sizeof(guids[0]); i++)
+    {
+        if (should_enumerate_device(username_w, dwFlags, &This->device_players, guids[i]))
+        {
+            callbackFlags = diactionformat_priorityA(lpdiActionFormat, actionMasks[i]);
+
+            IDirectInput_CreateDevice(iface, guids[i], &lpdid, NULL);
+            IDirectInputDevice_GetDeviceInfo(lpdid, &didevi);
+
+            if (lpCallback(&didevi, lpdid, callbackFlags, --remain, pvRef) == DIENUM_STOP)
+            {
+                HeapFree(GetProcessHeap(), 0, username_w);
+                return DI_OK;
+            }
+        }
+    }
+
+    HeapFree(GetProcessHeap(), 0, username_w);
+    return DI_OK;
+}
+
+static HRESULT WINAPI IDirectInput8WImpl_EnumDevicesBySemantics(
+      LPDIRECTINPUT8W iface, LPCWSTR ptszUserName, LPDIACTIONFORMATW lpdiActionFormat,
+      LPDIENUMDEVICESBYSEMANTICSCBW lpCallback,
+      LPVOID pvRef, DWORD dwFlags
+)
+{
+    static REFGUID guids[2] = { &GUID_SysKeyboard, &GUID_SysMouse };
+    static const DWORD actionMasks[] = { DIKEYBOARD_MASK, DIMOUSE_MASK };
+    IDirectInputImpl *This = impl_from_IDirectInput8W(iface);
+    DIDEVICEINSTANCEW didevi;
+    LPDIRECTINPUTDEVICE8W lpdid;
+    DWORD callbackFlags;
+    int i, j;
+    int device_count = 0;
+    int remain;
+    DIDEVICEINSTANCEW *didevis = 0;
+
+    FIXME("(this=%p,%s,%p,%p,%p,%04x): semi-stub\n", This, debugstr_w(ptszUserName), lpdiActionFormat,
+          lpCallback, pvRef, dwFlags);
+
+    didevi.dwSize = sizeof(didevi);
+
+    /* Enumerate all the joysticks */
+    for (i = 0; i < ARRAY_SIZE(dinput_devices); i++)
+    {
+        HRESULT enumSuccess;
+
+        if (!dinput_devices[i]->enum_deviceW) continue;
+
+        for (j = 0, enumSuccess = S_OK; SUCCEEDED(enumSuccess); j++)
+        {
+            TRACE(" - checking device %u ('%s')\n", i, dinput_devices[i]->name);
+
+            /* Default behavior is to enumerate attached game controllers */
+            enumSuccess = dinput_devices[i]->enum_deviceW(DI8DEVCLASS_GAMECTRL, DIEDFL_ATTACHEDONLY | dwFlags, &didevi, This->dwVersion, j);
+            if (enumSuccess == S_OK &&
+                should_enumerate_device(ptszUserName, dwFlags, &This->device_players, &didevi.guidInstance))
+            {
+                if (device_count++)
+                    didevis = HeapReAlloc(GetProcessHeap(), 0, didevis, sizeof(DIDEVICEINSTANCEW)*device_count);
+                else
+                    didevis = HeapAlloc(GetProcessHeap(), 0, sizeof(DIDEVICEINSTANCEW)*device_count);
+                didevis[device_count-1] = didevi;
+            }
+        }
+    }
+
+    remain = device_count;
+    /* Add keyboard and mouse to remaining device count */
+    if (!(dwFlags & DIEDBSFL_FORCEFEEDBACK))
+    {
+        for (i = 0; i < sizeof(guids) / sizeof(guids[0]); i++)
+        {
+            if (should_enumerate_device(ptszUserName, dwFlags, &This->device_players, guids[i]))
+                remain++;
+        }
+    }
+
+    for (i = 0; i < device_count; i++)
+    {
+        callbackFlags = diactionformat_priorityW(lpdiActionFormat, lpdiActionFormat->dwGenre);
+        IDirectInput_CreateDevice(iface, &didevis[i].guidInstance, &lpdid, NULL);
+
+        if (lpCallback(&didevis[i], lpdid, callbackFlags, --remain, pvRef) == DIENUM_STOP)
+        {
+            HeapFree(GetProcessHeap(), 0, didevis);
+            return DI_OK;
+        }
+    }
+
+    HeapFree(GetProcessHeap(), 0, didevis);
+
+    if (dwFlags & DIEDBSFL_FORCEFEEDBACK) return DI_OK;
+
+    /* Enumerate keyboard and mouse */
+    for(i=0; i < sizeof(guids)/sizeof(guids[0]); i++)
+    {
+        if (should_enumerate_device(ptszUserName, dwFlags, &This->device_players, guids[i]))
+        {
+            callbackFlags = diactionformat_priorityW(lpdiActionFormat, actionMasks[i]);
+
+            IDirectInput_CreateDevice(iface, guids[i], &lpdid, NULL);
+            IDirectInputDevice_GetDeviceInfo(lpdid, &didevi);
+
+            if (lpCallback(&didevi, lpdid, callbackFlags, --remain, pvRef) == DIENUM_STOP)
+                return DI_OK;
+        }
+    }
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI IDirectInput8WImpl_ConfigureDevices(
+      LPDIRECTINPUT8W iface, LPDICONFIGUREDEVICESCALLBACK lpdiCallback,
+      LPDICONFIGUREDEVICESPARAMSW lpdiCDParams, DWORD dwFlags, LPVOID pvRefData
+)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W(iface);
+
+    FIXME("(this=%p,%p,%p,%04x,%p): stub\n", This, lpdiCallback, lpdiCDParams, dwFlags, pvRefData);
+
+    /* Call helper function in config.c to do the real work */
+    return _configure_devices(iface, lpdiCallback, lpdiCDParams, dwFlags, pvRefData);
+}
+
+static HRESULT WINAPI IDirectInput8AImpl_ConfigureDevices(
+      LPDIRECTINPUT8A iface, LPDICONFIGUREDEVICESCALLBACK lpdiCallback,
+      LPDICONFIGUREDEVICESPARAMSA lpdiCDParams, DWORD dwFlags, LPVOID pvRefData
+)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A(iface);
+    DIACTIONFORMATW diafW;
+    DICONFIGUREDEVICESPARAMSW diCDParamsW;
+    HRESULT hr;
+    int i;
+
+     FIXME("(this=%p,%p,%p,%04x,%p): stub\n", This, lpdiCallback, lpdiCDParams, dwFlags, pvRefData);
+
+    /* Copy parameters */
+    diCDParamsW.dwSize = sizeof(DICONFIGUREDEVICESPARAMSW);
+    diCDParamsW.dwcFormats = lpdiCDParams->dwcFormats;
+    diCDParamsW.lprgFormats = &diafW;
+    diCDParamsW.hwnd = lpdiCDParams->hwnd;
+
+    diafW.rgoAction = HeapAlloc(GetProcessHeap(), 0, sizeof(DIACTIONW)*lpdiCDParams->lprgFormats->dwNumActions);
+    _copy_diactionformatAtoW(&diafW, lpdiCDParams->lprgFormats);
+
+    /* Copy action names */
+    for (i=0; i < diafW.dwNumActions; i++)
+    {
+        const char* from = lpdiCDParams->lprgFormats->rgoAction[i].u.lptszActionName;
+        int len = MultiByteToWideChar(CP_ACP, 0, from , -1, NULL , 0);
+        WCHAR *to = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR)*len);
+
+        MultiByteToWideChar(CP_ACP, 0, from , -1, to , len);
+        diafW.rgoAction[i].u.lptszActionName = to;
+    }
+
+    hr = IDirectInput8WImpl_ConfigureDevices(&This->IDirectInput8W_iface, lpdiCallback, &diCDParamsW, dwFlags, pvRefData);
+
+    /* Copy back configuration */
+    if (SUCCEEDED(hr))
+        _copy_diactionformatWtoA(lpdiCDParams->lprgFormats, &diafW);
+
+    /* Free memory */
+    for (i=0; i < diafW.dwNumActions; i++)
+        HeapFree(GetProcessHeap(), 0, (void*) diafW.rgoAction[i].u.lptszActionName);
+
+    HeapFree(GetProcessHeap(), 0, diafW.rgoAction);
+
+    return hr;
+}
+
+/*****************************************************************************
+ * IDirectInputJoyConfig8 interface
  */
-static void LockModule(void)
+
+static inline IDirectInputImpl *impl_from_IDirectInputJoyConfig8(IDirectInputJoyConfig8 *iface)
+{
+    return CONTAINING_RECORD( iface, IDirectInputImpl, IDirectInputJoyConfig8_iface );
+}
+
+static HRESULT WINAPI JoyConfig8Impl_QueryInterface(IDirectInputJoyConfig8 *iface, REFIID riid, void** ppobj)
+{
+    IDirectInputImpl *This = impl_from_IDirectInputJoyConfig8( iface );
+    return IDirectInputAImpl_QueryInterface( &This->IDirectInput7A_iface, riid, ppobj );
+}
+
+static ULONG WINAPI JoyConfig8Impl_AddRef(IDirectInputJoyConfig8 *iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInputJoyConfig8( iface );
+    return IDirectInputAImpl_AddRef( &This->IDirectInput7A_iface );
+}
+
+static ULONG WINAPI JoyConfig8Impl_Release(IDirectInputJoyConfig8 *iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInputJoyConfig8( iface );
+    return IDirectInputAImpl_Release( &This->IDirectInput7A_iface );
+}
+
+static HRESULT WINAPI JoyConfig8Impl_Acquire(IDirectInputJoyConfig8 *iface)
+{
+    FIXME( "(%p): stub!\n", iface );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_Unacquire(IDirectInputJoyConfig8 *iface)
+{
+    FIXME( "(%p): stub!\n", iface );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_SetCooperativeLevel(IDirectInputJoyConfig8 *iface, HWND hwnd, DWORD flags)
+{
+    FIXME( "(%p)->(%p, 0x%08x): stub!\n", iface, hwnd, flags );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_SendNotify(IDirectInputJoyConfig8 *iface)
+{
+    FIXME( "(%p): stub!\n", iface );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_EnumTypes(IDirectInputJoyConfig8 *iface, LPDIJOYTYPECALLBACK cb, void *ref)
+{
+    FIXME( "(%p)->(%p, %p): stub!\n", iface, cb, ref );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_GetTypeInfo(IDirectInputJoyConfig8 *iface, LPCWSTR name, LPDIJOYTYPEINFO info, DWORD flags)
+{
+    FIXME( "(%p)->(%s, %p, 0x%08x): stub!\n", iface, debugstr_w(name), info, flags );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_SetTypeInfo(IDirectInputJoyConfig8 *iface, LPCWSTR name, LPCDIJOYTYPEINFO info, DWORD flags,
+                                                 LPWSTR new_name)
+{
+    FIXME( "(%p)->(%s, %p, 0x%08x, %s): stub!\n", iface, debugstr_w(name), info, flags, debugstr_w(new_name) );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_DeleteType(IDirectInputJoyConfig8 *iface, LPCWSTR name)
+{
+    FIXME( "(%p)->(%s): stub!\n", iface, debugstr_w(name) );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_GetConfig(IDirectInputJoyConfig8 *iface, UINT id, LPDIJOYCONFIG info, DWORD flags)
+{
+    IDirectInputImpl *di = impl_from_IDirectInputJoyConfig8(iface);
+    UINT found = 0;
+    int i, j;
+    HRESULT r;
+
+    FIXME("(%p)->(%d, %p, 0x%08x): semi-stub!\n", iface, id, info, flags);
+
+#define X(x) if (flags & x) FIXME("\tflags |= "#x"\n");
+    X(DIJC_GUIDINSTANCE)
+    X(DIJC_REGHWCONFIGTYPE)
+    X(DIJC_GAIN)
+    X(DIJC_CALLOUT)
+#undef X
+
+    /* Enumerate all joysticks in order */
+    for (i = 0; i < ARRAY_SIZE(dinput_devices); i++)
+    {
+        if (!dinput_devices[i]->enum_deviceA) continue;
+
+        for (j = 0, r = S_OK; SUCCEEDED(r); j++)
+        {
+            DIDEVICEINSTANCEA dev;
+            dev.dwSize = sizeof(dev);
+            if ((r = dinput_devices[i]->enum_deviceA(DI8DEVCLASS_GAMECTRL, 0, &dev, di->dwVersion, j)) == S_OK)
+            {
+                /* Only take into account the chosen id */
+                if (found == id)
+                {
+                    if (flags & DIJC_GUIDINSTANCE)
+                        info->guidInstance = dev.guidInstance;
+
+                    return DI_OK;
+                }
+                found += 1;
+            }
+        }
+    }
+
+    return DIERR_NOMOREITEMS;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_SetConfig(IDirectInputJoyConfig8 *iface, UINT id, LPCDIJOYCONFIG info, DWORD flags)
+{
+    FIXME( "(%p)->(%d, %p, 0x%08x): stub!\n", iface, id, info, flags );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_DeleteConfig(IDirectInputJoyConfig8 *iface, UINT id)
+{
+    FIXME( "(%p)->(%d): stub!\n", iface, id );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_GetUserValues(IDirectInputJoyConfig8 *iface, LPDIJOYUSERVALUES info, DWORD flags)
+{
+    FIXME( "(%p)->(%p, 0x%08x): stub!\n", iface, info, flags );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_SetUserValues(IDirectInputJoyConfig8 *iface, LPCDIJOYUSERVALUES info, DWORD flags)
+{
+    FIXME( "(%p)->(%p, 0x%08x): stub!\n", iface, info, flags );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_AddNewHardware(IDirectInputJoyConfig8 *iface, HWND hwnd, REFGUID guid)
+{
+    FIXME( "(%p)->(%p, %s): stub!\n", iface, hwnd, debugstr_guid(guid) );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_OpenTypeKey(IDirectInputJoyConfig8 *iface, LPCWSTR name, DWORD security, PHKEY key)
 {
-    InterlockedIncrement(&dll_count);
+    FIXME( "(%p)->(%s, 0x%08x, %p): stub!\n", iface, debugstr_w(name), security, key );
+    return E_NOTIMPL;
 }
 
-static void UnlockModule(void)
+static HRESULT WINAPI JoyConfig8Impl_OpenAppStatusKey(IDirectInputJoyConfig8 *iface, PHKEY key)
 {
-    InterlockedDecrement(&dll_count);
+    FIXME( "(%p)->(%p): stub!\n", iface, key );
+    return E_NOTIMPL;
 }
 
+static const IDirectInput7AVtbl ddi7avt = {
+    IDirectInputAImpl_QueryInterface,
+    IDirectInputAImpl_AddRef,
+    IDirectInputAImpl_Release,
+    IDirectInputAImpl_CreateDevice,
+    IDirectInputAImpl_EnumDevices,
+    IDirectInputAImpl_GetDeviceStatus,
+    IDirectInputAImpl_RunControlPanel,
+    IDirectInputAImpl_Initialize,
+    IDirectInput2AImpl_FindDevice,
+    IDirectInput7AImpl_CreateDeviceEx
+};
+
+static const IDirectInput7WVtbl ddi7wvt = {
+    IDirectInputWImpl_QueryInterface,
+    IDirectInputWImpl_AddRef,
+    IDirectInputWImpl_Release,
+    IDirectInputWImpl_CreateDevice,
+    IDirectInputWImpl_EnumDevices,
+    IDirectInputWImpl_GetDeviceStatus,
+    IDirectInputWImpl_RunControlPanel,
+    IDirectInputWImpl_Initialize,
+    IDirectInput2WImpl_FindDevice,
+    IDirectInput7WImpl_CreateDeviceEx
+};
+
+static const IDirectInput8AVtbl ddi8avt = {
+    IDirectInput8AImpl_QueryInterface,
+    IDirectInput8AImpl_AddRef,
+    IDirectInput8AImpl_Release,
+    IDirectInput8AImpl_CreateDevice,
+    IDirectInput8AImpl_EnumDevices,
+    IDirectInput8AImpl_GetDeviceStatus,
+    IDirectInput8AImpl_RunControlPanel,
+    IDirectInput8AImpl_Initialize,
+    IDirectInput8AImpl_FindDevice,
+    IDirectInput8AImpl_EnumDevicesBySemantics,
+    IDirectInput8AImpl_ConfigureDevices
+};
+
+static const IDirectInput8WVtbl ddi8wvt = {
+    IDirectInput8WImpl_QueryInterface,
+    IDirectInput8WImpl_AddRef,
+    IDirectInput8WImpl_Release,
+    IDirectInput8WImpl_CreateDevice,
+    IDirectInput8WImpl_EnumDevices,
+    IDirectInput8WImpl_GetDeviceStatus,
+    IDirectInput8WImpl_RunControlPanel,
+    IDirectInput8WImpl_Initialize,
+    IDirectInput8WImpl_FindDevice,
+    IDirectInput8WImpl_EnumDevicesBySemantics,
+    IDirectInput8WImpl_ConfigureDevices
+};
+
+static const IDirectInputJoyConfig8Vtbl JoyConfig8vt =
+{
+    JoyConfig8Impl_QueryInterface,
+    JoyConfig8Impl_AddRef,
+    JoyConfig8Impl_Release,
+    JoyConfig8Impl_Acquire,
+    JoyConfig8Impl_Unacquire,
+    JoyConfig8Impl_SetCooperativeLevel,
+    JoyConfig8Impl_SendNotify,
+    JoyConfig8Impl_EnumTypes,
+    JoyConfig8Impl_GetTypeInfo,
+    JoyConfig8Impl_SetTypeInfo,
+    JoyConfig8Impl_DeleteType,
+    JoyConfig8Impl_GetConfig,
+    JoyConfig8Impl_SetConfig,
+    JoyConfig8Impl_DeleteConfig,
+    JoyConfig8Impl_GetUserValues,
+    JoyConfig8Impl_SetUserValues,
+    JoyConfig8Impl_AddNewHardware,
+    JoyConfig8Impl_OpenTypeKey,
+    JoyConfig8Impl_OpenAppStatusKey
+};
+
 /******************************************************************************
  *	DirectInput8Create (DINPUT8.@)
  */
 HRESULT WINAPI DECLSPEC_HOTPATCH DirectInput8Create(HINSTANCE hinst, DWORD dwVersion, REFIID riid, LPVOID *ppDI, LPUNKNOWN punkOuter) {
+    IDirectInputImpl *This;
     IDirectInputA *pDI;
     HRESULT hr, hrCo;
 
@@ -71,25 +1432,13 @@ HRESULT WINAPI DECLSPEC_HOTPATCH DirectInput8Create(HINSTANCE hinst, DWORD dwVer
         return DIERR_NOINTERFACE;
     }
 
-    hrCo = CoInitialize(NULL);
-
-    hr = CoCreateInstance(&CLSID_DirectInput, NULL, CLSCTX_INPROC_SERVER, &IID_IDirectInputA, (void **)&pDI);
-
-    /* Ensure balance of calls. */
-    if (SUCCEEDED(hrCo))
-        CoUninitialize();
+    hr = create_directinput_instance(riid, ppDI, &This);
 
     if (FAILED(hr)) {
         ERR("CoCreateInstance failed with hr = 0x%08x\n", hr);
         return hr;
     }
 
-    hr = IDirectInput_QueryInterface(pDI, riid, ppDI);
-    IDirectInput_Release(pDI);
-
-    if (FAILED(hr))
-        return hr;
-
     /* When aggregation is used (punkOuter!=NULL) the application needs to manually call Initialize. */
     if(punkOuter == NULL && IsEqualGUID(&IID_IDirectInput8A, riid)) {
         IDirectInput8A *DI = *ppDI;
@@ -125,6 +1474,7 @@ typedef struct
 {
     /* IUnknown fields */
     IClassFactory IClassFactory_iface;
+    LONG          ref;
 } IClassFactoryImpl;
 
 static inline IClassFactoryImpl *impl_from_IClassFactory(IClassFactory *iface)
@@ -139,13 +1489,14 @@ static HRESULT WINAPI DI8CF_QueryInterface(LPCLASSFACTORY iface,REFIID riid,LPVO
 }
 
 static ULONG WINAPI DI8CF_AddRef(LPCLASSFACTORY iface) {
-    LockModule();
-    return 2;
+	IClassFactoryImpl *This = impl_from_IClassFactory(iface);
+	return InterlockedIncrement(&(This->ref));
 }
 
 static ULONG WINAPI DI8CF_Release(LPCLASSFACTORY iface) {
-    UnlockModule();
-    return 1;
+	IClassFactoryImpl *This = impl_from_IClassFactory(iface);
+	/* static class, won't be  freed */
+	return InterlockedDecrement(&(This->ref));
 }
 
 static HRESULT WINAPI DI8CF_CreateInstance(LPCLASSFACTORY iface,LPUNKNOWN pOuter,REFIID riid,LPVOID *ppobj) {
@@ -153,17 +1504,7 @@ static HRESULT WINAPI DI8CF_CreateInstance(LPCLASSFACTORY iface,LPUNKNOWN pOuter
 
     TRACE("(%p)->(%p,%s,%p)\n",This,pOuter,debugstr_guid(riid),ppobj);
     if( IsEqualGUID( &IID_IDirectInput8A, riid ) || IsEqualGUID( &IID_IDirectInput8W, riid ) || IsEqualGUID( &IID_IUnknown, riid )) {
-        IDirectInputA *ppDI;
-        HRESULT hr;
-
-        hr = CoCreateInstance(&CLSID_DirectInput, NULL, CLSCTX_INPROC_SERVER, &IID_IDirectInputA, (void **)&ppDI);
-        if (FAILED(hr))
-            return hr;
-
-        hr = IDirectInput_QueryInterface(ppDI, riid, ppobj);
-        IDirectInput_Release(ppDI);
-
-        return hr;
+		return create_directinput_instance(riid, ppobj, NULL);
     }
 
     ERR("(%p,%p,%s,%p) Interface not found!\n",This,pOuter,debugstr_guid(riid),ppobj);    
@@ -171,14 +1512,9 @@ static HRESULT WINAPI DI8CF_CreateInstance(LPCLASSFACTORY iface,LPUNKNOWN pOuter
 }
 
 static HRESULT WINAPI DI8CF_LockServer(LPCLASSFACTORY iface,BOOL dolock) {
-    TRACE("(%p)->(%d)\n", iface, dolock);
-
-    if(dolock)
-        LockModule();
-    else
-        UnlockModule();
-
-    return S_OK;
+	IClassFactoryImpl *This = impl_from_IClassFactory(iface);
+	FIXME("(%p)->(%d),stub!\n",This,dolock);
+	return S_OK;
 }
 
 static const IClassFactoryVtbl DI8CF_Vtbl = {
@@ -196,7 +1532,7 @@ static IClassFactoryImpl DINPUT8_CF = { { &DI8CF_Vtbl } };
  */
 HRESULT WINAPI DllCanUnloadNow(void)
 {
-    return dll_count == 0 ? S_OK : S_FALSE;
+    return S_FALSE;
 }
 
 /***********************************************************************
@@ -216,32 +1552,282 @@ HRESULT WINAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
 }
 
 /***********************************************************************
- *		DllMain
+ *		DllRegisterServer (DINPUT.@)
  */
-BOOL WINAPI DllMain(HINSTANCE hInstDLL, DWORD reason, LPVOID lpv)
+HRESULT WINAPI DllRegisterServer(void)
 {
-    switch (reason)
-    {
-    case DLL_PROCESS_ATTACH:
-        instance = hInstDLL;
-        DisableThreadLibraryCalls( hInstDLL );
-        break;
-    }
-    return TRUE;
+    return __wine_register_resources( DINPUT_instance );
 }
 
 /***********************************************************************
- *		DllRegisterServer (DINPUT8.@)
+ *		DllUnregisterServer (DINPUT.@)
  */
-HRESULT WINAPI DllRegisterServer(void)
+HRESULT WINAPI DllUnregisterServer(void)
 {
-    return __wine_register_resources( instance );
+    return __wine_unregister_resources( DINPUT_instance );
 }
 
-/***********************************************************************
- *		DllUnregisterServer (DINPUT8.@)
+/******************************************************************************
+ *	DInput hook thread
  */
-HRESULT WINAPI DllUnregisterServer(void)
+
+static LRESULT CALLBACK LL_hook_proc( int code, WPARAM wparam, LPARAM lparam )
+{
+    IDirectInputImpl *dinput;
+    int skip = 0;
+
+    if (code != HC_ACTION) return CallNextHookEx( 0, code, wparam, lparam );
+
+    EnterCriticalSection( &dinput_hook_crit );
+    LIST_FOR_EACH_ENTRY( dinput, &direct_input_list, IDirectInputImpl, entry )
+    {
+        IDirectInputDeviceImpl *dev;
+
+        EnterCriticalSection( &dinput->crit );
+        LIST_FOR_EACH_ENTRY( dev, &dinput->devices_list, IDirectInputDeviceImpl, entry )
+            if (dev->acquired && dev->event_proc)
+            {
+                TRACE("calling %p->%p (%lx %lx)\n", dev, dev->event_proc, wparam, lparam);
+                skip |= dev->event_proc( &dev->IDirectInputDevice8A_iface, wparam, lparam );
+            }
+        LeaveCriticalSection( &dinput->crit );
+    }
+    LeaveCriticalSection( &dinput_hook_crit );
+
+    return skip ? 1 : CallNextHookEx( 0, code, wparam, lparam );
+}
+
+static LRESULT CALLBACK callwndproc_proc( int code, WPARAM wparam, LPARAM lparam )
+{
+    CWPSTRUCT *msg = (CWPSTRUCT *)lparam;
+    IDirectInputImpl *dinput;
+    HWND foreground;
+
+    if (code != HC_ACTION || (msg->message != WM_KILLFOCUS &&
+        msg->message != WM_ACTIVATEAPP && msg->message != WM_ACTIVATE))
+        return CallNextHookEx( 0, code, wparam, lparam );
+
+    foreground = GetForegroundWindow();
+
+    EnterCriticalSection( &dinput_hook_crit );
+
+    LIST_FOR_EACH_ENTRY( dinput, &direct_input_list, IDirectInputImpl, entry )
+    {
+        IDirectInputDeviceImpl *dev;
+
+        EnterCriticalSection( &dinput->crit );
+        LIST_FOR_EACH_ENTRY( dev, &dinput->devices_list, IDirectInputDeviceImpl, entry )
+        {
+            if (!dev->acquired) continue;
+
+            if (msg->hwnd == dev->win && msg->hwnd != foreground)
+            {
+                TRACE( "%p window is not foreground - unacquiring %p\n", dev->win, dev );
+                IDirectInputDevice_Unacquire( &dev->IDirectInputDevice8A_iface );
+            }
+        }
+        LeaveCriticalSection( &dinput->crit );
+    }
+    LeaveCriticalSection( &dinput_hook_crit );
+
+    return CallNextHookEx( 0, code, wparam, lparam );
+}
+
+static DWORD WINAPI hook_thread_proc(void *param)
+{
+    static HHOOK kbd_hook, mouse_hook;
+    MSG msg;
+
+    /* Force creation of the message queue */
+    PeekMessageW( &msg, 0, 0, 0, PM_NOREMOVE );
+    SetEvent(param);
+
+    while (GetMessageW( &msg, 0, 0, 0 ))
+    {
+        UINT kbd_cnt = 0, mice_cnt = 0;
+
+        if (msg.message == WM_USER+0x10)
+        {
+            IDirectInputImpl *dinput;
+
+            TRACE( "Processing hook change notification lp:%ld\n", msg.lParam );
+
+            if (!msg.wParam && !msg.lParam)
+            {
+                if (kbd_hook) UnhookWindowsHookEx( kbd_hook );
+                if (mouse_hook) UnhookWindowsHookEx( mouse_hook );
+                kbd_hook = mouse_hook = NULL;
+                break;
+            }
+
+            EnterCriticalSection( &dinput_hook_crit );
+
+            /* Count acquired keyboards and mice*/
+            LIST_FOR_EACH_ENTRY( dinput, &direct_input_list, IDirectInputImpl, entry )
+            {
+                IDirectInputDeviceImpl *dev;
+
+                EnterCriticalSection( &dinput->crit );
+                LIST_FOR_EACH_ENTRY( dev, &dinput->devices_list, IDirectInputDeviceImpl, entry )
+                {
+                    if (!dev->acquired || !dev->event_proc) continue;
+
+                    if (IsEqualGUID( &dev->guid, &GUID_SysKeyboard ) ||
+                        IsEqualGUID( &dev->guid, &DInput_Wine_Keyboard_GUID ))
+                        kbd_cnt++;
+                    else
+                        if (IsEqualGUID( &dev->guid, &GUID_SysMouse ) ||
+                            IsEqualGUID( &dev->guid, &DInput_Wine_Mouse_GUID ))
+                            mice_cnt++;
+                }
+                LeaveCriticalSection( &dinput->crit );
+            }
+            LeaveCriticalSection( &dinput_hook_crit );
+
+            if (kbd_cnt && !kbd_hook)
+                kbd_hook = SetWindowsHookExW( WH_KEYBOARD_LL, LL_hook_proc, DINPUT_instance, 0 );
+            else if (!kbd_cnt && kbd_hook)
+            {
+                UnhookWindowsHookEx( kbd_hook );
+                kbd_hook = NULL;
+            }
+
+            if (mice_cnt && !mouse_hook)
+                mouse_hook = SetWindowsHookExW( WH_MOUSE_LL, LL_hook_proc, DINPUT_instance, 0 );
+            else if (!mice_cnt && mouse_hook)
+            {
+                UnhookWindowsHookEx( mouse_hook );
+                mouse_hook = NULL;
+            }
+        }
+        TranslateMessage(&msg);
+        DispatchMessageW(&msg);
+    }
+
+    return 0;
+}
+
+static DWORD hook_thread_id;
+static HANDLE hook_thread_event;
+
+static CRITICAL_SECTION_DEBUG dinput_critsect_debug =
+{
+    0, 0, &dinput_hook_crit,
+    { &dinput_critsect_debug.ProcessLocksList, &dinput_critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": dinput_hook_crit") }
+};
+static CRITICAL_SECTION dinput_hook_crit = { &dinput_critsect_debug, -1, 0, 0, 0, 0 };
+
+static BOOL check_hook_thread(void)
+{
+    static HANDLE hook_thread;
+
+    EnterCriticalSection(&dinput_hook_crit);
+
+    TRACE("IDirectInputs left: %d, empty=%d, hook_thread=%d\n", list_count(&direct_input_list), list_empty(&direct_input_list), hook_thread);
+    if (!hook_thread)
+    {
+        hook_thread_event = CreateEventW(NULL, FALSE, FALSE, NULL);
+        hook_thread = CreateThread(NULL, 0, hook_thread_proc, hook_thread_event, 0, &hook_thread_id);
+        TRACE("hook_thread=%d, hook_thread_id=%d\n", hook_thread, hook_thread_id);
+        LeaveCriticalSection(&dinput_hook_crit);
+    }
+    else if (list_empty(&direct_input_list) && hook_thread)
+    {
+        DWORD tid = hook_thread_id;
+
+        if (hook_thread_event) /* if thread is not started yet */
+        {
+            WaitForSingleObject(hook_thread_event, INFINITE);
+            CloseHandle(hook_thread_event);
+            hook_thread_event = NULL;
+        }
+
+        hook_thread_id = 0;
+        PostThreadMessageW(tid, WM_USER+0x10, 0, 0);
+        LeaveCriticalSection(&dinput_hook_crit);
+
+        /* wait for hook thread to exit */
+        WaitForSingleObject(hook_thread, INFINITE);
+        CloseHandle(hook_thread);
+        hook_thread = NULL;
+    }
+    else
+        LeaveCriticalSection(&dinput_hook_crit);
+
+    return hook_thread_id != 0;
+}
+
+void check_dinput_hooks(LPDIRECTINPUTDEVICE8W iface, BOOL acquired)
+{
+    static HHOOK callwndproc_hook;
+    static ULONG foreground_cnt;
+    IDirectInputDeviceImpl *dev = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("iface=%p\n", iface);
+
+    EnterCriticalSection(&dinput_hook_crit);
+
+    if (dev->dwCoopLevel & DISCL_FOREGROUND)
+    {
+        if (acquired)
+            foreground_cnt++;
+        else
+            foreground_cnt--;
+    }
+
+    if (foreground_cnt && !callwndproc_hook)
+        callwndproc_hook = SetWindowsHookExW( WH_CALLWNDPROC, callwndproc_proc,
+                                              DINPUT_instance, GetCurrentThreadId() );
+    else if (!foreground_cnt && callwndproc_hook)
+    {
+        UnhookWindowsHookEx( callwndproc_hook );
+        callwndproc_hook = NULL;
+    }
+
+    TRACE("hook_thread_event=%d\n", hook_thread_event);
+    if (hook_thread_event) /* if thread is not started yet */
+    {
+        WaitForSingleObject(hook_thread_event, INFINITE);
+        CloseHandle(hook_thread_event);
+        hook_thread_event = NULL;
+    }
+
+    TRACE("hook_thread_id=%d\n", hook_thread_id);
+
+    PostThreadMessageW( hook_thread_id, WM_USER+0x10, 1, 0 );
+
+    LeaveCriticalSection(&dinput_hook_crit);
+
+    TRACE("done\n");
+}
+
+void check_dinput_events(void)
 {
-    return __wine_unregister_resources( instance );
+    /* Windows does not do that, but our current implementation of winex11
+     * requires periodic event polling to forward events to the wineserver.
+     *
+     * We have to call this function from multiple places, because:
+     * - some games do not explicitly poll for mouse events
+     *   (for example Culpa Innata)
+     * - some games only poll the device, and neither keyboard nor mouse
+     *   (for example Civilization: Call to Power 2)
+     */
+    MsgWaitForMultipleObjectsEx(0, NULL, 0, QS_ALLINPUT, 0);
+}
+
+BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, LPVOID reserved)
+{
+    switch(reason)
+    {
+      case DLL_PROCESS_ATTACH:
+        DisableThreadLibraryCalls(inst);
+        DINPUT_instance = inst;
+        break;
+      case DLL_PROCESS_DETACH:
+        if (reserved) break;
+        DeleteCriticalSection(&dinput_hook_crit);
+        break;
+    }
+    return TRUE;
 }
diff --git a/dlls/dinput8/dinput_main.c b/dlls/dinput8/dinput_main.c
new file mode 100644
index 0000000..c04902c
--- /dev/null
+++ b/dlls/dinput8/dinput_main.c
@@ -0,0 +1,1843 @@
+/*		DirectInput
+ *
+ * Copyright 1998 Marcus Meissner
+ * Copyright 1998,1999 Lionel Ulmer
+ * Copyright 2000-2002 TransGaming Technologies Inc.
+ * Copyright 2007 Vitaliy Margolen
+ *
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+/* Status:
+ *
+ * - Tomb Raider 2 Demo:
+ *   Playable using keyboard only.
+ * - WingCommander Prophecy Demo:
+ *   Doesn't get Input Focus.
+ *
+ * - Fallout : works great in X and DGA mode
+ */
+
+#include "config.h"
+#include <assert.h>
+#include <stdarg.h>
+#include <string.h>
+
+#define COBJMACROS
+#define NONAMELESSUNION
+
+#include "wine/debug.h"
+#include "wine/unicode.h"
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+#include "winerror.h"
+#include "objbase.h"
+#include "rpcproxy.h"
+#include "initguid.h"
+#include "dinput_private.h"
+#include "device_private.h"
+#include "dinputd.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dinput);
+
+static const IDirectInput7AVtbl ddi7avt;
+static const IDirectInput7WVtbl ddi7wvt;
+static const IDirectInput8AVtbl ddi8avt;
+static const IDirectInput8WVtbl ddi8wvt;
+static const IDirectInputJoyConfig8Vtbl JoyConfig8vt;
+
+static inline IDirectInputImpl *impl_from_IDirectInput7A( IDirectInput7A *iface )
+{
+    return CONTAINING_RECORD( iface, IDirectInputImpl, IDirectInput7A_iface );
+}
+
+static inline IDirectInputImpl *impl_from_IDirectInput7W( IDirectInput7W *iface )
+{
+    return CONTAINING_RECORD( iface, IDirectInputImpl, IDirectInput7W_iface );
+}
+
+static inline IDirectInputImpl *impl_from_IDirectInput8A( IDirectInput8A *iface )
+{
+    return CONTAINING_RECORD( iface, IDirectInputImpl, IDirectInput8A_iface );
+}
+
+static inline IDirectInputImpl *impl_from_IDirectInput8W( IDirectInput8W *iface )
+{
+    return CONTAINING_RECORD( iface, IDirectInputImpl, IDirectInput8W_iface );
+}
+
+static inline IDirectInputDeviceImpl *impl_from_IDirectInputDevice8W(IDirectInputDevice8W *iface)
+{
+    return CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8W_iface);
+}
+
+static const struct dinput_device *dinput_devices[] =
+{
+    &mouse_device,
+    &keyboard_device,
+    &joystick_linuxinput_device,
+    &joystick_linux_device,
+    &joystick_osx_device
+};
+
+static HINSTANCE DINPUT_instance = NULL;
+
+static BOOL check_hook_thread(void);
+static CRITICAL_SECTION dinput_hook_crit;
+static struct list direct_input_list = LIST_INIT( direct_input_list );
+
+static HRESULT initialize_directinput_instance(IDirectInputImpl *This, DWORD dwVersion);
+static void uninitialize_directinput_instance(IDirectInputImpl *This);
+
+static HRESULT create_directinput_instance(REFIID riid, LPVOID *ppDI, IDirectInputImpl **out)
+{
+    IDirectInputImpl *This = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IDirectInputImpl) );
+    HRESULT hr;
+
+    if (!This)
+        return E_OUTOFMEMORY;
+
+    This->IDirectInput7A_iface.lpVtbl = &ddi7avt;
+    This->IDirectInput7W_iface.lpVtbl = &ddi7wvt;
+    This->IDirectInput8A_iface.lpVtbl = &ddi8avt;
+    This->IDirectInput8W_iface.lpVtbl = &ddi8wvt;
+    This->IDirectInputJoyConfig8_iface.lpVtbl = &JoyConfig8vt;
+
+    hr = IDirectInput_QueryInterface( &This->IDirectInput7A_iface, riid, ppDI );
+    if (FAILED(hr))
+    {
+        HeapFree( GetProcessHeap(), 0, This );
+        return hr;
+    }
+
+    if (out) *out = This;
+    return DI_OK;
+}
+
+/******************************************************************************
+ *	DirectInputCreateEx (DINPUT.@)
+ */
+HRESULT WINAPI DirectInputCreateEx(
+	HINSTANCE hinst, DWORD dwVersion, REFIID riid, LPVOID *ppDI,
+	LPUNKNOWN punkOuter)
+{
+    IDirectInputImpl *This;
+    HRESULT hr;
+
+    TRACE("(%p,%04x,%s,%p,%p)\n", hinst, dwVersion, debugstr_guid(riid), ppDI, punkOuter);
+
+    if (IsEqualGUID( &IID_IDirectInputA,  riid ) ||
+        IsEqualGUID( &IID_IDirectInput2A, riid ) ||
+        IsEqualGUID( &IID_IDirectInput7A, riid ) ||
+        IsEqualGUID( &IID_IDirectInputW,  riid ) ||
+        IsEqualGUID( &IID_IDirectInput2W, riid ) ||
+        IsEqualGUID( &IID_IDirectInput7W, riid ))
+    {
+        hr = create_directinput_instance(riid, ppDI, &This);
+        if (FAILED(hr))
+            return hr;
+    }
+    else
+        return DIERR_NOINTERFACE;
+
+    hr = IDirectInput_Initialize( &This->IDirectInput7A_iface, hinst, dwVersion );
+    if (FAILED(hr))
+    {
+        IDirectInput_Release( &This->IDirectInput7A_iface );
+        *ppDI = NULL;
+        return hr;
+    }
+
+    return DI_OK;
+}
+
+/******************************************************************************
+ *	DirectInputCreateA (DINPUT.@)
+ */
+HRESULT WINAPI DECLSPEC_HOTPATCH DirectInputCreateA(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTA *ppDI, LPUNKNOWN punkOuter)
+{
+    return DirectInputCreateEx(hinst, dwVersion, &IID_IDirectInput7A, (LPVOID *)ppDI, punkOuter);
+}
+
+/******************************************************************************
+ *	DirectInputCreateW (DINPUT.@)
+ */
+HRESULT WINAPI DECLSPEC_HOTPATCH DirectInputCreateW(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTW *ppDI, LPUNKNOWN punkOuter)
+{
+    return DirectInputCreateEx(hinst, dwVersion, &IID_IDirectInput7W, (LPVOID *)ppDI, punkOuter);
+}
+
+static const char *_dump_DIDEVTYPE_value(DWORD dwDevType, DWORD dwVersion)
+{
+    if (dwVersion < 0x0800) {
+        switch (dwDevType) {
+            case 0: return "All devices";
+            case DIDEVTYPE_MOUSE: return "DIDEVTYPE_MOUSE";
+            case DIDEVTYPE_KEYBOARD: return "DIDEVTYPE_KEYBOARD";
+            case DIDEVTYPE_JOYSTICK: return "DIDEVTYPE_JOYSTICK";
+            case DIDEVTYPE_DEVICE: return "DIDEVTYPE_DEVICE";
+            default: return "Unknown";
+        }
+    } else {
+        switch (dwDevType) {
+            case DI8DEVCLASS_ALL: return "All devices";
+            case DI8DEVCLASS_POINTER: return "DI8DEVCLASS_POINTER";
+            case DI8DEVCLASS_KEYBOARD: return "DI8DEVCLASS_KEYBOARD";
+            case DI8DEVCLASS_DEVICE: return "DI8DEVCLASS_DEVICE";
+            case DI8DEVCLASS_GAMECTRL: return "DI8DEVCLASS_GAMECTRL";
+            default: return "Unknown";
+        }
+    }
+}
+
+static void _dump_EnumDevices_dwFlags(DWORD dwFlags)
+{
+    if (TRACE_ON(dinput)) {
+	unsigned int   i;
+	static const struct {
+	    DWORD       mask;
+	    const char  *name;
+	} flags[] = {
+#define FE(x) { x, #x}
+	    FE(DIEDFL_ALLDEVICES),
+	    FE(DIEDFL_ATTACHEDONLY),
+	    FE(DIEDFL_FORCEFEEDBACK),
+	    FE(DIEDFL_INCLUDEALIASES),
+            FE(DIEDFL_INCLUDEPHANTOMS),
+            FE(DIEDFL_INCLUDEHIDDEN)
+#undef FE
+	};
+	TRACE(" flags: ");
+	if (dwFlags == 0) {
+	    TRACE("DIEDFL_ALLDEVICES\n");
+	    return;
+	}
+	for (i = 0; i < (sizeof(flags) / sizeof(flags[0])); i++)
+	    if (flags[i].mask & dwFlags)
+		TRACE("%s ",flags[i].name);
+    }
+    TRACE("\n");
+}
+
+static void _dump_diactionformatA(LPDIACTIONFORMATA lpdiActionFormat)
+{
+    unsigned int i;
+
+    TRACE("diaf.dwSize = %d\n", lpdiActionFormat->dwSize);
+    TRACE("diaf.dwActionSize = %d\n", lpdiActionFormat->dwActionSize);
+    TRACE("diaf.dwDataSize = %d\n", lpdiActionFormat->dwDataSize);
+    TRACE("diaf.dwNumActions = %d\n", lpdiActionFormat->dwNumActions);
+    TRACE("diaf.rgoAction = %p\n", lpdiActionFormat->rgoAction);
+    TRACE("diaf.guidActionMap = %s\n", debugstr_guid(&lpdiActionFormat->guidActionMap));
+    TRACE("diaf.dwGenre = 0x%08x\n", lpdiActionFormat->dwGenre);
+    TRACE("diaf.dwBufferSize = %d\n", lpdiActionFormat->dwBufferSize);
+    TRACE("diaf.lAxisMin = %d\n", lpdiActionFormat->lAxisMin);
+    TRACE("diaf.lAxisMax = %d\n", lpdiActionFormat->lAxisMax);
+    TRACE("diaf.hInstString = %p\n", lpdiActionFormat->hInstString);
+    TRACE("diaf.ftTimeStamp ...\n");
+    TRACE("diaf.dwCRC = 0x%x\n", lpdiActionFormat->dwCRC);
+    TRACE("diaf.tszActionMap = %s\n", debugstr_a(lpdiActionFormat->tszActionMap));
+    for (i = 0; i < lpdiActionFormat->dwNumActions; i++)
+    {
+        TRACE("diaf.rgoAction[%u]:\n", i);
+        TRACE("\tuAppData=0x%lx\n", lpdiActionFormat->rgoAction[i].uAppData);
+        TRACE("\tdwSemantic=0x%08x\n", lpdiActionFormat->rgoAction[i].dwSemantic);
+        TRACE("\tdwFlags=0x%x\n", lpdiActionFormat->rgoAction[i].dwFlags);
+        TRACE("\tszActionName=%s\n", debugstr_a(lpdiActionFormat->rgoAction[i].u.lptszActionName));
+        TRACE("\tguidInstance=%s\n", debugstr_guid(&lpdiActionFormat->rgoAction[i].guidInstance));
+        TRACE("\tdwObjID=0x%x\n", lpdiActionFormat->rgoAction[i].dwObjID);
+        TRACE("\tdwHow=0x%x\n", lpdiActionFormat->rgoAction[i].dwHow);
+    }
+}
+
+void _copy_diactionformatAtoW(LPDIACTIONFORMATW to, LPDIACTIONFORMATA from)
+{
+    int i;
+
+    to->dwSize = sizeof(DIACTIONFORMATW);
+    to->dwActionSize = sizeof(DIACTIONW);
+    to->dwDataSize = from->dwDataSize;
+    to->dwNumActions = from->dwNumActions;
+    to->guidActionMap = from->guidActionMap;
+    to->dwGenre = from->dwGenre;
+    to->dwBufferSize = from->dwBufferSize;
+    to->lAxisMin = from->lAxisMin;
+    to->lAxisMax = from->lAxisMax;
+    to->dwCRC = from->dwCRC;
+    to->ftTimeStamp = from->ftTimeStamp;
+
+    for (i=0; i < to->dwNumActions; i++)
+    {
+        to->rgoAction[i].uAppData = from->rgoAction[i].uAppData;
+        to->rgoAction[i].dwSemantic = from->rgoAction[i].dwSemantic;
+        to->rgoAction[i].dwFlags = from->rgoAction[i].dwFlags;
+        to->rgoAction[i].guidInstance = from->rgoAction[i].guidInstance;
+        to->rgoAction[i].dwObjID = from->rgoAction[i].dwObjID;
+        to->rgoAction[i].dwHow = from->rgoAction[i].dwHow;
+    }
+}
+
+void _copy_diactionformatWtoA(LPDIACTIONFORMATA to, LPDIACTIONFORMATW from)
+{
+    int i;
+
+    to->dwSize = sizeof(DIACTIONFORMATA);
+    to->dwActionSize = sizeof(DIACTIONA);
+    to->dwDataSize = from->dwDataSize;
+    to->dwNumActions = from->dwNumActions;
+    to->guidActionMap = from->guidActionMap;
+    to->dwGenre = from->dwGenre;
+    to->dwBufferSize = from->dwBufferSize;
+    to->lAxisMin = from->lAxisMin;
+    to->lAxisMax = from->lAxisMax;
+    to->dwCRC = from->dwCRC;
+    to->ftTimeStamp = from->ftTimeStamp;
+
+    for (i=0; i < to->dwNumActions; i++)
+    {
+        to->rgoAction[i].uAppData = from->rgoAction[i].uAppData;
+        to->rgoAction[i].dwSemantic = from->rgoAction[i].dwSemantic;
+        to->rgoAction[i].dwFlags = from->rgoAction[i].dwFlags;
+        to->rgoAction[i].guidInstance = from->rgoAction[i].guidInstance;
+        to->rgoAction[i].dwObjID = from->rgoAction[i].dwObjID;
+        to->rgoAction[i].dwHow = from->rgoAction[i].dwHow;
+    }
+}
+
+/* diactionformat_priority
+ *
+ *  Given a DIACTIONFORMAT structure and a DI genre, returns the enumeration
+ *  priority. Joysticks should pass the game genre, and mouse or keyboard their
+ *  respective DI*_MASK
+ */
+static DWORD diactionformat_priorityA(LPDIACTIONFORMATA lpdiaf, DWORD genre)
+{
+    int i;
+    DWORD priorityFlags = 0;
+
+    /* If there's at least one action for the device it's priority 1 */
+    for(i=0; i < lpdiaf->dwNumActions; i++)
+        if ((lpdiaf->rgoAction[i].dwSemantic & genre) == genre)
+            priorityFlags |= DIEDBS_MAPPEDPRI1;
+
+    return priorityFlags;
+}
+
+static DWORD diactionformat_priorityW(LPDIACTIONFORMATW lpdiaf, DWORD genre)
+{
+    int i;
+    DWORD priorityFlags = 0;
+
+    /* If there's at least one action for the device it's priority 1 */
+    for(i=0; i < lpdiaf->dwNumActions; i++)
+        if ((lpdiaf->rgoAction[i].dwSemantic & genre) == genre)
+            priorityFlags |= DIEDBS_MAPPEDPRI1;
+
+    return priorityFlags;
+}
+
+#if defined __i386__ && defined _MSC_VER
+__declspec(naked) BOOL enum_callback_wrapper(void *callback, const void *instance, void *ref)
+{
+    __asm
+    {
+        push ebp
+        mov ebp, esp
+        push [ebp+16]
+        push [ebp+12]
+        call [ebp+8]
+        leave
+        ret
+    }
+}
+#elif defined __i386__ && defined __GNUC__
+extern BOOL enum_callback_wrapper(void *callback, const void *instance, void *ref);
+__ASM_GLOBAL_FUNC( enum_callback_wrapper,
+    "pushl %ebp\n\t"
+    __ASM_CFI(".cfi_adjust_cfa_offset 4\n\t")
+    __ASM_CFI(".cfi_rel_offset %ebp,0\n\t")
+    "movl %esp,%ebp\n\t"
+    __ASM_CFI(".cfi_def_cfa_register %ebp\n\t")
+    "pushl 16(%ebp)\n\t"
+    "pushl 12(%ebp)\n\t"
+    "call *8(%ebp)\n\t"
+    "leave\n\t"
+    __ASM_CFI(".cfi_def_cfa %esp,4\n\t")
+    __ASM_CFI(".cfi_same_value %ebp\n\t")
+    "ret" )
+#else
+#define enum_callback_wrapper(callback, instance, ref) (callback)((instance), (ref))
+#endif
+
+/******************************************************************************
+ *	IDirectInputA_EnumDevices
+ */
+static HRESULT WINAPI IDirectInputAImpl_EnumDevices(
+	LPDIRECTINPUT7A iface, DWORD dwDevType, LPDIENUMDEVICESCALLBACKA lpCallback,
+	LPVOID pvRef, DWORD dwFlags)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7A(iface);
+    DIDEVICEINSTANCEA devInstance;
+    unsigned int i;
+    int j;
+    HRESULT r;
+
+    TRACE("(this=%p,0x%04x '%s',%p,%p,0x%04x)\n",
+	  This, dwDevType, _dump_DIDEVTYPE_value(dwDevType, This->dwVersion),
+	  lpCallback, pvRef, dwFlags);
+    _dump_EnumDevices_dwFlags(dwFlags);
+
+    if (!lpCallback ||
+        dwFlags & ~(DIEDFL_ATTACHEDONLY | DIEDFL_FORCEFEEDBACK | DIEDFL_INCLUDEALIASES | DIEDFL_INCLUDEPHANTOMS | DIEDFL_INCLUDEHIDDEN) ||
+        (dwDevType > DI8DEVCLASS_GAMECTRL && dwDevType < DI8DEVTYPE_DEVICE) || dwDevType > DI8DEVTYPE_SUPPLEMENTAL)
+        return DIERR_INVALIDPARAM;
+
+    if (!This->initialized)
+        return DIERR_NOTINITIALIZED;
+
+    for (i = 0; i < ARRAY_SIZE(dinput_devices); i++) {
+        if (!dinput_devices[i]->enum_deviceA) continue;
+        for (j = 0, r = S_OK; SUCCEEDED(r); j++) {
+            devInstance.dwSize = sizeof(devInstance);
+            TRACE("  - checking device %u ('%s')\n", i, dinput_devices[i]->name);
+            r = dinput_devices[i]->enum_deviceA(dwDevType, dwFlags, &devInstance, This->dwVersion, j);
+            if (r == S_OK)
+                if (enum_callback_wrapper(lpCallback, &devInstance, pvRef) == DIENUM_STOP)
+                    return S_OK;
+        }
+    }
+
+    return S_OK;
+}
+/******************************************************************************
+ *	IDirectInputW_EnumDevices
+ */
+static HRESULT WINAPI IDirectInputWImpl_EnumDevices(
+	LPDIRECTINPUT7W iface, DWORD dwDevType, LPDIENUMDEVICESCALLBACKW lpCallback,
+	LPVOID pvRef, DWORD dwFlags) 
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7W( iface );
+    DIDEVICEINSTANCEW devInstance;
+    unsigned int i;
+    int j;
+    HRESULT r;
+
+    TRACE("(this=%p,0x%04x '%s',%p,%p,0x%04x)\n",
+	  This, dwDevType, _dump_DIDEVTYPE_value(dwDevType, This->dwVersion),
+	  lpCallback, pvRef, dwFlags);
+    _dump_EnumDevices_dwFlags(dwFlags);
+
+    if (!lpCallback ||
+        dwFlags & ~(DIEDFL_ATTACHEDONLY | DIEDFL_FORCEFEEDBACK | DIEDFL_INCLUDEALIASES | DIEDFL_INCLUDEPHANTOMS | DIEDFL_INCLUDEHIDDEN) ||
+        (dwDevType > DI8DEVCLASS_GAMECTRL && dwDevType < DI8DEVTYPE_DEVICE) || dwDevType > DI8DEVTYPE_SUPPLEMENTAL)
+        return DIERR_INVALIDPARAM;
+
+    if (!This->initialized)
+        return DIERR_NOTINITIALIZED;
+
+    for (i = 0; i < ARRAY_SIZE(dinput_devices); i++) {
+        if (!dinput_devices[i]->enum_deviceW) continue;
+        for (j = 0, r = S_OK; SUCCEEDED(r); j++) {
+            devInstance.dwSize = sizeof(devInstance);
+            TRACE("  - checking device %u ('%s')\n", i, dinput_devices[i]->name);
+            r = dinput_devices[i]->enum_deviceW(dwDevType, dwFlags, &devInstance, This->dwVersion, j);
+            if (r == S_OK)
+                if (enum_callback_wrapper(lpCallback, &devInstance, pvRef) == DIENUM_STOP)
+                    return S_OK;
+        }
+    }
+
+    return S_OK;
+}
+
+static ULONG WINAPI IDirectInputAImpl_AddRef(LPDIRECTINPUT7A iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7A( iface );
+    ULONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE( "(%p) incrementing from %d\n", This, ref - 1);
+    return ref;
+}
+
+static ULONG WINAPI IDirectInputWImpl_AddRef(LPDIRECTINPUT7W iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7W( iface );
+    return IDirectInputAImpl_AddRef( &This->IDirectInput7A_iface );
+}
+
+static ULONG WINAPI IDirectInputAImpl_Release(LPDIRECTINPUT7A iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7A( iface );
+    ULONG ref = InterlockedDecrement( &This->ref );
+
+    TRACE( "(%p) releasing from %d\n", This, ref + 1 );
+
+    if (ref == 0)
+    {
+        uninitialize_directinput_instance( This );
+        HeapFree( GetProcessHeap(), 0, This );
+    }
+
+    return ref;
+}
+
+static ULONG WINAPI IDirectInputWImpl_Release(LPDIRECTINPUT7W iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7W( iface );
+    return IDirectInputAImpl_Release( &This->IDirectInput7A_iface );
+}
+
+static HRESULT WINAPI IDirectInputAImpl_QueryInterface(LPDIRECTINPUT7A iface, REFIID riid, LPVOID *ppobj)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7A( iface );
+
+    TRACE( "(%p)->(%s,%p)\n", This, debugstr_guid(riid), ppobj );
+
+    if (!riid || !ppobj)
+        return E_POINTER;
+
+    if (IsEqualGUID( &IID_IUnknown, riid ) ||
+        IsEqualGUID( &IID_IDirectInputA,  riid ) ||
+        IsEqualGUID( &IID_IDirectInput2A, riid ) ||
+        IsEqualGUID( &IID_IDirectInput7A, riid ))
+    {
+        *ppobj = &This->IDirectInput7A_iface;
+        IUnknown_AddRef( (IUnknown*)*ppobj );
+
+        return DI_OK;
+    }
+
+    if (IsEqualGUID( &IID_IDirectInputW,  riid ) ||
+        IsEqualGUID( &IID_IDirectInput2W, riid ) ||
+        IsEqualGUID( &IID_IDirectInput7W, riid ))
+    {
+        *ppobj = &This->IDirectInput7W_iface;
+        IUnknown_AddRef( (IUnknown*)*ppobj );
+
+        return DI_OK;
+    }
+
+    if (IsEqualGUID( &IID_IDirectInput8A, riid ))
+    {
+        *ppobj = &This->IDirectInput8A_iface;
+        IUnknown_AddRef( (IUnknown*)*ppobj );
+
+        return DI_OK;
+    }
+
+    if (IsEqualGUID( &IID_IDirectInput8W, riid ))
+    {
+        *ppobj = &This->IDirectInput8W_iface;
+        IUnknown_AddRef( (IUnknown*)*ppobj );
+
+        return DI_OK;
+    }
+
+    if (IsEqualGUID( &IID_IDirectInputJoyConfig8, riid ))
+    {
+        *ppobj = &This->IDirectInputJoyConfig8_iface;
+        IUnknown_AddRef( (IUnknown*)*ppobj );
+
+        return DI_OK;
+    }
+
+    FIXME( "Unsupported interface: %s\n", debugstr_guid(riid));
+    *ppobj = NULL;
+    return E_NOINTERFACE;
+}
+
+static HRESULT WINAPI IDirectInputWImpl_QueryInterface(LPDIRECTINPUT7W iface, REFIID riid, LPVOID *ppobj)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7W( iface );
+    return IDirectInputAImpl_QueryInterface( &This->IDirectInput7A_iface, riid, ppobj );
+}
+
+static HRESULT initialize_directinput_instance(IDirectInputImpl *This, DWORD dwVersion)
+{
+    if (!This->initialized)
+    {
+        This->dwVersion = dwVersion;
+        This->evsequence = 1;
+
+        InitializeCriticalSection( &This->crit );
+        This->crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": IDirectInputImpl*->crit");
+
+        list_init( &This->devices_list );
+        list_init( &This->device_players );
+
+        /* Add self to the list of the IDirectInputs */
+        EnterCriticalSection( &dinput_hook_crit );
+        list_add_head( &direct_input_list, &This->entry );
+        LeaveCriticalSection( &dinput_hook_crit );
+
+        This->initialized = TRUE;
+
+        if (!check_hook_thread())
+        {
+            uninitialize_directinput_instance( This );
+            return DIERR_GENERIC;
+        }
+    }
+
+    return DI_OK;
+}
+
+static void uninitialize_directinput_instance(IDirectInputImpl *This)
+{
+    if (This->initialized)
+    {
+        struct DevicePlayer *device_player, *device_player2;
+        /* Remove self from the list of the IDirectInputs */
+        EnterCriticalSection( &dinput_hook_crit );
+        list_remove( &This->entry );
+        LeaveCriticalSection( &dinput_hook_crit );
+
+        LIST_FOR_EACH_ENTRY_SAFE( device_player, device_player2,
+                &This->device_players, struct DevicePlayer, entry )
+            HeapFree(GetProcessHeap(), 0, device_player);
+
+        check_hook_thread();
+
+        This->crit.DebugInfo->Spare[0] = 0;
+        DeleteCriticalSection( &This->crit );
+
+        This->initialized = FALSE;
+    }
+}
+
+enum directinput_versions
+{
+    DIRECTINPUT_VERSION_300 = 0x0300,
+    DIRECTINPUT_VERSION_500 = 0x0500,
+    DIRECTINPUT_VERSION_50A = 0x050A,
+    DIRECTINPUT_VERSION_5B2 = 0x05B2,
+    DIRECTINPUT_VERSION_602 = 0x0602,
+    DIRECTINPUT_VERSION_61A = 0x061A,
+    DIRECTINPUT_VERSION_700 = 0x0700,
+};
+
+static HRESULT WINAPI IDirectInputAImpl_Initialize(LPDIRECTINPUT7A iface, HINSTANCE hinst, DWORD version)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7A( iface );
+
+    TRACE("(%p)->(%p, 0x%04x)\n", iface, hinst, version);
+
+    if (!hinst)
+        return DIERR_INVALIDPARAM;
+    else if (version == 0)
+        return DIERR_NOTINITIALIZED;
+    else if (version > DIRECTINPUT_VERSION_700)
+        return DIERR_OLDDIRECTINPUTVERSION;
+    else if (version != DIRECTINPUT_VERSION_300 && version != DIRECTINPUT_VERSION_500 &&
+             version != DIRECTINPUT_VERSION_50A && version != DIRECTINPUT_VERSION_5B2 &&
+             version != DIRECTINPUT_VERSION_602 && version != DIRECTINPUT_VERSION_61A &&
+             version != DIRECTINPUT_VERSION_700 && version != DIRECTINPUT_VERSION)
+        return DIERR_BETADIRECTINPUTVERSION;
+
+    return initialize_directinput_instance(This, version);
+}
+
+static HRESULT WINAPI IDirectInputWImpl_Initialize(LPDIRECTINPUT7W iface, HINSTANCE hinst, DWORD x)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7W( iface );
+    return IDirectInputAImpl_Initialize( &This->IDirectInput7A_iface, hinst, x );
+}
+
+static HRESULT WINAPI IDirectInputAImpl_GetDeviceStatus(LPDIRECTINPUT7A iface, REFGUID rguid)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7A( iface );
+    HRESULT hr;
+    LPDIRECTINPUTDEVICEA device;
+
+    TRACE( "(%p)->(%s)\n", This, debugstr_guid(rguid) );
+
+    if (!rguid) return E_POINTER;
+    if (!This->initialized)
+        return DIERR_NOTINITIALIZED;
+
+    hr = IDirectInput_CreateDevice( iface, rguid, &device, NULL );
+    if (hr != DI_OK) return DI_NOTATTACHED;
+
+    IUnknown_Release( device );
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI IDirectInputWImpl_GetDeviceStatus(LPDIRECTINPUT7W iface, REFGUID rguid)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7W( iface );
+    return IDirectInputAImpl_GetDeviceStatus( &This->IDirectInput7A_iface, rguid );
+}
+
+static HRESULT WINAPI IDirectInputAImpl_RunControlPanel(LPDIRECTINPUT7A iface,
+							HWND hwndOwner,
+							DWORD dwFlags)
+{
+    WCHAR control_exeW[] = {'c','o','n','t','r','o','l','.','e','x','e',0};
+    STARTUPINFOW si = {0};
+    PROCESS_INFORMATION pi;
+
+    IDirectInputImpl *This = impl_from_IDirectInput7A( iface );
+
+    TRACE( "(%p)->(%p, %08x)\n", This, hwndOwner, dwFlags );
+
+    if (hwndOwner && !IsWindow(hwndOwner))
+        return E_HANDLE;
+
+    if (dwFlags)
+        return DIERR_INVALIDPARAM;
+
+    if (!This->initialized)
+        return DIERR_NOTINITIALIZED;
+
+    if (!CreateProcessW(NULL, control_exeW, NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL, &si, &pi))
+        return HRESULT_FROM_WIN32(GetLastError());
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI IDirectInputWImpl_RunControlPanel(LPDIRECTINPUT7W iface, HWND hwndOwner, DWORD dwFlags)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7W( iface );
+    return IDirectInputAImpl_RunControlPanel( &This->IDirectInput7A_iface, hwndOwner, dwFlags );
+}
+
+static HRESULT WINAPI IDirectInput2AImpl_FindDevice(LPDIRECTINPUT7A iface, REFGUID rguid,
+						    LPCSTR pszName, LPGUID pguidInstance)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7A( iface );
+
+    FIXME( "(%p)->(%s, %s, %p): stub\n", This, debugstr_guid(rguid), pszName, pguidInstance );
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI IDirectInput2WImpl_FindDevice(LPDIRECTINPUT7W iface, REFGUID rguid,
+						    LPCWSTR pszName, LPGUID pguidInstance)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7W( iface );
+
+    FIXME( "(%p)->(%s, %s, %p): stub\n", This, debugstr_guid(rguid), debugstr_w(pszName), pguidInstance );
+
+    return DI_OK;
+}
+
+static HRESULT create_device(IDirectInputImpl *This, REFGUID rguid, REFIID riid, LPVOID *pvOut, BOOL unicode)
+{
+    unsigned int i;
+
+    if (pvOut)
+        *pvOut = NULL;
+
+    if (!rguid || !pvOut)
+        return E_POINTER;
+
+    if (!This->initialized)
+        return DIERR_NOTINITIALIZED;
+
+    /* Loop on all the devices to see if anyone matches the given GUID */
+    for (i = 0; i < ARRAY_SIZE(dinput_devices); i++)
+    {
+        HRESULT ret;
+
+        if (!dinput_devices[i]->create_device) continue;
+        if ((ret = dinput_devices[i]->create_device(This, rguid, riid, pvOut, unicode)) == DI_OK)
+            return DI_OK;
+    }
+
+    WARN("invalid device GUID %s\n", debugstr_guid(rguid));
+    return DIERR_DEVICENOTREG;
+}
+
+static HRESULT WINAPI IDirectInput7AImpl_CreateDeviceEx(LPDIRECTINPUT7A iface, REFGUID rguid,
+                                                        REFIID riid, LPVOID* pvOut, LPUNKNOWN lpUnknownOuter)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7A( iface );
+
+    TRACE("(%p)->(%s, %s, %p, %p)\n", This, debugstr_guid(rguid), debugstr_guid(riid), pvOut, lpUnknownOuter);
+
+    return create_device(This, rguid, riid, pvOut, FALSE);
+}
+
+static HRESULT WINAPI IDirectInput7WImpl_CreateDeviceEx(LPDIRECTINPUT7W iface, REFGUID rguid,
+                                                        REFIID riid, LPVOID* pvOut, LPUNKNOWN lpUnknownOuter)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput7W( iface );
+
+    TRACE("(%p)->(%s, %s, %p, %p)\n", This, debugstr_guid(rguid), debugstr_guid(riid), pvOut, lpUnknownOuter);
+
+    return create_device(This, rguid, riid, pvOut, TRUE);
+}
+
+static HRESULT WINAPI IDirectInputAImpl_CreateDevice(LPDIRECTINPUT7A iface, REFGUID rguid,
+                                                     LPDIRECTINPUTDEVICEA* pdev, LPUNKNOWN punk)
+{
+    return IDirectInput7AImpl_CreateDeviceEx(iface, rguid, NULL, (LPVOID*)pdev, punk);
+}
+
+static HRESULT WINAPI IDirectInputWImpl_CreateDevice(LPDIRECTINPUT7W iface, REFGUID rguid,
+                                                     LPDIRECTINPUTDEVICEW* pdev, LPUNKNOWN punk)
+{
+    return IDirectInput7WImpl_CreateDeviceEx(iface, rguid, NULL, (LPVOID*)pdev, punk);
+}
+
+/*******************************************************************************
+ *      DirectInput8
+ */
+
+static ULONG WINAPI IDirectInput8AImpl_AddRef(LPDIRECTINPUT8A iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+    return IDirectInputAImpl_AddRef( &This->IDirectInput7A_iface );
+}
+
+static ULONG WINAPI IDirectInput8WImpl_AddRef(LPDIRECTINPUT8W iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W( iface );
+    return IDirectInputAImpl_AddRef( &This->IDirectInput7A_iface );
+}
+
+static HRESULT WINAPI IDirectInput8AImpl_QueryInterface(LPDIRECTINPUT8A iface, REFIID riid, LPVOID *ppobj)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+    return IDirectInputAImpl_QueryInterface( &This->IDirectInput7A_iface, riid, ppobj );
+}
+
+static HRESULT WINAPI IDirectInput8WImpl_QueryInterface(LPDIRECTINPUT8W iface, REFIID riid, LPVOID *ppobj)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W( iface );
+    return IDirectInputAImpl_QueryInterface( &This->IDirectInput7A_iface, riid, ppobj );
+}
+
+static ULONG WINAPI IDirectInput8AImpl_Release(LPDIRECTINPUT8A iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+    return IDirectInputAImpl_Release( &This->IDirectInput7A_iface );
+}
+
+static ULONG WINAPI IDirectInput8WImpl_Release(LPDIRECTINPUT8W iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W( iface );
+    return IDirectInputAImpl_Release( &This->IDirectInput7A_iface );
+}
+
+static HRESULT WINAPI IDirectInput8AImpl_CreateDevice(LPDIRECTINPUT8A iface, REFGUID rguid,
+                                                      LPDIRECTINPUTDEVICE8A* pdev, LPUNKNOWN punk)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+    return IDirectInput7AImpl_CreateDeviceEx( &This->IDirectInput7A_iface, rguid, NULL, (LPVOID*)pdev, punk );
+}
+
+static HRESULT WINAPI IDirectInput8WImpl_CreateDevice(LPDIRECTINPUT8W iface, REFGUID rguid,
+                                                      LPDIRECTINPUTDEVICE8W* pdev, LPUNKNOWN punk)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W( iface );
+    return IDirectInput7WImpl_CreateDeviceEx( &This->IDirectInput7W_iface, rguid, NULL, (LPVOID*)pdev, punk );
+}
+
+static HRESULT WINAPI IDirectInput8AImpl_EnumDevices(LPDIRECTINPUT8A iface, DWORD dwDevType, LPDIENUMDEVICESCALLBACKA lpCallback,
+                                                     LPVOID pvRef, DWORD dwFlags)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+    return IDirectInputAImpl_EnumDevices( &This->IDirectInput7A_iface, dwDevType, lpCallback, pvRef, dwFlags );
+}
+
+static HRESULT WINAPI IDirectInput8WImpl_EnumDevices(LPDIRECTINPUT8W iface, DWORD dwDevType, LPDIENUMDEVICESCALLBACKW lpCallback,
+                                                     LPVOID pvRef, DWORD dwFlags)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W( iface );
+    return IDirectInputWImpl_EnumDevices( &This->IDirectInput7W_iface, dwDevType, lpCallback, pvRef, dwFlags );
+}
+
+static HRESULT WINAPI IDirectInput8AImpl_GetDeviceStatus(LPDIRECTINPUT8A iface, REFGUID rguid)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+    return IDirectInputAImpl_GetDeviceStatus( &This->IDirectInput7A_iface, rguid );
+}
+
+static HRESULT WINAPI IDirectInput8WImpl_GetDeviceStatus(LPDIRECTINPUT8W iface, REFGUID rguid)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W( iface );
+    return IDirectInputAImpl_GetDeviceStatus( &This->IDirectInput7A_iface, rguid );
+}
+
+static HRESULT WINAPI IDirectInput8AImpl_RunControlPanel(LPDIRECTINPUT8A iface, HWND hwndOwner, DWORD dwFlags)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+    return IDirectInputAImpl_RunControlPanel( &This->IDirectInput7A_iface, hwndOwner, dwFlags );
+}
+
+static HRESULT WINAPI IDirectInput8WImpl_RunControlPanel(LPDIRECTINPUT8W iface, HWND hwndOwner, DWORD dwFlags)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W( iface );
+    return IDirectInputAImpl_RunControlPanel( &This->IDirectInput7A_iface, hwndOwner, dwFlags );
+}
+
+static HRESULT WINAPI IDirectInput8AImpl_Initialize(LPDIRECTINPUT8A iface, HINSTANCE hinst, DWORD version)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+
+    TRACE("(%p)->(%p, 0x%04x)\n", iface, hinst, version);
+
+    if (!hinst)
+        return DIERR_INVALIDPARAM;
+    else if (version == 0)
+        return DIERR_NOTINITIALIZED;
+    else if (version < DIRECTINPUT_VERSION)
+        return DIERR_BETADIRECTINPUTVERSION;
+    else if (version > DIRECTINPUT_VERSION)
+        return DIERR_OLDDIRECTINPUTVERSION;
+
+    return initialize_directinput_instance(This, version);
+}
+
+static HRESULT WINAPI IDirectInput8WImpl_Initialize(LPDIRECTINPUT8W iface, HINSTANCE hinst, DWORD version)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W( iface );
+    return IDirectInput8AImpl_Initialize( &This->IDirectInput8A_iface, hinst, version );
+}
+
+static HRESULT WINAPI IDirectInput8AImpl_FindDevice(LPDIRECTINPUT8A iface, REFGUID rguid, LPCSTR pszName, LPGUID pguidInstance)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+    return IDirectInput2AImpl_FindDevice( &This->IDirectInput7A_iface, rguid, pszName, pguidInstance );
+}
+
+static HRESULT WINAPI IDirectInput8WImpl_FindDevice(LPDIRECTINPUT8W iface, REFGUID rguid, LPCWSTR pszName, LPGUID pguidInstance)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W( iface );
+    return IDirectInput2WImpl_FindDevice( &This->IDirectInput7W_iface, rguid, pszName, pguidInstance );
+}
+
+static BOOL should_enumerate_device(const WCHAR *username, DWORD dwFlags,
+    struct list *device_players, REFGUID guid)
+{
+    BOOL should_enumerate = TRUE;
+    struct DevicePlayer *device_player;
+
+    /* Check if user owns this device */
+    if (dwFlags & DIEDBSFL_THISUSER && username && *username)
+    {
+        should_enumerate = FALSE;
+        LIST_FOR_EACH_ENTRY(device_player, device_players, struct DevicePlayer, entry)
+        {
+            if (IsEqualGUID(&device_player->instance_guid, guid))
+            {
+                if (*device_player->username && !lstrcmpW(username, device_player->username))
+                    return TRUE; /* Device username matches */
+                break;
+            }
+        }
+    }
+
+    /* Check if this device is not owned by anyone */
+    if (dwFlags & DIEDBSFL_AVAILABLEDEVICES) {
+        BOOL found = FALSE;
+        should_enumerate = FALSE;
+        LIST_FOR_EACH_ENTRY(device_player, device_players, struct DevicePlayer, entry)
+        {
+            if (IsEqualGUID(&device_player->instance_guid, guid))
+            {
+                if (*device_player->username)
+                    found = TRUE;
+                break;
+            }
+        }
+        if (!found)
+            return TRUE; /* Device does not have a username */
+    }
+
+    return should_enumerate;
+}
+
+static HRESULT WINAPI IDirectInput8AImpl_EnumDevicesBySemantics(
+      LPDIRECTINPUT8A iface, LPCSTR ptszUserName, LPDIACTIONFORMATA lpdiActionFormat,
+      LPDIENUMDEVICESBYSEMANTICSCBA lpCallback,
+      LPVOID pvRef, DWORD dwFlags
+)
+{
+    static REFGUID guids[2] = { &GUID_SysKeyboard, &GUID_SysMouse };
+    static const DWORD actionMasks[] = { DIKEYBOARD_MASK, DIMOUSE_MASK };
+    IDirectInputImpl *This = impl_from_IDirectInput8A( iface );
+    DIDEVICEINSTANCEA didevi;
+    LPDIRECTINPUTDEVICE8A lpdid;
+    DWORD callbackFlags;
+    int i, j;
+    int device_count = 0;
+    int remain;
+    DIDEVICEINSTANCEA *didevis = 0;
+    WCHAR *username_w = 0;
+
+    FIXME("(this=%p,%s,%p,%p,%p,%04x): semi-stub\n", This, debugstr_a(ptszUserName), lpdiActionFormat,
+          lpCallback, pvRef, dwFlags);
+#define X(x) if (dwFlags & x) FIXME("\tdwFlags |= "#x"\n");
+	X(DIEDBSFL_ATTACHEDONLY)
+	X(DIEDBSFL_THISUSER)
+	X(DIEDBSFL_FORCEFEEDBACK)
+	X(DIEDBSFL_AVAILABLEDEVICES)
+	X(DIEDBSFL_MULTIMICEKEYBOARDS)
+	X(DIEDBSFL_NONGAMINGDEVICES)
+#undef X
+
+    _dump_diactionformatA(lpdiActionFormat);
+
+    didevi.dwSize = sizeof(didevi);
+
+    if (ptszUserName)
+    {
+        int len = MultiByteToWideChar(CP_ACP, 0, ptszUserName, -1, 0, 0);
+
+        username_w = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR)*len);
+        MultiByteToWideChar(CP_ACP, 0, ptszUserName, -1, username_w, len);
+    }
+
+    /* Enumerate all the joysticks */
+    for (i = 0; i < ARRAY_SIZE(dinput_devices); i++)
+    {
+        HRESULT enumSuccess;
+
+        if (!dinput_devices[i]->enum_deviceA) continue;
+
+        for (j = 0, enumSuccess = S_OK; SUCCEEDED(enumSuccess); j++)
+        {
+            TRACE(" - checking device %u ('%s')\n", i, dinput_devices[i]->name);
+
+            /* Default behavior is to enumerate attached game controllers */
+            enumSuccess = dinput_devices[i]->enum_deviceA(DI8DEVCLASS_GAMECTRL, DIEDFL_ATTACHEDONLY | dwFlags, &didevi, This->dwVersion, j);
+            if (enumSuccess == S_OK &&
+                should_enumerate_device(username_w, dwFlags, &This->device_players, &didevi.guidInstance))
+            {
+                if (device_count++)
+                    didevis = HeapReAlloc(GetProcessHeap(), 0, didevis, sizeof(DIDEVICEINSTANCEA)*device_count);
+                else
+                    didevis = HeapAlloc(GetProcessHeap(), 0, sizeof(DIDEVICEINSTANCEA)*device_count);
+                didevis[device_count-1] = didevi;
+            }
+        }
+    }
+
+    remain = device_count;
+    /* Add keyboard and mouse to remaining device count */
+    if (!(dwFlags & DIEDBSFL_FORCEFEEDBACK))
+    {
+        for (i = 0; i < sizeof(guids) / sizeof(guids[0]); i++)
+        {
+            if (should_enumerate_device(username_w, dwFlags, &This->device_players, guids[i]))
+                remain++;
+        }
+    }
+
+    for (i = 0; i < device_count; i++)
+    {
+        callbackFlags = diactionformat_priorityA(lpdiActionFormat, lpdiActionFormat->dwGenre);
+        IDirectInput_CreateDevice(iface, &didevis[i].guidInstance, &lpdid, NULL);
+
+        if (lpCallback(&didevis[i], lpdid, callbackFlags, --remain, pvRef) == DIENUM_STOP)
+        {
+            HeapFree(GetProcessHeap(), 0, didevis);
+            HeapFree(GetProcessHeap(), 0, username_w);
+            return DI_OK;
+        }
+    }
+
+    HeapFree(GetProcessHeap(), 0, didevis);
+
+    if (dwFlags & DIEDBSFL_FORCEFEEDBACK)
+    {
+        HeapFree(GetProcessHeap(), 0, username_w);
+        return DI_OK;
+    }
+
+    /* Enumerate keyboard and mouse */
+    for(i=0; i < sizeof(guids)/sizeof(guids[0]); i++)
+    {
+        if (should_enumerate_device(username_w, dwFlags, &This->device_players, guids[i]))
+        {
+            callbackFlags = diactionformat_priorityA(lpdiActionFormat, actionMasks[i]);
+
+            IDirectInput_CreateDevice(iface, guids[i], &lpdid, NULL);
+            IDirectInputDevice_GetDeviceInfo(lpdid, &didevi);
+
+            if (lpCallback(&didevi, lpdid, callbackFlags, --remain, pvRef) == DIENUM_STOP)
+            {
+                HeapFree(GetProcessHeap(), 0, username_w);
+                return DI_OK;
+            }
+        }
+    }
+
+    HeapFree(GetProcessHeap(), 0, username_w);
+    return DI_OK;
+}
+
+static HRESULT WINAPI IDirectInput8WImpl_EnumDevicesBySemantics(
+      LPDIRECTINPUT8W iface, LPCWSTR ptszUserName, LPDIACTIONFORMATW lpdiActionFormat,
+      LPDIENUMDEVICESBYSEMANTICSCBW lpCallback,
+      LPVOID pvRef, DWORD dwFlags
+)
+{
+    static REFGUID guids[2] = { &GUID_SysKeyboard, &GUID_SysMouse };
+    static const DWORD actionMasks[] = { DIKEYBOARD_MASK, DIMOUSE_MASK };
+    IDirectInputImpl *This = impl_from_IDirectInput8W(iface);
+    DIDEVICEINSTANCEW didevi;
+    LPDIRECTINPUTDEVICE8W lpdid;
+    DWORD callbackFlags;
+    int i, j;
+    int device_count = 0;
+    int remain;
+    DIDEVICEINSTANCEW *didevis = 0;
+
+    FIXME("(this=%p,%s,%p,%p,%p,%04x): semi-stub\n", This, debugstr_w(ptszUserName), lpdiActionFormat,
+          lpCallback, pvRef, dwFlags);
+
+    didevi.dwSize = sizeof(didevi);
+
+    /* Enumerate all the joysticks */
+    for (i = 0; i < ARRAY_SIZE(dinput_devices); i++)
+    {
+        HRESULT enumSuccess;
+
+        if (!dinput_devices[i]->enum_deviceW) continue;
+
+        for (j = 0, enumSuccess = S_OK; SUCCEEDED(enumSuccess); j++)
+        {
+            TRACE(" - checking device %u ('%s')\n", i, dinput_devices[i]->name);
+
+            /* Default behavior is to enumerate attached game controllers */
+            enumSuccess = dinput_devices[i]->enum_deviceW(DI8DEVCLASS_GAMECTRL, DIEDFL_ATTACHEDONLY | dwFlags, &didevi, This->dwVersion, j);
+            if (enumSuccess == S_OK &&
+                should_enumerate_device(ptszUserName, dwFlags, &This->device_players, &didevi.guidInstance))
+            {
+                if (device_count++)
+                    didevis = HeapReAlloc(GetProcessHeap(), 0, didevis, sizeof(DIDEVICEINSTANCEW)*device_count);
+                else
+                    didevis = HeapAlloc(GetProcessHeap(), 0, sizeof(DIDEVICEINSTANCEW)*device_count);
+                didevis[device_count-1] = didevi;
+            }
+        }
+    }
+
+    remain = device_count;
+    /* Add keyboard and mouse to remaining device count */
+    if (!(dwFlags & DIEDBSFL_FORCEFEEDBACK))
+    {
+        for (i = 0; i < sizeof(guids) / sizeof(guids[0]); i++)
+        {
+            if (should_enumerate_device(ptszUserName, dwFlags, &This->device_players, guids[i]))
+                remain++;
+        }
+    }
+
+    for (i = 0; i < device_count; i++)
+    {
+        callbackFlags = diactionformat_priorityW(lpdiActionFormat, lpdiActionFormat->dwGenre);
+        IDirectInput_CreateDevice(iface, &didevis[i].guidInstance, &lpdid, NULL);
+
+        if (lpCallback(&didevis[i], lpdid, callbackFlags, --remain, pvRef) == DIENUM_STOP)
+        {
+            HeapFree(GetProcessHeap(), 0, didevis);
+            return DI_OK;
+        }
+    }
+
+    HeapFree(GetProcessHeap(), 0, didevis);
+
+    if (dwFlags & DIEDBSFL_FORCEFEEDBACK) return DI_OK;
+
+    /* Enumerate keyboard and mouse */
+    for(i=0; i < sizeof(guids)/sizeof(guids[0]); i++)
+    {
+        if (should_enumerate_device(ptszUserName, dwFlags, &This->device_players, guids[i]))
+        {
+            callbackFlags = diactionformat_priorityW(lpdiActionFormat, actionMasks[i]);
+
+            IDirectInput_CreateDevice(iface, guids[i], &lpdid, NULL);
+            IDirectInputDevice_GetDeviceInfo(lpdid, &didevi);
+
+            if (lpCallback(&didevi, lpdid, callbackFlags, --remain, pvRef) == DIENUM_STOP)
+                return DI_OK;
+        }
+    }
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI IDirectInput8WImpl_ConfigureDevices(
+      LPDIRECTINPUT8W iface, LPDICONFIGUREDEVICESCALLBACK lpdiCallback,
+      LPDICONFIGUREDEVICESPARAMSW lpdiCDParams, DWORD dwFlags, LPVOID pvRefData
+)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8W(iface);
+
+    FIXME("(this=%p,%p,%p,%04x,%p): stub\n", This, lpdiCallback, lpdiCDParams, dwFlags, pvRefData);
+
+    /* Call helper function in config.c to do the real work */
+    return _configure_devices(iface, lpdiCallback, lpdiCDParams, dwFlags, pvRefData);
+}
+
+static HRESULT WINAPI IDirectInput8AImpl_ConfigureDevices(
+      LPDIRECTINPUT8A iface, LPDICONFIGUREDEVICESCALLBACK lpdiCallback,
+      LPDICONFIGUREDEVICESPARAMSA lpdiCDParams, DWORD dwFlags, LPVOID pvRefData
+)
+{
+    IDirectInputImpl *This = impl_from_IDirectInput8A(iface);
+    DIACTIONFORMATW diafW;
+    DICONFIGUREDEVICESPARAMSW diCDParamsW;
+    HRESULT hr;
+    int i;
+
+     FIXME("(this=%p,%p,%p,%04x,%p): stub\n", This, lpdiCallback, lpdiCDParams, dwFlags, pvRefData);
+
+    /* Copy parameters */
+    diCDParamsW.dwSize = sizeof(DICONFIGUREDEVICESPARAMSW);
+    diCDParamsW.dwcFormats = lpdiCDParams->dwcFormats;
+    diCDParamsW.lprgFormats = &diafW;
+    diCDParamsW.hwnd = lpdiCDParams->hwnd;
+
+    diafW.rgoAction = HeapAlloc(GetProcessHeap(), 0, sizeof(DIACTIONW)*lpdiCDParams->lprgFormats->dwNumActions);
+    _copy_diactionformatAtoW(&diafW, lpdiCDParams->lprgFormats);
+
+    /* Copy action names */
+    for (i=0; i < diafW.dwNumActions; i++)
+    {
+        const char* from = lpdiCDParams->lprgFormats->rgoAction[i].u.lptszActionName;
+        int len = MultiByteToWideChar(CP_ACP, 0, from , -1, NULL , 0);
+        WCHAR *to = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR)*len);
+
+        MultiByteToWideChar(CP_ACP, 0, from , -1, to , len);
+        diafW.rgoAction[i].u.lptszActionName = to;
+    }
+
+    hr = IDirectInput8WImpl_ConfigureDevices(&This->IDirectInput8W_iface, lpdiCallback, &diCDParamsW, dwFlags, pvRefData);
+
+    /* Copy back configuration */
+    if (SUCCEEDED(hr))
+        _copy_diactionformatWtoA(lpdiCDParams->lprgFormats, &diafW);
+
+    /* Free memory */
+    for (i=0; i < diafW.dwNumActions; i++)
+        HeapFree(GetProcessHeap(), 0, (void*) diafW.rgoAction[i].u.lptszActionName);
+
+    HeapFree(GetProcessHeap(), 0, diafW.rgoAction);
+
+    return hr;
+}
+
+/*****************************************************************************
+ * IDirectInputJoyConfig8 interface
+ */
+
+static inline IDirectInputImpl *impl_from_IDirectInputJoyConfig8(IDirectInputJoyConfig8 *iface)
+{
+    return CONTAINING_RECORD( iface, IDirectInputImpl, IDirectInputJoyConfig8_iface );
+}
+
+static HRESULT WINAPI JoyConfig8Impl_QueryInterface(IDirectInputJoyConfig8 *iface, REFIID riid, void** ppobj)
+{
+    IDirectInputImpl *This = impl_from_IDirectInputJoyConfig8( iface );
+    return IDirectInputAImpl_QueryInterface( &This->IDirectInput7A_iface, riid, ppobj );
+}
+
+static ULONG WINAPI JoyConfig8Impl_AddRef(IDirectInputJoyConfig8 *iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInputJoyConfig8( iface );
+    return IDirectInputAImpl_AddRef( &This->IDirectInput7A_iface );
+}
+
+static ULONG WINAPI JoyConfig8Impl_Release(IDirectInputJoyConfig8 *iface)
+{
+    IDirectInputImpl *This = impl_from_IDirectInputJoyConfig8( iface );
+    return IDirectInputAImpl_Release( &This->IDirectInput7A_iface );
+}
+
+static HRESULT WINAPI JoyConfig8Impl_Acquire(IDirectInputJoyConfig8 *iface)
+{
+    FIXME( "(%p): stub!\n", iface );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_Unacquire(IDirectInputJoyConfig8 *iface)
+{
+    FIXME( "(%p): stub!\n", iface );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_SetCooperativeLevel(IDirectInputJoyConfig8 *iface, HWND hwnd, DWORD flags)
+{
+    FIXME( "(%p)->(%p, 0x%08x): stub!\n", iface, hwnd, flags );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_SendNotify(IDirectInputJoyConfig8 *iface)
+{
+    FIXME( "(%p): stub!\n", iface );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_EnumTypes(IDirectInputJoyConfig8 *iface, LPDIJOYTYPECALLBACK cb, void *ref)
+{
+    FIXME( "(%p)->(%p, %p): stub!\n", iface, cb, ref );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_GetTypeInfo(IDirectInputJoyConfig8 *iface, LPCWSTR name, LPDIJOYTYPEINFO info, DWORD flags)
+{
+    FIXME( "(%p)->(%s, %p, 0x%08x): stub!\n", iface, debugstr_w(name), info, flags );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_SetTypeInfo(IDirectInputJoyConfig8 *iface, LPCWSTR name, LPCDIJOYTYPEINFO info, DWORD flags,
+                                                 LPWSTR new_name)
+{
+    FIXME( "(%p)->(%s, %p, 0x%08x, %s): stub!\n", iface, debugstr_w(name), info, flags, debugstr_w(new_name) );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_DeleteType(IDirectInputJoyConfig8 *iface, LPCWSTR name)
+{
+    FIXME( "(%p)->(%s): stub!\n", iface, debugstr_w(name) );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_GetConfig(IDirectInputJoyConfig8 *iface, UINT id, LPDIJOYCONFIG info, DWORD flags)
+{
+    IDirectInputImpl *di = impl_from_IDirectInputJoyConfig8(iface);
+    UINT found = 0;
+    int i, j;
+    HRESULT r;
+
+    FIXME("(%p)->(%d, %p, 0x%08x): semi-stub!\n", iface, id, info, flags);
+
+#define X(x) if (flags & x) FIXME("\tflags |= "#x"\n");
+    X(DIJC_GUIDINSTANCE)
+    X(DIJC_REGHWCONFIGTYPE)
+    X(DIJC_GAIN)
+    X(DIJC_CALLOUT)
+#undef X
+
+    /* Enumerate all joysticks in order */
+    for (i = 0; i < ARRAY_SIZE(dinput_devices); i++)
+    {
+        if (!dinput_devices[i]->enum_deviceA) continue;
+
+        for (j = 0, r = S_OK; SUCCEEDED(r); j++)
+        {
+            DIDEVICEINSTANCEA dev;
+            dev.dwSize = sizeof(dev);
+            if ((r = dinput_devices[i]->enum_deviceA(DI8DEVCLASS_GAMECTRL, 0, &dev, di->dwVersion, j)) == S_OK)
+            {
+                /* Only take into account the chosen id */
+                if (found == id)
+                {
+                    if (flags & DIJC_GUIDINSTANCE)
+                        info->guidInstance = dev.guidInstance;
+
+                    return DI_OK;
+                }
+                found += 1;
+            }
+        }
+    }
+
+    return DIERR_NOMOREITEMS;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_SetConfig(IDirectInputJoyConfig8 *iface, UINT id, LPCDIJOYCONFIG info, DWORD flags)
+{
+    FIXME( "(%p)->(%d, %p, 0x%08x): stub!\n", iface, id, info, flags );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_DeleteConfig(IDirectInputJoyConfig8 *iface, UINT id)
+{
+    FIXME( "(%p)->(%d): stub!\n", iface, id );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_GetUserValues(IDirectInputJoyConfig8 *iface, LPDIJOYUSERVALUES info, DWORD flags)
+{
+    FIXME( "(%p)->(%p, 0x%08x): stub!\n", iface, info, flags );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_SetUserValues(IDirectInputJoyConfig8 *iface, LPCDIJOYUSERVALUES info, DWORD flags)
+{
+    FIXME( "(%p)->(%p, 0x%08x): stub!\n", iface, info, flags );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_AddNewHardware(IDirectInputJoyConfig8 *iface, HWND hwnd, REFGUID guid)
+{
+    FIXME( "(%p)->(%p, %s): stub!\n", iface, hwnd, debugstr_guid(guid) );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_OpenTypeKey(IDirectInputJoyConfig8 *iface, LPCWSTR name, DWORD security, PHKEY key)
+{
+    FIXME( "(%p)->(%s, 0x%08x, %p): stub!\n", iface, debugstr_w(name), security, key );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI JoyConfig8Impl_OpenAppStatusKey(IDirectInputJoyConfig8 *iface, PHKEY key)
+{
+    FIXME( "(%p)->(%p): stub!\n", iface, key );
+    return E_NOTIMPL;
+}
+
+static const IDirectInput7AVtbl ddi7avt = {
+    IDirectInputAImpl_QueryInterface,
+    IDirectInputAImpl_AddRef,
+    IDirectInputAImpl_Release,
+    IDirectInputAImpl_CreateDevice,
+    IDirectInputAImpl_EnumDevices,
+    IDirectInputAImpl_GetDeviceStatus,
+    IDirectInputAImpl_RunControlPanel,
+    IDirectInputAImpl_Initialize,
+    IDirectInput2AImpl_FindDevice,
+    IDirectInput7AImpl_CreateDeviceEx
+};
+
+static const IDirectInput7WVtbl ddi7wvt = {
+    IDirectInputWImpl_QueryInterface,
+    IDirectInputWImpl_AddRef,
+    IDirectInputWImpl_Release,
+    IDirectInputWImpl_CreateDevice,
+    IDirectInputWImpl_EnumDevices,
+    IDirectInputWImpl_GetDeviceStatus,
+    IDirectInputWImpl_RunControlPanel,
+    IDirectInputWImpl_Initialize,
+    IDirectInput2WImpl_FindDevice,
+    IDirectInput7WImpl_CreateDeviceEx
+};
+
+static const IDirectInput8AVtbl ddi8avt = {
+    IDirectInput8AImpl_QueryInterface,
+    IDirectInput8AImpl_AddRef,
+    IDirectInput8AImpl_Release,
+    IDirectInput8AImpl_CreateDevice,
+    IDirectInput8AImpl_EnumDevices,
+    IDirectInput8AImpl_GetDeviceStatus,
+    IDirectInput8AImpl_RunControlPanel,
+    IDirectInput8AImpl_Initialize,
+    IDirectInput8AImpl_FindDevice,
+    IDirectInput8AImpl_EnumDevicesBySemantics,
+    IDirectInput8AImpl_ConfigureDevices
+};
+
+static const IDirectInput8WVtbl ddi8wvt = {
+    IDirectInput8WImpl_QueryInterface,
+    IDirectInput8WImpl_AddRef,
+    IDirectInput8WImpl_Release,
+    IDirectInput8WImpl_CreateDevice,
+    IDirectInput8WImpl_EnumDevices,
+    IDirectInput8WImpl_GetDeviceStatus,
+    IDirectInput8WImpl_RunControlPanel,
+    IDirectInput8WImpl_Initialize,
+    IDirectInput8WImpl_FindDevice,
+    IDirectInput8WImpl_EnumDevicesBySemantics,
+    IDirectInput8WImpl_ConfigureDevices
+};
+
+static const IDirectInputJoyConfig8Vtbl JoyConfig8vt =
+{
+    JoyConfig8Impl_QueryInterface,
+    JoyConfig8Impl_AddRef,
+    JoyConfig8Impl_Release,
+    JoyConfig8Impl_Acquire,
+    JoyConfig8Impl_Unacquire,
+    JoyConfig8Impl_SetCooperativeLevel,
+    JoyConfig8Impl_SendNotify,
+    JoyConfig8Impl_EnumTypes,
+    JoyConfig8Impl_GetTypeInfo,
+    JoyConfig8Impl_SetTypeInfo,
+    JoyConfig8Impl_DeleteType,
+    JoyConfig8Impl_GetConfig,
+    JoyConfig8Impl_SetConfig,
+    JoyConfig8Impl_DeleteConfig,
+    JoyConfig8Impl_GetUserValues,
+    JoyConfig8Impl_SetUserValues,
+    JoyConfig8Impl_AddNewHardware,
+    JoyConfig8Impl_OpenTypeKey,
+    JoyConfig8Impl_OpenAppStatusKey
+};
+
+/*******************************************************************************
+ * DirectInput ClassFactory
+ */
+typedef struct
+{
+    /* IUnknown fields */
+    IClassFactory IClassFactory_iface;
+    LONG          ref;
+} IClassFactoryImpl;
+
+static inline IClassFactoryImpl *impl_from_IClassFactory(IClassFactory *iface)
+{
+        return CONTAINING_RECORD(iface, IClassFactoryImpl, IClassFactory_iface);
+}
+
+static HRESULT WINAPI DICF_QueryInterface(LPCLASSFACTORY iface,REFIID riid,LPVOID *ppobj) {
+	IClassFactoryImpl *This = impl_from_IClassFactory(iface);
+
+	FIXME("(%p)->(%s,%p),stub!\n",This,debugstr_guid(riid),ppobj);
+	return E_NOINTERFACE;
+}
+
+static ULONG WINAPI DICF_AddRef(LPCLASSFACTORY iface) {
+	IClassFactoryImpl *This = impl_from_IClassFactory(iface);
+	return InterlockedIncrement(&(This->ref));
+}
+
+static ULONG WINAPI DICF_Release(LPCLASSFACTORY iface) {
+	IClassFactoryImpl *This = impl_from_IClassFactory(iface);
+	/* static class, won't be  freed */
+	return InterlockedDecrement(&(This->ref));
+}
+
+static HRESULT WINAPI DICF_CreateInstance(
+	LPCLASSFACTORY iface,LPUNKNOWN pOuter,REFIID riid,LPVOID *ppobj
+) {
+	IClassFactoryImpl *This = impl_from_IClassFactory(iface);
+
+	TRACE("(%p)->(%p,%s,%p)\n",This,pOuter,debugstr_guid(riid),ppobj);
+        if ( IsEqualGUID( &IID_IUnknown, riid ) ||
+             IsEqualGUID( &IID_IDirectInputA, riid ) ||
+	     IsEqualGUID( &IID_IDirectInputW, riid ) ||
+	     IsEqualGUID( &IID_IDirectInput2A, riid ) ||
+	     IsEqualGUID( &IID_IDirectInput2W, riid ) ||
+	     IsEqualGUID( &IID_IDirectInput7A, riid ) ||
+	     IsEqualGUID( &IID_IDirectInput7W, riid ) ) {
+		return create_directinput_instance(riid, ppobj, NULL);
+	}
+
+	FIXME("(%p,%p,%s,%p) Interface not found!\n",This,pOuter,debugstr_guid(riid),ppobj);	
+	return E_NOINTERFACE;
+}
+
+static HRESULT WINAPI DICF_LockServer(LPCLASSFACTORY iface,BOOL dolock) {
+	IClassFactoryImpl *This = impl_from_IClassFactory(iface);
+	FIXME("(%p)->(%d),stub!\n",This,dolock);
+	return S_OK;
+}
+
+static const IClassFactoryVtbl DICF_Vtbl = {
+	DICF_QueryInterface,
+	DICF_AddRef,
+	DICF_Release,
+	DICF_CreateInstance,
+	DICF_LockServer
+};
+static IClassFactoryImpl DINPUT_CF = {{&DICF_Vtbl}, 1 };
+
+/***********************************************************************
+ *		DllCanUnloadNow (DINPUT.@)
+ */
+HRESULT WINAPI DllCanUnloadNow(void)
+{
+    return S_FALSE;
+}
+
+/***********************************************************************
+ *		DllGetClassObject (DINPUT.@)
+ */
+HRESULT WINAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
+{
+    TRACE("(%s,%s,%p)\n", debugstr_guid(rclsid), debugstr_guid(riid), ppv);
+    if ( IsEqualCLSID( &IID_IClassFactory, riid ) ) {
+        *ppv = &DINPUT_CF;
+	IClassFactory_AddRef((IClassFactory*)*ppv);
+    return S_OK;
+    }
+
+    FIXME("(%s,%s,%p): no interface found.\n", debugstr_guid(rclsid), debugstr_guid(riid), ppv);
+    return CLASS_E_CLASSNOTAVAILABLE;
+}
+
+/***********************************************************************
+ *		DllRegisterServer (DINPUT.@)
+ */
+HRESULT WINAPI DllRegisterServer(void)
+{
+    return __wine_register_resources( DINPUT_instance );
+}
+
+/***********************************************************************
+ *		DllUnregisterServer (DINPUT.@)
+ */
+HRESULT WINAPI DllUnregisterServer(void)
+{
+    return __wine_unregister_resources( DINPUT_instance );
+}
+
+/******************************************************************************
+ *	DInput hook thread
+ */
+
+static LRESULT CALLBACK LL_hook_proc( int code, WPARAM wparam, LPARAM lparam )
+{
+    IDirectInputImpl *dinput;
+    int skip = 0;
+
+    if (code != HC_ACTION) return CallNextHookEx( 0, code, wparam, lparam );
+
+    EnterCriticalSection( &dinput_hook_crit );
+    LIST_FOR_EACH_ENTRY( dinput, &direct_input_list, IDirectInputImpl, entry )
+    {
+        IDirectInputDeviceImpl *dev;
+
+        EnterCriticalSection( &dinput->crit );
+        LIST_FOR_EACH_ENTRY( dev, &dinput->devices_list, IDirectInputDeviceImpl, entry )
+            if (dev->acquired && dev->event_proc)
+            {
+                TRACE("calling %p->%p (%lx %lx)\n", dev, dev->event_proc, wparam, lparam);
+                skip |= dev->event_proc( &dev->IDirectInputDevice8A_iface, wparam, lparam );
+            }
+        LeaveCriticalSection( &dinput->crit );
+    }
+    LeaveCriticalSection( &dinput_hook_crit );
+
+    return skip ? 1 : CallNextHookEx( 0, code, wparam, lparam );
+}
+
+static LRESULT CALLBACK callwndproc_proc( int code, WPARAM wparam, LPARAM lparam )
+{
+    CWPSTRUCT *msg = (CWPSTRUCT *)lparam;
+    IDirectInputImpl *dinput;
+    HWND foreground;
+
+    if (code != HC_ACTION || (msg->message != WM_KILLFOCUS &&
+        msg->message != WM_ACTIVATEAPP && msg->message != WM_ACTIVATE))
+        return CallNextHookEx( 0, code, wparam, lparam );
+
+    foreground = GetForegroundWindow();
+
+    EnterCriticalSection( &dinput_hook_crit );
+
+    LIST_FOR_EACH_ENTRY( dinput, &direct_input_list, IDirectInputImpl, entry )
+    {
+        IDirectInputDeviceImpl *dev;
+
+        EnterCriticalSection( &dinput->crit );
+        LIST_FOR_EACH_ENTRY( dev, &dinput->devices_list, IDirectInputDeviceImpl, entry )
+        {
+            if (!dev->acquired) continue;
+
+            if (msg->hwnd == dev->win && msg->hwnd != foreground)
+            {
+                TRACE( "%p window is not foreground - unacquiring %p\n", dev->win, dev );
+                IDirectInputDevice_Unacquire( &dev->IDirectInputDevice8A_iface );
+            }
+        }
+        LeaveCriticalSection( &dinput->crit );
+    }
+    LeaveCriticalSection( &dinput_hook_crit );
+
+    return CallNextHookEx( 0, code, wparam, lparam );
+}
+
+static DWORD WINAPI hook_thread_proc(void *param)
+{
+    static HHOOK kbd_hook, mouse_hook;
+    MSG msg;
+
+    TRACE("param=%p, hook_thread_event=%p\n", param, hook_thread_event);
+
+    /* Force creation of the message queue */
+    PeekMessageW( &msg, 0, 0, 0, PM_NOREMOVE );
+    SetEvent(param);
+    TRACE("after SetEvent\n");
+
+    while (GetMessageW( &msg, 0, 0, 0 ))
+    {
+        UINT kbd_cnt = 0, mice_cnt = 0;
+
+        if (msg.message == WM_USER+0x10)
+        {
+            IDirectInputImpl *dinput;
+
+            TRACE( "Processing hook change notification lp:%ld\n", msg.lParam );
+
+            if (!msg.wParam && !msg.lParam)
+            {
+                if (kbd_hook) UnhookWindowsHookEx( kbd_hook );
+                if (mouse_hook) UnhookWindowsHookEx( mouse_hook );
+                kbd_hook = mouse_hook = NULL;
+                break;
+            }
+
+            EnterCriticalSection( &dinput_hook_crit );
+
+            /* Count acquired keyboards and mice*/
+            LIST_FOR_EACH_ENTRY( dinput, &direct_input_list, IDirectInputImpl, entry )
+            {
+                IDirectInputDeviceImpl *dev;
+
+                EnterCriticalSection( &dinput->crit );
+                LIST_FOR_EACH_ENTRY( dev, &dinput->devices_list, IDirectInputDeviceImpl, entry )
+                {
+                    if (!dev->acquired || !dev->event_proc) continue;
+
+                    if (IsEqualGUID( &dev->guid, &GUID_SysKeyboard ) ||
+                        IsEqualGUID( &dev->guid, &DInput_Wine_Keyboard_GUID ))
+                        kbd_cnt++;
+                    else
+                        if (IsEqualGUID( &dev->guid, &GUID_SysMouse ) ||
+                            IsEqualGUID( &dev->guid, &DInput_Wine_Mouse_GUID ))
+                            mice_cnt++;
+                }
+                LeaveCriticalSection( &dinput->crit );
+            }
+            LeaveCriticalSection( &dinput_hook_crit );
+
+            if (kbd_cnt && !kbd_hook)
+                kbd_hook = SetWindowsHookExW( WH_KEYBOARD_LL, LL_hook_proc, DINPUT_instance, 0 );
+            else if (!kbd_cnt && kbd_hook)
+            {
+                UnhookWindowsHookEx( kbd_hook );
+                kbd_hook = NULL;
+            }
+
+            if (mice_cnt && !mouse_hook)
+                mouse_hook = SetWindowsHookExW( WH_MOUSE_LL, LL_hook_proc, DINPUT_instance, 0 );
+            else if (!mice_cnt && mouse_hook)
+            {
+                UnhookWindowsHookEx( mouse_hook );
+                mouse_hook = NULL;
+            }
+        }
+        TranslateMessage(&msg);
+        DispatchMessageW(&msg);
+    }
+
+    return 0;
+}
+
+static DWORD hook_thread_id;
+static HANDLE hook_thread_event;
+
+static CRITICAL_SECTION_DEBUG dinput_critsect_debug =
+{
+    0, 0, &dinput_hook_crit,
+    { &dinput_critsect_debug.ProcessLocksList, &dinput_critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": dinput_hook_crit") }
+};
+static CRITICAL_SECTION dinput_hook_crit = { &dinput_critsect_debug, -1, 0, 0, 0, 0 };
+
+static BOOL check_hook_thread(void)
+{
+    static HANDLE hook_thread;
+
+    EnterCriticalSection(&dinput_hook_crit);
+
+    TRACE("IDirectInputs left: %d\n", list_count(&direct_input_list));
+    if (!list_empty(&direct_input_list) && !hook_thread)
+    {
+        hook_thread_event = CreateEventW(NULL, FALSE, FALSE, NULL);
+        hook_thread = CreateThread(NULL, 0, hook_thread_proc, hook_thread_event, 0, &hook_thread_id);
+        LeaveCriticalSection(&dinput_hook_crit);
+    }
+    else if (list_empty(&direct_input_list) && hook_thread)
+    {
+        DWORD tid = hook_thread_id;
+
+        if (hook_thread_event) /* if thread is not started yet */
+        {
+            WaitForSingleObject(hook_thread_event, INFINITE);
+            CloseHandle(hook_thread_event);
+            hook_thread_event = NULL;
+        }
+
+        hook_thread_id = 0;
+        PostThreadMessageW(tid, WM_USER+0x10, 0, 0);
+        LeaveCriticalSection(&dinput_hook_crit);
+
+        /* wait for hook thread to exit */
+        WaitForSingleObject(hook_thread, INFINITE);
+        CloseHandle(hook_thread);
+        hook_thread = NULL;
+    }
+    else
+        LeaveCriticalSection(&dinput_hook_crit);
+
+    return hook_thread_id != 0;
+}
+
+void check_dinput_hooks(LPDIRECTINPUTDEVICE8W iface, BOOL acquired)
+{
+    static HHOOK callwndproc_hook;
+    static ULONG foreground_cnt;
+    IDirectInputDeviceImpl *dev = impl_from_IDirectInputDevice8W(iface);
+
+    EnterCriticalSection(&dinput_hook_crit);
+
+    if (dev->dwCoopLevel & DISCL_FOREGROUND)
+    {
+        if (acquired)
+            foreground_cnt++;
+        else
+            foreground_cnt--;
+    }
+
+    if (foreground_cnt && !callwndproc_hook)
+        callwndproc_hook = SetWindowsHookExW( WH_CALLWNDPROC, callwndproc_proc,
+                                              DINPUT_instance, GetCurrentThreadId() );
+    else if (!foreground_cnt && callwndproc_hook)
+    {
+        UnhookWindowsHookEx( callwndproc_hook );
+        callwndproc_hook = NULL;
+    }
+
+    if (hook_thread_event) /* if thread is not started yet */
+    {
+        WaitForSingleObject(hook_thread_event, INFINITE);
+        CloseHandle(hook_thread_event);
+        hook_thread_event = NULL;
+    }
+
+    PostThreadMessageW( hook_thread_id, WM_USER+0x10, 1, 0 );
+
+    LeaveCriticalSection(&dinput_hook_crit);
+}
+
+void check_dinput_events(void)
+{
+    /* Windows does not do that, but our current implementation of winex11
+     * requires periodic event polling to forward events to the wineserver.
+     *
+     * We have to call this function from multiple places, because:
+     * - some games do not explicitly poll for mouse events
+     *   (for example Culpa Innata)
+     * - some games only poll the device, and neither keyboard nor mouse
+     *   (for example Civilization: Call to Power 2)
+     */
+    MsgWaitForMultipleObjectsEx(0, NULL, 0, QS_ALLINPUT, 0);
+}
+
+BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, LPVOID reserved)
+{
+    switch(reason)
+    {
+      case DLL_PROCESS_ATTACH:
+        DisableThreadLibraryCalls(inst);
+        DINPUT_instance = inst;
+        break;
+      case DLL_PROCESS_DETACH:
+        if (reserved) break;
+        DeleteCriticalSection(&dinput_hook_crit);
+        break;
+    }
+    return TRUE;
+}
diff --git a/dlls/dinput8/dinput_private.h b/dlls/dinput8/dinput_private.h
new file mode 100644
index 0000000..3ed68f2
--- /dev/null
+++ b/dlls/dinput8/dinput_private.h
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2000 Lionel Ulmer
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_DLLS_DINPUT_DINPUT_PRIVATE_H
+#define __WINE_DLLS_DINPUT_DINPUT_PRIVATE_H
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "dinput.h"
+#include "dinputd.h"
+#include "wine/list.h"
+
+/* Implementation specification */
+typedef struct IDirectInputImpl IDirectInputImpl;
+struct IDirectInputImpl
+{
+    IDirectInput7A              IDirectInput7A_iface;
+    IDirectInput7W              IDirectInput7W_iface;
+    IDirectInput8A              IDirectInput8A_iface;
+    IDirectInput8W              IDirectInput8W_iface;
+    IDirectInputJoyConfig8      IDirectInputJoyConfig8_iface;
+
+    LONG                        ref;
+
+    BOOL                        initialized;
+    CRITICAL_SECTION            crit;
+    struct list                 entry;          /* entry into list of all IDirectInputs */
+
+    DWORD                       evsequence;     /* unique sequence number for events */
+    DWORD                       dwVersion;      /* direct input version number */
+    struct list                 devices_list;   /* list of all created dinput devices */
+    struct list                 device_players; /* device instance guid to player name */
+};
+
+/* Function called by all devices that Wine supports */
+struct dinput_device {
+    const char *name;
+    HRESULT (*enum_deviceA)(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEA lpddi, DWORD version, int id);
+    HRESULT (*enum_deviceW)(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEW lpddi, DWORD version, int id);
+    HRESULT (*create_device)(IDirectInputImpl *dinput, REFGUID rguid, REFIID riid, LPVOID *pdev, int unicode);
+};
+
+struct DevicePlayer {
+    GUID instance_guid;
+    WCHAR username[MAX_PATH];
+    struct list entry;
+};
+
+extern const struct dinput_device mouse_device DECLSPEC_HIDDEN;
+extern const struct dinput_device keyboard_device DECLSPEC_HIDDEN;
+extern const struct dinput_device joystick_linux_device DECLSPEC_HIDDEN;
+extern const struct dinput_device joystick_linuxinput_device DECLSPEC_HIDDEN;
+extern const struct dinput_device joystick_osx_device DECLSPEC_HIDDEN;
+
+extern void check_dinput_hooks(LPDIRECTINPUTDEVICE8W, BOOL) DECLSPEC_HIDDEN;
+extern void check_dinput_events(void) DECLSPEC_HIDDEN;
+typedef int (*DI_EVENT_PROC)(LPDIRECTINPUTDEVICE8A, WPARAM, LPARAM);
+
+extern void _copy_diactionformatAtoW(LPDIACTIONFORMATW, LPDIACTIONFORMATA) DECLSPEC_HIDDEN;
+extern void _copy_diactionformatWtoA(LPDIACTIONFORMATA, LPDIACTIONFORMATW) DECLSPEC_HIDDEN;
+
+extern HRESULT _configure_devices(IDirectInput8W *iface, LPDICONFIGUREDEVICESCALLBACK lpdiCallback, LPDICONFIGUREDEVICESPARAMSW lpdiCDParams, DWORD dwFlags, LPVOID pvRefData) DECLSPEC_HIDDEN;
+
+extern WCHAR* get_mapping_path(const WCHAR *device, const WCHAR *username) DECLSPEC_HIDDEN;
+
+#define IS_DIPROP(x)    (((ULONG_PTR)(x) >> 16) == 0)
+
+#define DIKEYBOARD_MASK    0x81000000
+#define DIMOUSE_MASK       0x82000000
+#define DIGENRE_ANY        0xFF000000
+
+#endif /* __WINE_DLLS_DINPUT_DINPUT_PRIVATE_H */
diff --git a/dlls/dinput8/effect_linuxinput.c b/dlls/dinput8/effect_linuxinput.c
new file mode 100644
index 0000000..7477bc7
--- /dev/null
+++ b/dlls/dinput8/effect_linuxinput.c
@@ -0,0 +1,934 @@
+/*              DirectInput Linux Event Device Effect
+ *
+ * Copyright 2005 Daniel Remenak
+ *
+ * Thanks to Google's Summer of Code Program (2005)
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#ifdef HAVE_STRUCT_FF_EFFECT_DIRECTION
+
+#include <stdarg.h>
+#include <string.h>
+#ifdef HAVE_LINUX_INPUT_H
+#  include <linux/input.h>
+#  undef SW_MAX
+#endif
+#include <limits.h>
+#include <errno.h>
+#ifdef HAVE_UNISTD_H
+#  include <unistd.h>
+#endif
+#include <math.h>
+#include "wine/debug.h"
+#include "wine/unicode.h"
+#include "windef.h"
+#include "winbase.h"
+#include "winerror.h"
+#include "dinput.h"
+
+#include "device_private.h"
+#include "joystick_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dinput);
+
+static const IDirectInputEffectVtbl LinuxInputEffectVtbl;
+typedef struct LinuxInputEffectImpl LinuxInputEffectImpl;
+struct LinuxInputEffectImpl
+{
+    IDirectInputEffect  IDirectInputEffect_iface;
+    LONG                ref;
+    GUID                guid;
+
+    struct ff_effect    effect; /* Effect data */
+    int                 gain;   /* Effect gain */
+    BOOL                first_axis_is_x;
+    int*                fd;     /* Parent device */
+    struct list        *entry;  /* Entry into the parent's list of effects */
+};
+
+static inline LinuxInputEffectImpl *impl_from_IDirectInputEffect(IDirectInputEffect *iface)
+{
+    return CONTAINING_RECORD(iface, LinuxInputEffectImpl, IDirectInputEffect_iface);
+}
+
+static double ff_effect_direction_to_rad(unsigned int dir)
+{
+    return (dir & 0xffff) * M_PI / 0x8000;
+}
+
+static void ff_dump_effect(struct ff_effect *effect)
+{
+    const char *type = "(Unknown)", *length = "INFINITE";
+    struct ff_envelope *env = NULL;
+    double angle;
+#define FE(x) case x: type = #x; break
+    switch (effect->type)
+    {
+        FE(FF_RUMBLE);
+        FE(FF_PERIODIC);
+        FE(FF_CONSTANT);
+        FE(FF_SPRING);
+        FE(FF_FRICTION);
+        FE(FF_DAMPER);
+        FE(FF_INERTIA);
+        FE(FF_RAMP);
+    }
+#undef FE
+
+    /* rotate so 0 points right */
+    angle = 360 - ff_effect_direction_to_rad(effect->direction + 0xc000) * 180 / M_PI;
+
+    if (effect->replay.length)
+      length = wine_dbg_sprintf("%u ms", effect->replay.length);
+
+    TRACE("type 0x%x %s, id %d, direction 0x%x (source angle %.2f), time length %s, start delay %u ms\n",
+          effect->type, type, effect->id, effect->direction, angle, length, effect->replay.delay);
+    if (effect->trigger.button || effect->trigger.interval)
+        TRACE(" -> trigger button %u, re-trigger interval %u ms\n",
+              effect->trigger.button, effect->trigger.interval);
+
+    if (effect->type == FF_PERIODIC)
+    {
+        struct ff_periodic_effect *per = &effect->u.periodic;
+        const char *wave = "(Unknown)";
+#define FE(x) case x: wave = #x; break
+        switch (per->waveform)
+        {
+            FE(FF_SQUARE);
+            FE(FF_TRIANGLE);
+            FE(FF_SINE);
+            FE(FF_SAW_UP);
+            FE(FF_SAW_DOWN);
+            FE(FF_CUSTOM);
+        }
+#undef FE
+        angle = ff_effect_direction_to_rad(per->phase) * 180 / M_PI;
+        TRACE(" -> waveform 0x%x %s, period %u ms, magnitude %d, offset %d, phase 0x%x (angle %.2f), custom len %d\n",
+              per->waveform, wave, per->period, per->magnitude, per->offset, per->phase, angle, per->custom_len);
+        env = &per->envelope;
+    }
+    else if (effect->type == FF_CONSTANT)
+    {
+        struct ff_constant_effect *cons = &effect->u.constant;
+        TRACE(" -> level %d\n", cons->level);
+        env = &cons->envelope;
+    }
+    else if (effect->type == FF_RAMP)
+    {
+        struct ff_ramp_effect *ramp = &effect->u.ramp;
+        TRACE(" -> start/end level %d/%d\n", ramp->start_level, ramp->end_level);
+        env = &ramp->envelope;
+    }
+    else if (effect->type == FF_RUMBLE)
+    {
+        struct ff_rumble_effect *rumble = &effect->u.rumble;
+        TRACE(" -> strong/weak magnitude %u/%u\n", rumble->strong_magnitude, rumble->weak_magnitude);
+    }
+    else if (effect->type == FF_SPRING || effect->type == FF_FRICTION ||
+             effect->type == FF_DAMPER || effect->type == FF_INERTIA)
+    {
+        struct ff_condition_effect *cond = effect->u.condition;
+        int i;
+        for (i = 0; i < 2; i++)
+        {
+            /* format numbers here to make them align correctly */
+            TRACE(" -> [%d] right/left saturation %5u/%5u, right/left coefficient %5d/%5d,"
+                  " deadband %5u, center %5d\n", i, cond[i].right_saturation, cond[i].left_saturation,
+                  cond[i].right_coeff, cond[i].left_coeff, cond[i].deadband, cond[i].center);
+        }
+    }
+
+    if (env)
+        TRACE(" -> envelope attack length(ms)/level %u/%u, fade length(ms)/level %u/%u\n",
+              env->attack_length, env->attack_level, env->fade_length, env->fade_level);
+}
+
+/******************************************************************************
+ *      LinuxInputEffectImpl 
+ */
+
+static ULONG WINAPI LinuxInputEffectImpl_AddRef(
+	LPDIRECTINPUTEFFECT iface)
+{
+    LinuxInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+    return InterlockedIncrement(&(This->ref));
+}
+
+static HRESULT WINAPI LinuxInputEffectImpl_Download(
+	LPDIRECTINPUTEFFECT iface)
+{
+    LinuxInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+    int ret, old_effect_id;
+
+    TRACE("(this=%p)\n", This);
+    ff_dump_effect(&This->effect);
+
+    old_effect_id = This->effect.id;
+    if (ioctl(*(This->fd), EVIOCSFF, &This->effect) != -1)
+        return DI_OK;
+
+    /* Linux kernel < 3.14 has a bug that incorrectly assigns an effect ID even
+     * on error, restore it here if that is the case. */
+    This->effect.id = old_effect_id;
+
+    switch (errno)
+    {
+        case EINVAL:
+            ret = DIERR_INVALIDPARAM;
+            break;
+        case ENOSPC:
+            ret = DIERR_DEVICEFULL;
+            break;
+        case ENOMEM:
+            ret = DIERR_OUTOFMEMORY;
+            break;
+        default:
+            ret = DIERR_INPUTLOST;
+            break;
+    }
+    TRACE("Could not upload effect to fd %d, errno %d \"%s\", returning 0x%x.\n",
+          *This->fd, errno, strerror(errno), ret);
+    return ret;
+}
+
+static HRESULT WINAPI LinuxInputEffectImpl_Escape(
+	LPDIRECTINPUTEFFECT iface,
+        LPDIEFFESCAPE pesc)
+{
+    WARN("(this=%p,%p): invalid: no hardware-specific escape codes in this" 
+         " driver!\n", iface, pesc);
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI LinuxInputEffectImpl_GetEffectGuid(
+        LPDIRECTINPUTEFFECT iface,
+	LPGUID pguid)
+{
+    LinuxInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+
+    TRACE("(this=%p,%p)\n", This, pguid);
+
+    *pguid = This->guid;
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI LinuxInputEffectImpl_GetEffectStatus(
+        LPDIRECTINPUTEFFECT iface,
+	LPDWORD pdwFlags)
+{
+    LinuxInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+
+    TRACE("(this=%p,%p)\n", This, pdwFlags);
+
+    if (!pdwFlags)
+        return E_POINTER;
+
+    if (This->effect.id == -1)
+        return DIERR_NOTDOWNLOADED;
+
+    /* linux sends the effect status through an event.
+     * that event is trapped by our parent joystick driver
+     * and there is no clean way to pass it back to us. */
+    FIXME("Not enough information to provide a status.\n");
+
+    (*pdwFlags) = 0;
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI LinuxInputEffectImpl_GetParameters(
+	LPDIRECTINPUTEFFECT iface,
+	LPDIEFFECT peff,
+	DWORD dwFlags)
+{
+    HRESULT diErr = DI_OK;
+    LinuxInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("(this=%p,%p,%d)\n", This, peff, dwFlags);
+
+    /* Major conversion factors are:
+     * times: millisecond (linux) -> microsecond (windows) (x * 1000)
+     * forces: scale 0x7FFF (linux) -> scale 10000 (windows) approx ((x / 33) * 10)
+     * angles: scale 0x7FFF (linux) -> scale 35999 (windows) approx ((x / 33) * 36)
+     * angle bases: 0 -> -y (down) (linux) -> 0 -> +x (right) (windows)
+     */
+
+    if (dwFlags & DIEP_AXES) {
+	if (peff->cAxes < 2 /* linuxinput effects always use 2 axes, x and y */)
+	    diErr = DIERR_MOREDATA;
+	peff->cAxes = 2; 
+	if (diErr)
+	    return diErr;
+	else {
+	    peff->rgdwAxes[0] = DIJOFS_X;
+	    peff->rgdwAxes[1] = DIJOFS_Y;
+	}
+    }
+ 
+    if (dwFlags & DIEP_DIRECTION) {
+        if (peff->cAxes < 2)
+            diErr = DIERR_MOREDATA;
+        peff->cAxes = 2; 
+        if (diErr)
+            return diErr;
+        else {
+	    if (peff->dwFlags & DIEFF_CARTESIAN) {
+		/* rotate so 0 points right */
+		double angle = ff_effect_direction_to_rad(This->effect.direction + 0xc000);
+		peff->rglDirection[0] = sin(angle) * 1000;
+		peff->rglDirection[1] = -cos(angle) * 1000;
+	    } else {
+		/* Polar and spherical coordinates are the same for two or less
+		 * axes.
+		 * Note that we also use this case if NO flags are marked.
+		 * According to MSDN, we should return the direction in the
+		 * format that it was specified in, if no flags are marked.
+		 */
+		peff->rglDirection[0] = (This->effect.direction / 33) * 36 + 9000;
+		if (peff->rglDirection[0] > 35999)
+		    peff->rglDirection[0] -= 35999;
+	    }
+	}
+    }
+
+    if (dwFlags & DIEP_DURATION)
+    {
+        if (!This->effect.replay.length) /* infinite for the linux driver */
+            peff->dwDuration = INFINITE;
+        else
+            peff->dwDuration = (DWORD)This->effect.replay.length * 1000;
+    }
+
+    if (dwFlags & DIEP_ENVELOPE) {
+	struct ff_envelope* env;
+	if (This->effect.type == FF_CONSTANT) env = &This->effect.u.constant.envelope;
+	else if (This->effect.type == FF_PERIODIC) env = &This->effect.u.periodic.envelope;
+	else if (This->effect.type == FF_RAMP) env = &This->effect.u.ramp.envelope;
+	else env = NULL;
+	if (env == NULL) {
+	    peff->lpEnvelope = NULL;
+	} else if (peff->lpEnvelope == NULL) {
+	    return DIERR_INVALIDPARAM;
+	} else { 
+	    peff->lpEnvelope->dwAttackLevel = (env->attack_level / 33) * 10;
+	    peff->lpEnvelope->dwAttackTime = env->attack_length * 1000;
+	    peff->lpEnvelope->dwFadeLevel = (env->fade_level / 33) * 10;
+	    peff->lpEnvelope->dwFadeTime = env->fade_length * 1000;
+	}
+    }
+
+    if (dwFlags & DIEP_GAIN) {
+	peff->dwGain = This->gain * 10000 / 0xFFFF;
+    }
+
+    if (dwFlags & DIEP_SAMPLEPERIOD) {
+	/* the linux input ff driver has no support for setting
+	 * the playback sample period.  0 means default. */
+    	peff->dwSamplePeriod = 0;
+    }
+
+    if ((dwFlags & DIEP_STARTDELAY) && peff->dwSize > sizeof(DIEFFECT_DX5))
+        peff->dwStartDelay = This->effect.replay.delay * 1000;
+
+    if (dwFlags & DIEP_TRIGGERBUTTON) {
+	FIXME("LinuxInput button mapping needs redoing; for now, assuming we're using an actual joystick.\n");
+	peff->dwTriggerButton = DIJOFS_BUTTON(This->effect.trigger.button - BTN_JOYSTICK);
+    }
+
+    if (dwFlags & DIEP_TRIGGERREPEATINTERVAL) {
+	peff->dwTriggerRepeatInterval = This->effect.trigger.interval * 1000;
+    }
+
+    if (dwFlags & DIEP_TYPESPECIFICPARAMS) {
+	DWORD expectedsize = 0;
+	if (This->effect.type == FF_PERIODIC) {
+	    expectedsize = sizeof(DIPERIODIC);
+	} else if (This->effect.type == FF_CONSTANT) {
+	    expectedsize = sizeof(DICONSTANTFORCE);
+	} else if (This->effect.type == FF_SPRING 
+		|| This->effect.type == FF_FRICTION 
+		|| This->effect.type == FF_INERTIA 
+		|| This->effect.type == FF_DAMPER) {
+	    expectedsize = sizeof(DICONDITION) * 2;
+	} else if (This->effect.type == FF_RAMP) {
+	    expectedsize = sizeof(DIRAMPFORCE);
+	}
+	if (expectedsize > peff->cbTypeSpecificParams)
+	    diErr = DIERR_MOREDATA;
+	peff->cbTypeSpecificParams = expectedsize;
+	if (diErr)
+	    return diErr;
+	else {
+	    if (This->effect.type == FF_PERIODIC) {
+                LPDIPERIODIC tsp = peff->lpvTypeSpecificParams;
+		tsp->dwMagnitude = (This->effect.u.periodic.magnitude / 33) * 10;
+		tsp->lOffset = (This->effect.u.periodic.offset / 33) * 10;
+		tsp->dwPhase = (This->effect.u.periodic.phase / 33) * 36;
+		tsp->dwPeriod = (This->effect.u.periodic.period * 1000);
+	    } else if (This->effect.type == FF_CONSTANT) {
+                LPDICONSTANTFORCE tsp = peff->lpvTypeSpecificParams;
+		tsp->lMagnitude = (This->effect.u.constant.level / 33) * 10;
+	    } else if (This->effect.type == FF_SPRING 
+		    || This->effect.type == FF_FRICTION 
+		    || This->effect.type == FF_INERTIA 
+		    || This->effect.type == FF_DAMPER) {
+                LPDICONDITION tsp = peff->lpvTypeSpecificParams;
+		int i;
+		for (i = 0; i < 2; ++i) {
+		    tsp[i].lOffset = (This->effect.u.condition[i].center / 33) * 10; 
+		    tsp[i].lPositiveCoefficient = (This->effect.u.condition[i].right_coeff / 33) * 10;
+		    tsp[i].lNegativeCoefficient = (This->effect.u.condition[i].left_coeff / 33) * 10; 
+		    tsp[i].dwPositiveSaturation = (This->effect.u.condition[i].right_saturation / 33) * 10;
+		    tsp[i].dwNegativeSaturation = (This->effect.u.condition[i].left_saturation / 33) * 10;
+		    tsp[i].lDeadBand = (This->effect.u.condition[i].deadband / 33) * 10;
+		}
+	    } else if (This->effect.type == FF_RAMP) {
+                LPDIRAMPFORCE tsp = peff->lpvTypeSpecificParams;
+		tsp->lStart = (This->effect.u.ramp.start_level / 33) * 10;
+		tsp->lEnd = (This->effect.u.ramp.end_level / 33) * 10;
+	    }
+	}
+    } 
+
+    return diErr;
+}
+
+static HRESULT WINAPI LinuxInputEffectImpl_Initialize(
+        LPDIRECTINPUTEFFECT iface,
+	HINSTANCE hinst,
+	DWORD dwVersion,
+	REFGUID rguid)
+{
+    FIXME("(this=%p,%p,%d,%s): stub!\n",
+	 iface, hinst, dwVersion, debugstr_guid(rguid));
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI LinuxInputEffectImpl_QueryInterface(
+	LPDIRECTINPUTEFFECT iface,
+	REFIID riid,
+	void **ppvObject)
+{
+    LinuxInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+
+    TRACE("(this=%p,%s,%p)\n", This, debugstr_guid(riid), ppvObject);
+
+    if (IsEqualGUID(&IID_IUnknown, riid) ||
+	IsEqualGUID(&IID_IDirectInputEffect, riid)) {
+	    LinuxInputEffectImpl_AddRef(iface);
+	    *ppvObject = This;
+	    return 0;
+    }
+
+    TRACE("Unsupported interface!\n");
+    return E_FAIL;
+}
+
+static HRESULT WINAPI LinuxInputEffectImpl_Start(
+	LPDIRECTINPUTEFFECT iface,
+	DWORD dwIterations,
+	DWORD dwFlags)
+{
+    struct input_event event;
+    LinuxInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+
+    TRACE("(this=%p,%d,%d)\n", This, dwIterations, dwFlags);
+
+    if (!(dwFlags & DIES_NODOWNLOAD)) {
+	/* Download the effect if necessary */
+	if (This->effect.id == -1) {
+	    HRESULT res = LinuxInputEffectImpl_Download(iface);
+	    if (res != DI_OK)
+		return res;
+	}
+    }
+
+    if (dwFlags & DIES_SOLO) {
+	FIXME("Solo mode requested: should be stopping all effects here!\n");
+    }
+
+    event.type = EV_FF;
+    event.code = This->effect.id;
+    event.value = min( dwIterations, INT_MAX );
+    if (write(*(This->fd), &event, sizeof(event)) == -1) {
+	FIXME("Unable to write event.  Assuming device disconnected.\n");
+	return DIERR_INPUTLOST;
+    }
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI LinuxInputEffectImpl_SetParameters(
+        LPDIRECTINPUTEFFECT iface,
+        LPCDIEFFECT peff,
+        DWORD dwFlags)
+{
+    LinuxInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+    DWORD type = typeFromGUID(&This->guid);
+    HRESULT retval = DI_OK;
+
+    TRACE("(this=%p,%p,%d)\n", This, peff, dwFlags);
+
+    dump_DIEFFECT(peff, &This->guid, dwFlags);
+
+    if ((dwFlags & ~DIEP_NORESTART & ~DIEP_NODOWNLOAD & ~DIEP_START) == 0) {
+	/* set everything */
+	dwFlags = DIEP_AXES | DIEP_DIRECTION | DIEP_DURATION | DIEP_ENVELOPE |
+	    DIEP_GAIN | DIEP_SAMPLEPERIOD | DIEP_STARTDELAY | DIEP_TRIGGERBUTTON |
+	    DIEP_TRIGGERREPEATINTERVAL | DIEP_TYPESPECIFICPARAMS;
+    }
+
+    if (dwFlags & DIEP_AXES) {
+	/* the linux input effect system only supports one or two axes */
+	if (peff->cAxes > 2)
+	    return DIERR_INVALIDPARAM;
+	else if (peff->cAxes < 1)
+	    return DIERR_INCOMPLETEEFFECT;
+	This->first_axis_is_x = peff->rgdwAxes[0] == DIJOFS_X;
+    }
+
+    /* some of this may look funky, but it's 'cause the linux driver and directx have
+     * different opinions about which way direction "0" is.  directx has 0 along the x
+     * axis (left), linux has it along the y axis (down). */ 
+    if (dwFlags & DIEP_DIRECTION) {
+	if (peff->cAxes == 1) {
+	    if (peff->dwFlags & DIEFF_CARTESIAN) {
+		if (dwFlags & DIEP_AXES) {
+		    if (peff->rgdwAxes[0] == DIJOFS_X && peff->rglDirection[0] >= 0)
+			This->effect.direction = 0x4000;
+		    else if (peff->rgdwAxes[0] == DIJOFS_X && peff->rglDirection[0] < 0)
+			This->effect.direction = 0xC000;
+		    else if (peff->rgdwAxes[0] == DIJOFS_Y && peff->rglDirection[0] >= 0)
+			This->effect.direction = 0;
+		    else if (peff->rgdwAxes[0] == DIJOFS_Y && peff->rglDirection[0] < 0)
+			This->effect.direction = 0x8000;
+		}
+	    } else {
+		/* one-axis effects must use cartesian coords */
+		return DIERR_INVALIDPARAM;
+	    }
+        }
+        /* two axes */
+        else
+        {
+            if (peff->dwFlags & DIEFF_CARTESIAN)
+            {
+                LONG x, y;
+                if (This->first_axis_is_x)
+                {
+                    x = peff->rglDirection[0];
+                    y = peff->rglDirection[1];
+                }
+                else
+                {
+                    x = peff->rglDirection[1];
+                    y = peff->rglDirection[0];
+                }
+                This->effect.direction = (unsigned int)((M_PI / 2 + atan2(y, x)) * 0x8000 / M_PI);
+            }
+            else
+            {
+                /* Polar and spherical are the same for 2 axes */
+                /* Precision is important here, so we do double math with exact constants */
+                This->effect.direction = (unsigned int)(((double)peff->rglDirection[0] / 18000) * 0x8000);
+            }
+        }
+    }
+
+    if (dwFlags & DIEP_DURATION)
+    {
+        if (peff->dwDuration == INFINITE)
+            This->effect.replay.length = 0; /* infinite for the linux driver */
+        else if(peff->dwDuration > 1000)
+            This->effect.replay.length = peff->dwDuration / 1000;
+        else
+            This->effect.replay.length = 1;
+    }
+
+    if (dwFlags & DIEP_ENVELOPE)
+    {
+        struct ff_envelope* env;
+        if (This->effect.type == FF_CONSTANT)
+            env = &This->effect.u.constant.envelope;
+        else if (This->effect.type == FF_PERIODIC)
+            env = &This->effect.u.periodic.envelope;
+        else if (This->effect.type == FF_RAMP)
+            env = &This->effect.u.ramp.envelope;
+        else
+            env = NULL;
+
+        /* copy the envelope if it is present and the linux effect supports it */
+        if (peff->lpEnvelope && env)
+        {
+            env->attack_length = peff->lpEnvelope->dwAttackTime / 1000;
+            env->attack_level = (peff->lpEnvelope->dwAttackLevel / 10) * 32;
+            env->fade_length = peff->lpEnvelope->dwFadeTime / 1000;
+            env->fade_level = (peff->lpEnvelope->dwFadeLevel / 10) * 32;
+        }
+        /* if the dinput envelope is NULL we will clear the linux envelope */
+        else if (env)
+        {
+            env->attack_length = 0;
+            env->attack_level = 0;
+            env->fade_length = 0;
+            env->fade_level = 0;
+        }
+        else if(peff->lpEnvelope)
+        {
+            if(peff->lpEnvelope->dwAttackTime || peff->lpEnvelope->dwAttackLevel ||
+               peff->lpEnvelope->dwFadeTime || peff->lpEnvelope->dwFadeLevel)
+                WARN("Ignoring dinput envelope not supported in the linux effect\n");
+        }
+    }
+
+    /* Gain and Sample Period settings are not supported by the linux
+     * event system */
+    if (dwFlags & DIEP_GAIN) {
+	This->gain = 0xFFFF * peff->dwGain / 10000;
+	TRACE("Effect gain requested but no effect gain functionality present.\n");
+    }
+
+    if (dwFlags & DIEP_SAMPLEPERIOD)
+	TRACE("Sample period requested but no sample period functionality present.\n");
+
+    if (dwFlags & DIEP_STARTDELAY)
+    if ((dwFlags & DIEP_STARTDELAY) && peff->dwSize > sizeof(DIEFFECT_DX5))
+        This->effect.replay.delay = peff->dwStartDelay / 1000;
+
+    if (dwFlags & DIEP_TRIGGERBUTTON) {
+	if (peff->dwTriggerButton != -1) {
+	    FIXME("Linuxinput button mapping needs redoing, assuming we're using a joystick.\n");
+	    FIXME("Trigger button translation not yet implemented!\n");
+	}
+	This->effect.trigger.button = 0;
+    }
+
+    if (dwFlags & DIEP_TRIGGERREPEATINTERVAL)
+	This->effect.trigger.interval = peff->dwTriggerRepeatInterval / 1000;
+
+    if (dwFlags & DIEP_TYPESPECIFICPARAMS)
+    {
+        if (!(peff->lpvTypeSpecificParams))
+            return DIERR_INCOMPLETEEFFECT;
+
+        if (type == DIEFT_PERIODIC)
+        {
+            DIPERIODIC *tsp;
+            if (peff->cbTypeSpecificParams != sizeof(DIPERIODIC))
+                return DIERR_INVALIDPARAM;
+            tsp = peff->lpvTypeSpecificParams;
+
+            This->effect.u.periodic.magnitude = (tsp->dwMagnitude / 10) * 32;
+            This->effect.u.periodic.offset = (tsp->lOffset / 10) * 32;
+            /* phase ranges from 0 - 35999 in dinput and 0 - 65535 on Linux */
+            This->effect.u.periodic.phase = (tsp->dwPhase / 36) * 65;
+            /* dinput uses microseconds, Linux uses milliseconds */
+            if (tsp->dwPeriod <= 1000)
+                This->effect.u.periodic.period = 1;
+            else
+                This->effect.u.periodic.period = tsp->dwPeriod / 1000;
+        }
+        else if (type == DIEFT_CONSTANTFORCE)
+        {
+            LPCDICONSTANTFORCE tsp;
+            if (peff->cbTypeSpecificParams != sizeof(DICONSTANTFORCE))
+                return DIERR_INVALIDPARAM;
+            tsp = peff->lpvTypeSpecificParams;
+	    This->effect.u.constant.level = (max(min(tsp->lMagnitude, 10000), -10000) / 10) * 32;
+	} else if (type == DIEFT_RAMPFORCE) {
+            LPCDIRAMPFORCE tsp;
+            if (peff->cbTypeSpecificParams != sizeof(DIRAMPFORCE))
+                return DIERR_INVALIDPARAM;
+            tsp = peff->lpvTypeSpecificParams;
+	    This->effect.u.ramp.start_level = (tsp->lStart / 10) * 32;
+	    This->effect.u.ramp.end_level = (tsp->lEnd / 10) * 32;
+        }
+        else if (type == DIEFT_CONDITION)
+        {
+            DICONDITION *tsp = peff->lpvTypeSpecificParams;
+            struct ff_condition_effect *cond = This->effect.u.condition;
+            int i, j, sources;
+            double factor[2];
+
+            if (peff->cbTypeSpecificParams == sizeof(DICONDITION))
+            {
+                /* One condition block.  This needs to be rotated to direction,
+                 * and expanded to separate x and y conditions. Ensures 0 points right */
+                double angle = ff_effect_direction_to_rad(This->effect.direction + 0xc000);
+                factor[0] = sin(angle);
+                factor[1] = -cos(angle);
+                sources = 1;
+            }
+            else if (peff->cbTypeSpecificParams == 2 * sizeof(DICONDITION))
+            {
+                /* Direct parameter copy without changes */
+                factor[0] = factor[1] = 1;
+                sources = 2;
+            }
+            else
+                return DIERR_INVALIDPARAM;
+
+            for (i = j = 0; i < 2; ++i)
+            {
+                cond[i].center = (int)(factor[i] * (tsp[j].lOffset / 10) * 32);
+                cond[i].right_coeff = (int)(factor[i] * (tsp[j].lPositiveCoefficient / 10) * 32);
+                cond[i].left_coeff = (int)(factor[i] * (tsp[j].lNegativeCoefficient / 10) * 32);
+                cond[i].right_saturation = (int)(factor[i] * (tsp[j].dwPositiveSaturation / 10) * 65);
+                cond[i].left_saturation = (int)(factor[i] * (tsp[j].dwNegativeSaturation / 10) * 65);
+                cond[i].deadband = (int)(factor[i] * (tsp[j].lDeadBand / 10) * 32);
+                if (sources == 2)
+                    j++;
+            }
+        }
+        else
+        {
+            FIXME("Custom force types are not supported\n");
+            return DIERR_INVALIDPARAM;
+        }
+    }
+
+    if (!(dwFlags & DIEP_NODOWNLOAD))
+	retval = LinuxInputEffectImpl_Download(iface);
+    if (retval != DI_OK)
+	return DI_DOWNLOADSKIPPED;
+
+    if (dwFlags & DIEP_NORESTART)
+	TRACE("DIEP_NORESTART: not handled (we have no control of that).\n");
+
+    if (dwFlags & DIEP_START)
+	retval = LinuxInputEffectImpl_Start(iface, 1, 0);
+    if (retval != DI_OK)
+	return retval;
+ 
+    return DI_OK;
+}   
+
+static HRESULT WINAPI LinuxInputEffectImpl_Stop(
+        LPDIRECTINPUTEFFECT iface)
+{
+    struct input_event event;
+    LinuxInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+
+    TRACE("(this=%p)\n", This);
+
+    event.type = EV_FF;
+    event.code = This->effect.id;
+    event.value = 0;
+    /* we don't care about the success or failure of this call */
+    write(*(This->fd), &event, sizeof(event));
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI LinuxInputEffectImpl_Unload(
+	LPDIRECTINPUTEFFECT iface)
+{
+    LinuxInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("(this=%p)\n", This);
+
+    /* Erase the downloaded effect */
+    if (ioctl(*(This->fd), EVIOCRMFF, This->effect.id) == -1)
+	return DIERR_INVALIDPARAM;
+
+    /* Mark the effect as deallocated */
+    This->effect.id = -1;
+
+    return DI_OK;
+}
+
+static ULONG WINAPI LinuxInputEffectImpl_Release(LPDIRECTINPUTEFFECT iface)
+{
+    LinuxInputEffectImpl *This = impl_from_IDirectInputEffect(iface);
+    ULONG ref = InterlockedDecrement(&(This->ref));
+
+    if (ref == 0)
+    {
+        LinuxInputEffectImpl_Stop(iface);
+        LinuxInputEffectImpl_Unload(iface);
+        list_remove(This->entry);
+        HeapFree(GetProcessHeap(), 0, LIST_ENTRY(This->entry, effect_list_item, entry));
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+/******************************************************************************
+ *      LinuxInputEffect
+ */
+
+DECLSPEC_HIDDEN HRESULT linuxinput_create_effect(
+	int* fd,
+	REFGUID rguid,
+        struct list *parent_list_entry,
+	LPDIRECTINPUTEFFECT* peff)
+{
+    LinuxInputEffectImpl* newEffect = HeapAlloc(GetProcessHeap(), 
+	HEAP_ZERO_MEMORY, sizeof(LinuxInputEffectImpl));
+    DWORD type = typeFromGUID(rguid);
+
+    newEffect->IDirectInputEffect_iface.lpVtbl = &LinuxInputEffectVtbl;
+    newEffect->ref = 1;
+    newEffect->guid = *rguid;
+    newEffect->fd = fd;
+    newEffect->gain = 0xFFFF;
+
+    /* set the type.  this cannot be changed over the effect's life. */
+    switch (type) {
+	case DIEFT_PERIODIC: 
+	    newEffect->effect.type = FF_PERIODIC;
+	    if (IsEqualGUID(rguid, &GUID_Sine)) {
+		newEffect->effect.u.periodic.waveform = FF_SINE;
+	    } else if (IsEqualGUID(rguid, &GUID_Triangle)) {
+                newEffect->effect.u.periodic.waveform = FF_TRIANGLE;
+            } else if (IsEqualGUID(rguid, &GUID_Square)) {
+                newEffect->effect.u.periodic.waveform = FF_SQUARE;
+            } else if (IsEqualGUID(rguid, &GUID_SawtoothUp)) {
+                newEffect->effect.u.periodic.waveform = FF_SAW_UP;
+            } else if (IsEqualGUID(rguid, &GUID_SawtoothDown)) {
+                newEffect->effect.u.periodic.waveform = FF_SAW_DOWN;
+	    }
+	    break;
+	case DIEFT_CONSTANTFORCE: 
+            newEffect->effect.type = FF_CONSTANT;
+	    break;
+	case DIEFT_RAMPFORCE: 
+	    newEffect->effect.type = FF_RAMP;
+	    break;
+	case DIEFT_CONDITION: 
+	    if (IsEqualGUID(rguid, &GUID_Spring)) {
+		newEffect->effect.type = FF_SPRING;
+            } else if (IsEqualGUID(rguid, &GUID_Friction)) {
+		newEffect->effect.type = FF_FRICTION;
+            } else if (IsEqualGUID(rguid, &GUID_Inertia)) {
+		newEffect->effect.type = FF_INERTIA;
+            } else if (IsEqualGUID(rguid, &GUID_Damper)) {
+		newEffect->effect.type = FF_DAMPER;
+	    }
+	    break;
+	case DIEFT_CUSTOMFORCE:
+	    FIXME("Custom forces are not supported.\n");
+	    HeapFree(GetProcessHeap(), 0, newEffect);
+	    return DIERR_INVALIDPARAM;
+	default:
+            FIXME("Unknown force type 0x%x.\n", type);
+            HeapFree(GetProcessHeap(), 0, newEffect);
+	    return DIERR_INVALIDPARAM;
+    }
+
+    /* mark as non-uploaded */
+    newEffect->effect.id = -1;
+
+    newEffect->entry = parent_list_entry;
+
+    *peff = &newEffect->IDirectInputEffect_iface;
+
+    TRACE("Creating linux input system effect (%p) with guid %s\n", 
+	  *peff, _dump_dinput_GUID(rguid));
+
+    return DI_OK;
+}
+
+DECLSPEC_HIDDEN HRESULT linuxinput_get_info_A(
+	int fd,
+	REFGUID rguid,
+	LPDIEFFECTINFOA info)
+{
+    DWORD type = typeFromGUID(rguid);
+
+    TRACE("(%d, %s, %p) type=%d\n", fd, _dump_dinput_GUID(rguid), info, type);
+
+    if (!info) return E_POINTER;
+
+    if (info->dwSize != sizeof(DIEFFECTINFOA)) return DIERR_INVALIDPARAM;
+
+    info->guid = *rguid;
+    
+    info->dwEffType = type; 
+    /* the event device API does not support querying for all these things
+     * therefore we assume that we have support for them
+     * that's not as dangerous as it sounds, since drivers are allowed to
+     * ignore parameters they claim to support anyway */
+    info->dwEffType |= DIEFT_DEADBAND | DIEFT_FFATTACK | DIEFT_FFFADE 
+                    | DIEFT_POSNEGCOEFFICIENTS | DIEFT_POSNEGSATURATION
+		    | DIEFT_SATURATION | DIEFT_STARTDELAY; 
+
+    /* again, assume we have support for everything */
+    info->dwStaticParams = DIEP_ALLPARAMS;
+    info->dwDynamicParams = info->dwStaticParams;
+
+    /* yes, this is windows behavior (print the GUID_Name for name) */
+    strcpy(info->tszName, _dump_dinput_GUID(rguid));
+
+    return DI_OK;
+}
+
+DECLSPEC_HIDDEN HRESULT linuxinput_get_info_W(
+	int fd,
+	REFGUID rguid,
+	LPDIEFFECTINFOW info)
+{
+    DWORD type = typeFromGUID(rguid);
+
+    TRACE("(%d, %s, %p) type=%d\n", fd, _dump_dinput_GUID(rguid), info, type);
+
+    if (!info) return E_POINTER;
+
+    if (info->dwSize != sizeof(DIEFFECTINFOW)) return DIERR_INVALIDPARAM;
+
+    info->guid = *rguid;
+
+    info->dwEffType = type;
+    /* the event device API does not support querying for all these things
+     * therefore we assume that we have support for them
+     * that's not as dangerous as it sounds, since drivers are allowed to
+     * ignore parameters they claim to support anyway */
+    info->dwEffType |= DIEFT_DEADBAND | DIEFT_FFATTACK | DIEFT_FFFADE
+                    | DIEFT_POSNEGCOEFFICIENTS | DIEFT_POSNEGSATURATION
+                    | DIEFT_SATURATION | DIEFT_STARTDELAY; 
+
+    /* again, assume we have support for everything */
+    info->dwStaticParams = DIEP_ALLPARAMS;
+    info->dwDynamicParams = info->dwStaticParams;
+
+    /* yes, this is windows behavior (print the GUID_Name for name) */
+    MultiByteToWideChar(CP_ACP, 0, _dump_dinput_GUID(rguid), -1, 
+                        info->tszName, MAX_PATH);
+
+    return DI_OK;
+}
+
+static const IDirectInputEffectVtbl LinuxInputEffectVtbl = {
+    LinuxInputEffectImpl_QueryInterface,
+    LinuxInputEffectImpl_AddRef,
+    LinuxInputEffectImpl_Release,
+    LinuxInputEffectImpl_Initialize,
+    LinuxInputEffectImpl_GetEffectGuid,
+    LinuxInputEffectImpl_GetParameters,
+    LinuxInputEffectImpl_SetParameters,
+    LinuxInputEffectImpl_Start,
+    LinuxInputEffectImpl_Stop,
+    LinuxInputEffectImpl_GetEffectStatus,
+    LinuxInputEffectImpl_Download,
+    LinuxInputEffectImpl_Unload,
+    LinuxInputEffectImpl_Escape
+};
+
+#endif /* HAVE_STRUCT_FF_EFFECT_DIRECTION */
diff --git a/dlls/dinput8/joystick.c b/dlls/dinput8/joystick.c
new file mode 100644
index 0000000..45c3618
--- /dev/null
+++ b/dlls/dinput8/joystick.c
@@ -0,0 +1,1083 @@
+/*  DirectInput Generic Joystick device
+ *
+ * Copyright 1998 Marcus Meissner
+ * Copyright 1998,1999 Lionel Ulmer
+ * Copyright 2000-2001 TransGaming Technologies Inc.
+ * Copyright 2009 Aric Stewart, CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/*
+ * To Do:
+ *	dead zone
+ *	force feedback
+ */
+
+#include <stdio.h>
+
+#include "joystick_private.h"
+#include "wine/debug.h"
+#include "winreg.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dinput);
+
+static inline JoystickGenericImpl *impl_from_IDirectInputDevice8A(IDirectInputDevice8A *iface)
+{
+    return CONTAINING_RECORD(CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8A_iface), JoystickGenericImpl, base);
+}
+static inline JoystickGenericImpl *impl_from_IDirectInputDevice8W(IDirectInputDevice8W *iface)
+{
+    return CONTAINING_RECORD(CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8W_iface), JoystickGenericImpl, base);
+}
+static inline IDirectInputDevice8A *IDirectInputDevice8A_from_impl(JoystickGenericImpl *This)
+{
+    return &This->base.IDirectInputDevice8A_iface;
+}
+static inline IDirectInputDevice8W *IDirectInputDevice8W_from_impl(JoystickGenericImpl *This)
+{
+    return &This->base.IDirectInputDevice8W_iface;
+}
+
+DWORD typeFromGUID(REFGUID guid)
+{
+    if (IsEqualGUID(guid, &GUID_ConstantForce)) {
+        return DIEFT_CONSTANTFORCE;
+    } else if (IsEqualGUID(guid, &GUID_Square)
+            || IsEqualGUID(guid, &GUID_Sine)
+            || IsEqualGUID(guid, &GUID_Triangle)
+            || IsEqualGUID(guid, &GUID_SawtoothUp)
+            || IsEqualGUID(guid, &GUID_SawtoothDown)) {
+        return DIEFT_PERIODIC;
+    } else if (IsEqualGUID(guid, &GUID_RampForce)) {
+        return DIEFT_RAMPFORCE;
+    } else if (IsEqualGUID(guid, &GUID_Spring)
+            || IsEqualGUID(guid, &GUID_Damper)
+            || IsEqualGUID(guid, &GUID_Inertia)
+            || IsEqualGUID(guid, &GUID_Friction)) {
+        return DIEFT_CONDITION;
+    } else if (IsEqualGUID(guid, &GUID_CustomForce)) {
+        return DIEFT_CUSTOMFORCE;
+    } else {
+        WARN("GUID (%s) is not a known force type\n", _dump_dinput_GUID(guid));
+        return 0;
+    }
+}
+
+static void _dump_DIEFFECT_flags(DWORD dwFlags)
+{
+    if (TRACE_ON(dinput)) {
+        unsigned int   i;
+        static const struct {
+            DWORD       mask;
+            const char  *name;
+        } flags[] = {
+#define FE(x) { x, #x}
+            FE(DIEFF_CARTESIAN),
+            FE(DIEFF_OBJECTIDS),
+            FE(DIEFF_OBJECTOFFSETS),
+            FE(DIEFF_POLAR),
+            FE(DIEFF_SPHERICAL)
+#undef FE
+        };
+        for (i = 0; i < (sizeof(flags) / sizeof(flags[0])); i++)
+            if (flags[i].mask & dwFlags)
+                TRACE("%s ", flags[i].name);
+        TRACE("\n");
+    }
+}
+
+static void _dump_DIENVELOPE(LPCDIENVELOPE env)
+{
+    if (env->dwSize != sizeof(DIENVELOPE)) {
+        WARN("Non-standard DIENVELOPE structure size %d.\n", env->dwSize);
+    }
+    TRACE("Envelope has attack (level: %d time: %d), fade (level: %d time: %d)\n",
+          env->dwAttackLevel, env->dwAttackTime, env->dwFadeLevel, env->dwFadeTime);
+}
+
+static void _dump_DICONSTANTFORCE(LPCDICONSTANTFORCE frc)
+{
+    TRACE("Constant force has magnitude %d\n", frc->lMagnitude);
+}
+
+static void _dump_DIPERIODIC(LPCDIPERIODIC frc)
+{
+    TRACE("Periodic force has magnitude %d, offset %d, phase %d, period %d\n",
+          frc->dwMagnitude, frc->lOffset, frc->dwPhase, frc->dwPeriod);
+}
+
+static void _dump_DIRAMPFORCE(LPCDIRAMPFORCE frc)
+{
+    TRACE("Ramp force has start %d, end %d\n",
+          frc->lStart, frc->lEnd);
+}
+
+static void _dump_DICONDITION(LPCDICONDITION frc)
+{
+    TRACE("Condition has offset %d, pos/neg coefficients %d and %d, pos/neg saturations %d and %d, deadband %d\n",
+          frc->lOffset, frc->lPositiveCoefficient, frc->lNegativeCoefficient,
+          frc->dwPositiveSaturation, frc->dwNegativeSaturation, frc->lDeadBand);
+}
+
+static void _dump_DICUSTOMFORCE(LPCDICUSTOMFORCE frc)
+{
+    unsigned int i;
+    TRACE("Custom force uses %d channels, sample period %d.  Has %d samples at %p.\n",
+          frc->cChannels, frc->dwSamplePeriod, frc->cSamples, frc->rglForceData);
+    if (frc->cSamples % frc->cChannels != 0)
+        WARN("Custom force has a non-integral samples-per-channel count!\n");
+    if (TRACE_ON(dinput)) {
+        TRACE("Custom force data (time aligned, axes in order):\n");
+        for (i = 1; i <= frc->cSamples; ++i) {
+            TRACE("%d ", frc->rglForceData[i]);
+            if (i % frc->cChannels == 0)
+                TRACE("\n");
+        }
+    }
+}
+
+void dump_DIEFFECT(LPCDIEFFECT eff, REFGUID guid, DWORD dwFlags)
+{
+    DWORD type = typeFromGUID(guid);
+    unsigned int i;
+
+    TRACE("Dumping DIEFFECT structure:\n");
+    TRACE("  - dwSize: %d\n", eff->dwSize);
+    if ((eff->dwSize != sizeof(DIEFFECT)) && (eff->dwSize != sizeof(DIEFFECT_DX5))) {
+        WARN("Non-standard DIEFFECT structure size %d\n", eff->dwSize);
+    }
+    TRACE("  - dwFlags: %d\n", eff->dwFlags);
+    TRACE("    ");
+    _dump_DIEFFECT_flags(eff->dwFlags);
+    TRACE("  - dwDuration: %d\n", eff->dwDuration);
+    TRACE("  - dwGain: %d\n", eff->dwGain);
+
+    if (eff->dwGain > 10000)
+        WARN("dwGain is out of range (>10,000)\n");
+
+    TRACE("  - dwTriggerButton: %d\n", eff->dwTriggerButton);
+    TRACE("  - dwTriggerRepeatInterval: %d\n", eff->dwTriggerRepeatInterval);
+    TRACE("  - rglDirection: %p\n", eff->rglDirection);
+    TRACE("  - cbTypeSpecificParams: %d\n", eff->cbTypeSpecificParams);
+    TRACE("  - lpvTypeSpecificParams: %p\n", eff->lpvTypeSpecificParams);
+
+    /* Only trace some members if dwFlags indicates they have data */
+    if (dwFlags & DIEP_AXES) {
+        TRACE("  - cAxes: %d\n", eff->cAxes);
+        TRACE("  - rgdwAxes: %p\n", eff->rgdwAxes);
+
+        if (TRACE_ON(dinput) && eff->rgdwAxes) {
+            TRACE("    ");
+            for (i = 0; i < eff->cAxes; ++i)
+                TRACE("%d ", eff->rgdwAxes[i]);
+            TRACE("\n");
+        }
+    }
+
+    if (dwFlags & DIEP_ENVELOPE) {
+        TRACE("  - lpEnvelope: %p\n", eff->lpEnvelope);
+        if (eff->lpEnvelope != NULL)
+            _dump_DIENVELOPE(eff->lpEnvelope);
+    }
+
+    if (eff->dwSize > sizeof(DIEFFECT_DX5))
+        TRACE("  - dwStartDelay: %d\n", eff->dwStartDelay);
+
+    if (type == DIEFT_CONSTANTFORCE) {
+        if (eff->cbTypeSpecificParams != sizeof(DICONSTANTFORCE)) {
+            WARN("Effect claims to be a constant force but the type-specific params are the wrong size!\n");
+        } else {
+            _dump_DICONSTANTFORCE(eff->lpvTypeSpecificParams);
+        }
+    } else if (type == DIEFT_PERIODIC) {
+        if (eff->cbTypeSpecificParams != sizeof(DIPERIODIC)) {
+            WARN("Effect claims to be a periodic force but the type-specific params are the wrong size!\n");
+        } else {
+            _dump_DIPERIODIC(eff->lpvTypeSpecificParams);
+        }
+    } else if (type == DIEFT_RAMPFORCE) {
+        if (eff->cbTypeSpecificParams != sizeof(DIRAMPFORCE)) {
+            WARN("Effect claims to be a ramp force but the type-specific params are the wrong size!\n");
+        } else {
+            _dump_DIRAMPFORCE(eff->lpvTypeSpecificParams);
+        }
+    } else if (type == DIEFT_CONDITION) {
+        if (eff->cbTypeSpecificParams == sizeof(DICONDITION)) {
+            _dump_DICONDITION(eff->lpvTypeSpecificParams);
+        } else if (eff->cbTypeSpecificParams == 2 * sizeof(DICONDITION)) {
+            DICONDITION *condition = eff->lpvTypeSpecificParams;
+            _dump_DICONDITION(&condition[0]);
+            _dump_DICONDITION(&condition[1]);
+        } else {
+            WARN("Effect claims to be a condition but the type-specific params are the wrong size!\n");
+        }
+    } else if (type == DIEFT_CUSTOMFORCE) {
+        if (eff->cbTypeSpecificParams != sizeof(DICUSTOMFORCE)) {
+            WARN("Effect claims to be a custom force but the type-specific params are the wrong size!\n");
+        } else {
+            _dump_DICUSTOMFORCE(eff->lpvTypeSpecificParams);
+        }
+    }
+}
+
+BOOL device_disabled_registry(const char* name)
+{
+    static const char disabled_str[] = "disabled";
+    static const char joystick_key[] = "Joysticks";
+    char buffer[MAX_PATH];
+    HKEY hkey, appkey, temp;
+    BOOL do_disable = FALSE;
+
+    get_app_key(&hkey, &appkey);
+
+    /* Joystick settings are in the 'joysticks' subkey */
+    if (appkey)
+    {
+        if (RegOpenKeyA(appkey, joystick_key, &temp)) temp = 0;
+        RegCloseKey(appkey);
+        appkey = temp;
+    }
+    if (hkey)
+    {
+        if (RegOpenKeyA(hkey, joystick_key, &temp)) temp = 0;
+        RegCloseKey(hkey);
+        hkey = temp;
+    }
+
+    /* Look for the "controllername"="disabled" key */
+    if (!get_config_key(hkey, appkey, name, buffer, sizeof(buffer)))
+        if (!strcmp(disabled_str, buffer))
+        {
+            TRACE("Disabling joystick '%s' based on registry key.\n", name);
+            do_disable = TRUE;
+        }
+
+    if (appkey) RegCloseKey(appkey);
+    if (hkey)   RegCloseKey(hkey);
+
+    return do_disable;
+}
+
+/******************************************************************************
+  *     SetProperty : change input device properties
+  */
+HRESULT WINAPI JoystickWGenericImpl_SetProperty(LPDIRECTINPUTDEVICE8W iface, REFGUID rguid, LPCDIPROPHEADER ph)
+{
+    JoystickGenericImpl *This = impl_from_IDirectInputDevice8W(iface);
+    DWORD i;
+    ObjProps remap_props;
+
+    TRACE("(%p,%s,%p)\n",This,debugstr_guid(rguid),ph);
+
+    if (ph == NULL) {
+        WARN("invalid parameter: ph == NULL\n");
+        return DIERR_INVALIDPARAM;
+    }
+
+    if (TRACE_ON(dinput))
+        _dump_DIPROPHEADER(ph);
+
+    if (IS_DIPROP(rguid)) {
+        switch (LOWORD(rguid)) {
+        case (DWORD_PTR)DIPROP_RANGE: {
+            LPCDIPROPRANGE pr = (LPCDIPROPRANGE)ph;
+            if (ph->dwHow == DIPH_DEVICE) {
+
+                /* Many games poll the joystick immediately after setting the range
+                 * for calibration purposes, so the old values need to be remapped
+                 * to the new range before it does so */
+
+                TRACE("proprange(%d,%d) all\n", pr->lMin, pr->lMax);
+                for (i = 0; i < This->base.data_format.wine_df->dwNumObjs; i++) {
+
+                    remap_props.lDevMin = This->props[i].lMin;
+                    remap_props.lDevMax = This->props[i].lMax;
+
+                    remap_props.lDeadZone = This->props[i].lDeadZone;
+                    remap_props.lSaturation = This->props[i].lSaturation;
+
+                    remap_props.lMin = pr->lMin;
+                    remap_props.lMax = pr->lMax;
+
+                    switch (This->base.data_format.wine_df->rgodf[i].dwOfs) {
+                    case DIJOFS_X        : This->js.lX  = joystick_map_axis(&remap_props, This->js.lX); break;
+                    case DIJOFS_Y        : This->js.lY  = joystick_map_axis(&remap_props, This->js.lY); break;
+                    case DIJOFS_Z        : This->js.lZ  = joystick_map_axis(&remap_props, This->js.lZ); break;
+                    case DIJOFS_RX       : This->js.lRx = joystick_map_axis(&remap_props, This->js.lRx); break;
+                    case DIJOFS_RY       : This->js.lRy = joystick_map_axis(&remap_props, This->js.lRy); break;
+                    case DIJOFS_RZ       : This->js.lRz = joystick_map_axis(&remap_props, This->js.lRz); break;
+                    case DIJOFS_SLIDER(0): This->js.rglSlider[0] = joystick_map_axis(&remap_props, This->js.rglSlider[0]); break;
+                    case DIJOFS_SLIDER(1): This->js.rglSlider[1] = joystick_map_axis(&remap_props, This->js.rglSlider[1]); break;
+	            default: break;
+                    }
+
+                    This->props[i].lMin = pr->lMin;
+                    This->props[i].lMax = pr->lMax;
+                }
+            } else {
+                int obj = find_property(&This->base.data_format, ph);
+
+                TRACE("proprange(%d,%d) obj=%d\n", pr->lMin, pr->lMax, obj);
+                if (obj >= 0) {
+
+                    remap_props.lDevMin = This->props[obj].lMin;
+                    remap_props.lDevMax = This->props[obj].lMax;
+
+                    remap_props.lDeadZone = This->props[obj].lDeadZone;
+                    remap_props.lSaturation = This->props[obj].lSaturation;
+
+                    remap_props.lMin = pr->lMin;
+                    remap_props.lMax = pr->lMax;
+
+                    switch (This->base.data_format.wine_df->rgodf[obj].dwOfs) {
+                    case DIJOFS_X        : This->js.lX  = joystick_map_axis(&remap_props, This->js.lX); break;
+                    case DIJOFS_Y        : This->js.lY  = joystick_map_axis(&remap_props, This->js.lY); break;
+                    case DIJOFS_Z        : This->js.lZ  = joystick_map_axis(&remap_props, This->js.lZ); break;
+                    case DIJOFS_RX       : This->js.lRx = joystick_map_axis(&remap_props, This->js.lRx); break;
+                    case DIJOFS_RY       : This->js.lRy = joystick_map_axis(&remap_props, This->js.lRy); break;
+                    case DIJOFS_RZ       : This->js.lRz = joystick_map_axis(&remap_props, This->js.lRz); break;
+                    case DIJOFS_SLIDER(0): This->js.rglSlider[0] = joystick_map_axis(&remap_props, This->js.rglSlider[0]); break;
+                    case DIJOFS_SLIDER(1): This->js.rglSlider[1] = joystick_map_axis(&remap_props, This->js.rglSlider[1]); break;
+		    default: break;
+                    }
+
+                    This->props[obj].lMin = pr->lMin;
+                    This->props[obj].lMax = pr->lMax;
+                    return DI_OK;
+                }
+            }
+            break;
+        }
+        case (DWORD_PTR)DIPROP_DEADZONE: {
+            LPCDIPROPDWORD pd = (LPCDIPROPDWORD)ph;
+            if (ph->dwHow == DIPH_DEVICE) {
+                TRACE("deadzone(%d) all\n", pd->dwData);
+                for (i = 0; i < This->base.data_format.wine_df->dwNumObjs; i++)
+                    This->props[i].lDeadZone  = pd->dwData;
+            } else {
+                int obj = find_property(&This->base.data_format, ph);
+
+                TRACE("deadzone(%d) obj=%d\n", pd->dwData, obj);
+                if (obj >= 0) {
+                    This->props[obj].lDeadZone  = pd->dwData;
+                    return DI_OK;
+                }
+            }
+            break;
+        }
+        case (DWORD_PTR)DIPROP_SATURATION: {
+            LPCDIPROPDWORD pd = (LPCDIPROPDWORD)ph;
+            if (ph->dwHow == DIPH_DEVICE) {
+                TRACE("saturation(%d) all\n", pd->dwData);
+                for (i = 0; i < This->base.data_format.wine_df->dwNumObjs; i++)
+                    This->props[i].lSaturation = pd->dwData;
+            } else {
+                int obj = find_property(&This->base.data_format, ph);
+
+                TRACE("saturation(%d) obj=%d\n", pd->dwData, obj);
+                if (obj >= 0) {
+                    This->props[obj].lSaturation = pd->dwData;
+                    return DI_OK;
+                }
+            }
+            break;
+        }
+        default:
+            return IDirectInputDevice2WImpl_SetProperty(iface, rguid, ph);
+        }
+    }
+
+    return DI_OK;
+}
+
+HRESULT WINAPI JoystickAGenericImpl_SetProperty(LPDIRECTINPUTDEVICE8A iface, REFGUID rguid, LPCDIPROPHEADER ph)
+{
+    JoystickGenericImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickWGenericImpl_SetProperty(IDirectInputDevice8W_from_impl(This), rguid, ph);
+}
+
+#define DEBUG_TYPE(x) case (x): str = #x; break
+void _dump_DIDEVCAPS(const DIDEVCAPS *lpDIDevCaps)
+{
+    int type = GET_DIDEVICE_TYPE(lpDIDevCaps->dwDevType);
+    const char *str, *hid = "";
+    TRACE("dwSize: %d\n", lpDIDevCaps->dwSize);
+    TRACE("dwFlags: %08x\n", lpDIDevCaps->dwFlags);
+    switch(type)
+    {
+        /* Direct X <= 7 definitions */
+        DEBUG_TYPE(DIDEVTYPE_DEVICE);
+        DEBUG_TYPE(DIDEVTYPE_MOUSE);
+        DEBUG_TYPE(DIDEVTYPE_KEYBOARD);
+        DEBUG_TYPE(DIDEVTYPE_JOYSTICK);
+        /* Direct X >= 8 definitions */
+        DEBUG_TYPE(DI8DEVTYPE_DEVICE);
+        DEBUG_TYPE(DI8DEVTYPE_MOUSE);
+        DEBUG_TYPE(DI8DEVTYPE_KEYBOARD);
+        DEBUG_TYPE(DI8DEVTYPE_JOYSTICK);
+        DEBUG_TYPE(DI8DEVTYPE_GAMEPAD);
+        DEBUG_TYPE(DI8DEVTYPE_DRIVING);
+        DEBUG_TYPE(DI8DEVTYPE_FLIGHT);
+        DEBUG_TYPE(DI8DEVTYPE_1STPERSON);
+        DEBUG_TYPE(DI8DEVTYPE_DEVICECTRL);
+        DEBUG_TYPE(DI8DEVTYPE_SCREENPOINTER);
+        DEBUG_TYPE(DI8DEVTYPE_REMOTE);
+        DEBUG_TYPE(DI8DEVTYPE_SUPPLEMENTAL);
+        default: str = "UNKNOWN";
+    }
+
+    if (lpDIDevCaps->dwDevType & DIDEVTYPE_HID)
+        hid = " (HID)";
+
+    TRACE("dwDevType: %08x %s%s\n", lpDIDevCaps->dwDevType, str, hid);
+    TRACE("dwAxes: %d\n", lpDIDevCaps->dwAxes);
+    TRACE("dwButtons: %d\n", lpDIDevCaps->dwButtons);
+    TRACE("dwPOVs: %d\n", lpDIDevCaps->dwPOVs);
+    if (lpDIDevCaps->dwSize > sizeof(DIDEVCAPS_DX3)) {
+        TRACE("dwFFSamplePeriod: %d\n", lpDIDevCaps->dwFFSamplePeriod);
+        TRACE("dwFFMinTimeResolution: %d\n", lpDIDevCaps->dwFFMinTimeResolution);
+        TRACE("dwFirmwareRevision: %d\n", lpDIDevCaps->dwFirmwareRevision);
+        TRACE("dwHardwareRevision: %d\n", lpDIDevCaps->dwHardwareRevision);
+        TRACE("dwFFDriverVersion: %d\n", lpDIDevCaps->dwFFDriverVersion);
+    }
+}
+#undef DEBUG_TYPE
+
+HRESULT WINAPI JoystickWGenericImpl_GetCapabilities(LPDIRECTINPUTDEVICE8W iface, LPDIDEVCAPS lpDIDevCaps)
+{
+    JoystickGenericImpl *This = impl_from_IDirectInputDevice8W(iface);
+    int size;
+
+    TRACE("%p->(%p)\n",iface,lpDIDevCaps);
+
+    if (lpDIDevCaps == NULL) {
+        WARN("invalid pointer\n");
+        return E_POINTER;
+    }
+
+    size = lpDIDevCaps->dwSize;
+
+    if (!(size == sizeof(DIDEVCAPS) || size == sizeof(DIDEVCAPS_DX3))) {
+        WARN("invalid parameter\n");
+        return DIERR_INVALIDPARAM;
+    }
+
+    CopyMemory(lpDIDevCaps, &This->devcaps, size);
+    lpDIDevCaps->dwSize = size;
+
+    if (TRACE_ON(dinput))
+        _dump_DIDEVCAPS(lpDIDevCaps);
+
+    return DI_OK;
+}
+
+HRESULT WINAPI JoystickAGenericImpl_GetCapabilities(LPDIRECTINPUTDEVICE8A iface, LPDIDEVCAPS lpDIDevCaps)
+{
+    JoystickGenericImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickWGenericImpl_GetCapabilities(IDirectInputDevice8W_from_impl(This), lpDIDevCaps);
+}
+
+/******************************************************************************
+  *     GetObjectInfo : get object info
+  */
+HRESULT WINAPI JoystickWGenericImpl_GetObjectInfo(LPDIRECTINPUTDEVICE8W iface,
+        LPDIDEVICEOBJECTINSTANCEW pdidoi, DWORD dwObj, DWORD dwHow)
+{
+    static const WCHAR axisW[] = {'A','x','i','s',' ','%','d',0};
+    static const WCHAR povW[] = {'P','O','V',' ','%','d',0};
+    static const WCHAR buttonW[] = {'B','u','t','t','o','n',' ','%','d',0};
+    HRESULT res;
+
+    res = IDirectInputDevice2WImpl_GetObjectInfo(iface, pdidoi, dwObj, dwHow);
+    if (res != DI_OK) return res;
+
+    if (pdidoi->dwType & DIDFT_AXIS) {
+        sprintfW(pdidoi->tszName, axisW, DIDFT_GETINSTANCE(pdidoi->dwType));
+        pdidoi->dwFlags |= DIDOI_ASPECTPOSITION;
+    } else if (pdidoi->dwType & DIDFT_POV)
+        sprintfW(pdidoi->tszName, povW, DIDFT_GETINSTANCE(pdidoi->dwType));
+    else if (pdidoi->dwType & DIDFT_BUTTON)
+        sprintfW(pdidoi->tszName, buttonW, DIDFT_GETINSTANCE(pdidoi->dwType));
+
+    _dump_OBJECTINSTANCEW(pdidoi);
+    return res;
+}
+
+HRESULT WINAPI JoystickAGenericImpl_GetObjectInfo(LPDIRECTINPUTDEVICE8A iface,
+        LPDIDEVICEOBJECTINSTANCEA pdidoi, DWORD dwObj, DWORD dwHow)
+{
+    JoystickGenericImpl *This = impl_from_IDirectInputDevice8A(iface);
+    HRESULT res;
+    DIDEVICEOBJECTINSTANCEW didoiW;
+    DWORD dwSize = pdidoi->dwSize;
+
+    didoiW.dwSize = sizeof(didoiW);
+    res = JoystickWGenericImpl_GetObjectInfo(IDirectInputDevice8W_from_impl(This), &didoiW, dwObj, dwHow);
+    if (res != DI_OK) return res;
+
+    memset(pdidoi, 0, pdidoi->dwSize);
+    memcpy(pdidoi, &didoiW, FIELD_OFFSET(DIDEVICEOBJECTINSTANCEW, tszName));
+    pdidoi->dwSize = dwSize;
+    WideCharToMultiByte(CP_ACP, 0, didoiW.tszName, -1, pdidoi->tszName,
+                        sizeof(pdidoi->tszName), NULL, NULL);
+
+    return res;
+}
+
+/******************************************************************************
+  *     GetProperty : get input device properties
+  */
+HRESULT WINAPI JoystickWGenericImpl_GetProperty(LPDIRECTINPUTDEVICE8W iface, REFGUID rguid, LPDIPROPHEADER pdiph)
+{
+    JoystickGenericImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(%p,%s,%p)\n", iface, debugstr_guid(rguid), pdiph);
+
+    if (TRACE_ON(dinput))
+        _dump_DIPROPHEADER(pdiph);
+
+    if (IS_DIPROP(rguid)) {
+        switch (LOWORD(rguid)) {
+        case (DWORD_PTR) DIPROP_RANGE: {
+            LPDIPROPRANGE pr = (LPDIPROPRANGE)pdiph;
+            int obj = find_property(&This->base.data_format, pdiph);
+
+            /* The app is querying the current range of the axis
+             * return the lMin and lMax values */
+            if (obj >= 0) {
+                pr->lMin = This->props[obj].lMin;
+                pr->lMax = This->props[obj].lMax;
+                TRACE("range(%d, %d) obj=%d\n", pr->lMin, pr->lMax, obj);
+                return DI_OK;
+            }
+            break;
+        }
+        case (DWORD_PTR) DIPROP_DEADZONE: {
+            LPDIPROPDWORD pd = (LPDIPROPDWORD)pdiph;
+            int obj = find_property(&This->base.data_format, pdiph);
+
+            if (obj >= 0) {
+                pd->dwData = This->props[obj].lDeadZone;
+                TRACE("deadzone(%d) obj=%d\n", pd->dwData, obj);
+                return DI_OK;
+            }
+            break;
+        }
+        case (DWORD_PTR) DIPROP_SATURATION: {
+            LPDIPROPDWORD pd = (LPDIPROPDWORD)pdiph;
+            int obj = find_property(&This->base.data_format, pdiph);
+
+            if (obj >= 0) {
+                pd->dwData = This->props[obj].lSaturation;
+                TRACE("saturation(%d) obj=%d\n", pd->dwData, obj);
+                return DI_OK;
+            }
+            break;
+        }
+        case (DWORD_PTR) DIPROP_PRODUCTNAME:
+        case (DWORD_PTR) DIPROP_INSTANCENAME: {
+            DIPROPSTRING *ps = (DIPROPSTRING*) pdiph;
+            DIDEVICEINSTANCEW didev;
+
+            didev.dwSize = sizeof(didev);
+
+            IDirectInputDevice_GetDeviceInfo(iface, &didev);
+            if (LOWORD(rguid) == (DWORD_PTR) DIPROP_PRODUCTNAME)
+                lstrcpynW(ps->wsz, didev.tszProductName, MAX_PATH);
+            else
+                lstrcpynW(ps->wsz, didev.tszInstanceName, MAX_PATH);
+
+            return DI_OK;
+        }
+        default:
+            return IDirectInputDevice2WImpl_GetProperty(iface, rguid, pdiph);
+        }
+    }
+
+    return DI_OK;
+}
+
+HRESULT WINAPI JoystickAGenericImpl_GetProperty(LPDIRECTINPUTDEVICE8A iface, REFGUID rguid, LPDIPROPHEADER pdiph)
+{
+    JoystickGenericImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickWGenericImpl_GetProperty(IDirectInputDevice8W_from_impl(This), rguid, pdiph);
+}
+
+/******************************************************************************
+  *     GetDeviceInfo : get information about a device's identity
+  */
+HRESULT WINAPI JoystickAGenericImpl_GetDeviceInfo(
+    LPDIRECTINPUTDEVICE8A iface,
+    LPDIDEVICEINSTANCEA pdidi)
+{
+    JoystickGenericImpl *This = impl_from_IDirectInputDevice8A(iface);
+    DIPROPDWORD pd;
+    DWORD index = 0;
+
+    TRACE("(%p,%p)\n", iface, pdidi);
+
+    if (pdidi == NULL) {
+        WARN("invalid pointer\n");
+        return E_POINTER;
+    }
+
+    if ((pdidi->dwSize != sizeof(DIDEVICEINSTANCE_DX3A)) &&
+        (pdidi->dwSize != sizeof(DIDEVICEINSTANCEA))) {
+        WARN("invalid parameter: pdidi->dwSize = %d\n", pdidi->dwSize);
+        return DIERR_INVALIDPARAM;
+    }
+
+    /* Try to get joystick index */
+    pd.diph.dwSize = sizeof(pd);
+    pd.diph.dwHeaderSize = sizeof(pd.diph);
+    pd.diph.dwObj = 0;
+    pd.diph.dwHow = DIPH_DEVICE;
+    if (SUCCEEDED(IDirectInputDevice2_GetProperty(iface, DIPROP_JOYSTICKID, &pd.diph)))
+        index = pd.dwData;
+
+    /* Return joystick */
+    pdidi->guidInstance = This->guidInstance;
+    pdidi->guidProduct = This->guidProduct;
+    /* we only support traditional joysticks for now */
+    pdidi->dwDevType = This->devcaps.dwDevType;
+    snprintf(pdidi->tszInstanceName, MAX_PATH, "Joystick %d", index);
+    strcpy(pdidi->tszProductName, This->name);
+    if (pdidi->dwSize > sizeof(DIDEVICEINSTANCE_DX3A)) {
+        pdidi->guidFFDriver = GUID_NULL;
+        pdidi->wUsagePage = 0;
+        pdidi->wUsage = 0;
+    }
+
+    return DI_OK;
+}
+
+/******************************************************************************
+  *     GetDeviceInfo : get information about a device's identity
+  */
+HRESULT WINAPI JoystickWGenericImpl_GetDeviceInfo(
+    LPDIRECTINPUTDEVICE8W iface,
+    LPDIDEVICEINSTANCEW pdidi)
+{
+    JoystickGenericImpl *This = impl_from_IDirectInputDevice8W(iface);
+    CHAR buffer[MAX_PATH];
+    DIPROPDWORD pd;
+    DWORD index = 0;
+
+    TRACE("(%p,%p)\n", iface, pdidi);
+
+    if ((pdidi->dwSize != sizeof(DIDEVICEINSTANCE_DX3W)) &&
+        (pdidi->dwSize != sizeof(DIDEVICEINSTANCEW))) {
+        WARN("invalid parameter: pdidi->dwSize = %d\n", pdidi->dwSize);
+        return DIERR_INVALIDPARAM;
+    }
+
+    /* Try to get joystick index */
+    pd.diph.dwSize = sizeof(pd);
+    pd.diph.dwHeaderSize = sizeof(pd.diph);
+    pd.diph.dwObj = 0;
+    pd.diph.dwHow = DIPH_DEVICE;
+    if (SUCCEEDED(IDirectInputDevice2_GetProperty(iface, DIPROP_JOYSTICKID, &pd.diph)))
+        index = pd.dwData;
+
+    /* Return joystick */
+    pdidi->guidInstance = This->guidInstance;
+    pdidi->guidProduct = This->guidProduct;
+    /* we only support traditional joysticks for now */
+    pdidi->dwDevType = This->devcaps.dwDevType;
+    snprintf(buffer, sizeof(buffer), "Joystick %d", index);
+    MultiByteToWideChar(CP_ACP, 0, buffer, -1, pdidi->tszInstanceName, MAX_PATH);
+    MultiByteToWideChar(CP_ACP, 0, This->name, -1, pdidi->tszProductName, MAX_PATH);
+    if (pdidi->dwSize > sizeof(DIDEVICEINSTANCE_DX3W)) {
+        pdidi->guidFFDriver = GUID_NULL;
+        pdidi->wUsagePage = 0;
+        pdidi->wUsage = 0;
+    }
+
+    return DI_OK;
+}
+
+HRESULT WINAPI JoystickWGenericImpl_Poll(LPDIRECTINPUTDEVICE8W iface)
+{
+    JoystickGenericImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(%p)\n",This);
+
+    if (!This->base.acquired) {
+        WARN("not acquired\n");
+        return DIERR_NOTACQUIRED;
+    }
+
+    This->joy_polldev(IDirectInputDevice8A_from_impl(This));
+    return DI_OK;
+}
+
+HRESULT WINAPI JoystickAGenericImpl_Poll(LPDIRECTINPUTDEVICE8A iface)
+{
+    JoystickGenericImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickWGenericImpl_Poll(IDirectInputDevice8W_from_impl(This));
+}
+
+/******************************************************************************
+  *     GetDeviceState : returns the "state" of the joystick.
+  *
+  */
+HRESULT WINAPI JoystickWGenericImpl_GetDeviceState(LPDIRECTINPUTDEVICE8W iface, DWORD len, LPVOID ptr)
+{
+    JoystickGenericImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(%p,0x%08x,%p)\n", This, len, ptr);
+
+    if (!This->base.acquired) {
+        WARN("not acquired\n");
+        return DIERR_NOTACQUIRED;
+    }
+
+    /* update joystick state */
+    This->joy_polldev(IDirectInputDevice8A_from_impl(This));
+
+    /* convert and copy data to user supplied buffer */
+    fill_DataFormat(ptr, len, &This->js, &This->base.data_format);
+
+    return DI_OK;
+}
+
+HRESULT WINAPI JoystickAGenericImpl_GetDeviceState(LPDIRECTINPUTDEVICE8A iface, DWORD len, LPVOID ptr)
+{
+    JoystickGenericImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickWGenericImpl_GetDeviceState(IDirectInputDevice8W_from_impl(This), len, ptr);
+}
+
+
+HRESULT WINAPI JoystickWGenericImpl_BuildActionMap(LPDIRECTINPUTDEVICE8W iface,
+                                                   LPDIACTIONFORMATW lpdiaf,
+                                                   LPCWSTR lpszUserName,
+                                                   DWORD dwFlags)
+{
+    JoystickGenericImpl *This = impl_from_IDirectInputDevice8W(iface);
+    unsigned int i, j;
+    BOOL has_actions = FALSE;
+    DWORD object_types[] = { DIDFT_AXIS, DIDFT_BUTTON };
+    DWORD type_map[] = { DIDFT_RELAXIS, DIDFT_PSHBUTTON };
+
+    FIXME("(%p)->(%p,%s,%08x): semi-stub !\n", iface, lpdiaf, debugstr_w(lpszUserName), dwFlags);
+
+    for (i=0; i < lpdiaf->dwNumActions; i++)
+    {
+        DWORD inst = (0x000000ff & (lpdiaf->rgoAction[i].dwSemantic)) - 1;
+        DWORD type = 0x000000ff & (lpdiaf->rgoAction[i].dwSemantic >> 8);
+        DWORD genre = 0xff000000 & lpdiaf->rgoAction[i].dwSemantic;
+
+        /* Don't touch a user configured action */
+        if (lpdiaf->rgoAction[i].dwHow == DIAH_USERCONFIG) continue;
+
+        /* Only consider actions of the right genre */
+        if (lpdiaf->dwGenre != genre && genre != DIGENRE_ANY) continue;
+
+        for (j=0; j < sizeof(object_types)/sizeof(object_types[0]); j++)
+        {
+            if (type & object_types[j])
+            {
+                /* Ensure that the object exists */
+                LPDIOBJECTDATAFORMAT odf = dataformat_to_odf_by_type(This->base.data_format.wine_df, inst, object_types[j]);
+
+                if (odf != NULL)
+                {
+                    lpdiaf->rgoAction[i].dwObjID = type_map[j] | (0x0000ff00 & (inst << 8));
+                    lpdiaf->rgoAction[i].guidInstance = This->base.guid;
+                    lpdiaf->rgoAction[i].dwHow = DIAH_DEFAULT;
+
+                    has_actions = TRUE;
+
+                    /* No need to try other types if the action was already mapped */
+                    break;
+                }
+            }
+        }
+    }
+
+    if (!has_actions) return DI_NOEFFECT;
+
+    return IDirectInputDevice8WImpl_BuildActionMap(iface, lpdiaf, lpszUserName, dwFlags);
+}
+
+HRESULT WINAPI JoystickAGenericImpl_BuildActionMap(LPDIRECTINPUTDEVICE8A iface,
+                                                   LPDIACTIONFORMATA lpdiaf,
+                                                   LPCSTR lpszUserName,
+                                                   DWORD dwFlags)
+{
+    JoystickGenericImpl *This = impl_from_IDirectInputDevice8A(iface);
+    DIACTIONFORMATW diafW;
+    HRESULT hr;
+    WCHAR *lpszUserNameW = NULL;
+    int username_size;
+
+    diafW.rgoAction = HeapAlloc(GetProcessHeap(), 0, sizeof(DIACTIONW)*lpdiaf->dwNumActions);
+    _copy_diactionformatAtoW(&diafW, lpdiaf);
+
+    if (lpszUserName != NULL)
+    {
+        username_size = MultiByteToWideChar(CP_ACP, 0, lpszUserName, -1, NULL, 0);
+        lpszUserNameW = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR)*username_size);
+        MultiByteToWideChar(CP_ACP, 0, lpszUserName, -1, lpszUserNameW, username_size);
+    }
+
+    hr = JoystickWGenericImpl_BuildActionMap(&This->base.IDirectInputDevice8W_iface, &diafW, lpszUserNameW, dwFlags);
+
+    _copy_diactionformatWtoA(lpdiaf, &diafW);
+    HeapFree(GetProcessHeap(), 0, diafW.rgoAction);
+    HeapFree(GetProcessHeap(), 0, lpszUserNameW);
+
+    return hr;
+}
+
+HRESULT WINAPI JoystickWGenericImpl_SetActionMap(LPDIRECTINPUTDEVICE8W iface,
+                                                 LPDIACTIONFORMATW lpdiaf,
+                                                 LPCWSTR lpszUserName,
+                                                 DWORD dwFlags)
+{
+    JoystickGenericImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    FIXME("(%p)->(%p,%s,%08x): semi-stub !\n", iface, lpdiaf, debugstr_w(lpszUserName), dwFlags);
+
+    return _set_action_map(iface, lpdiaf, lpszUserName, dwFlags, This->base.data_format.wine_df);
+}
+
+HRESULT WINAPI JoystickAGenericImpl_SetActionMap(LPDIRECTINPUTDEVICE8A iface,
+                                                 LPDIACTIONFORMATA lpdiaf,
+                                                 LPCSTR lpszUserName,
+                                                 DWORD dwFlags)
+{
+    JoystickGenericImpl *This = impl_from_IDirectInputDevice8A(iface);
+    DIACTIONFORMATW diafW;
+    HRESULT hr;
+    WCHAR *lpszUserNameW = NULL;
+    int username_size;
+
+    diafW.rgoAction = HeapAlloc(GetProcessHeap(), 0, sizeof(DIACTIONW)*lpdiaf->dwNumActions);
+    _copy_diactionformatAtoW(&diafW, lpdiaf);
+
+    if (lpszUserName != NULL)
+    {
+        username_size = MultiByteToWideChar(CP_ACP, 0, lpszUserName, -1, NULL, 0);
+        lpszUserNameW = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR)*username_size);
+        MultiByteToWideChar(CP_ACP, 0, lpszUserName, -1, lpszUserNameW, username_size);
+    }
+
+    hr = JoystickWGenericImpl_SetActionMap(&This->base.IDirectInputDevice8W_iface, &diafW, lpszUserNameW, dwFlags);
+
+    HeapFree(GetProcessHeap(), 0, diafW.rgoAction);
+    HeapFree(GetProcessHeap(), 0, lpszUserNameW);
+
+    return hr;
+}
+
+/*
+ * This maps the read value (from the input event) to a value in the
+ * 'wanted' range.
+ * Notes:
+ *   Dead zone is in % multiplied by a 100 (range 0..10000)
+ */
+LONG joystick_map_axis(ObjProps *props, int val)
+{
+    LONG ret;
+    LONG dead_zone = MulDiv( props->lDeadZone, props->lDevMax - props->lDevMin, 10000 );
+    LONG dev_range = props->lDevMax - props->lDevMin - dead_zone;
+
+    /* Center input */
+    val -= (props->lDevMin + props->lDevMax) / 2;
+
+    /* Remove dead zone */
+    if (abs( val ) <= dead_zone / 2)
+        val = 0;
+    else
+        val = val < 0 ? val + dead_zone / 2 : val - dead_zone / 2;
+
+    /* Scale and map the value from the device range into the required range */
+    ret = MulDiv( val, props->lMax - props->lMin, dev_range ) +
+          (props->lMin + props->lMax) / 2;
+
+    /* Clamp in case or rounding errors */
+    if      (ret > props->lMax) ret = props->lMax;
+    else if (ret < props->lMin) ret = props->lMin;
+
+    TRACE( "(%d <%d> %d) -> (%d <%d> %d): val=%d ret=%d\n",
+           props->lDevMin, dead_zone, props->lDevMax,
+           props->lMin, props->lDeadZone, props->lMax,
+           val, ret );
+
+    return ret;
+}
+
+/*
+ * Maps POV x & y event values to a DX "clock" position:
+ *         0
+ *   31500    4500
+ * 27000  -1    9000
+ *   22500   13500
+ *       18000
+ */
+DWORD joystick_map_pov(const POINTL *p)
+{
+    if (p->x > 0)
+        return p->y < 0 ?  4500 : !p->y ?  9000 : 13500;
+    else if (p->x < 0)
+        return p->y < 0 ? 31500 : !p->y ? 27000 : 22500;
+    else
+        return p->y < 0 ?     0 : !p->y ?    -1 : 18000;
+}
+
+/*
+ * Setup the dinput options.
+ */
+
+HRESULT setup_dinput_options(JoystickGenericImpl *This, const int *default_axis_map)
+{
+    char buffer[MAX_PATH+16];
+    HKEY hkey, appkey;
+    int tokens = 0;
+    int axis = 0;
+    int pov = 0;
+
+    get_app_key(&hkey, &appkey);
+
+    /* get options */
+
+    if (!get_config_key(hkey, appkey, "DefaultDeadZone", buffer, sizeof(buffer)))
+    {
+        This->deadzone = atoi(buffer);
+        TRACE("setting default deadzone to: \"%s\" %d\n", buffer, This->deadzone);
+    }
+
+    This->axis_map = HeapAlloc(GetProcessHeap(), 0, This->device_axis_count * sizeof(int));
+    if (!This->axis_map) return DIERR_OUTOFMEMORY;
+
+    if (!get_config_key(hkey, appkey, This->name, buffer, sizeof(buffer)))
+    {
+        static const char *axis_names[] = {"X", "Y", "Z", "Rx", "Ry", "Rz",
+                                           "Slider1", "Slider2",
+                                           "POV1", "POV2", "POV3", "POV4"};
+        const char *delim = ",";
+        char * ptr;
+        TRACE("\"%s\" = \"%s\"\n", This->name, buffer);
+
+        if ((ptr = strtok(buffer, delim)) != NULL)
+        {
+            do
+            {
+                int i;
+
+                for (i = 0; i < sizeof(axis_names) / sizeof(axis_names[0]); i++)
+                {
+                    if (!strcmp(ptr, axis_names[i]))
+                    {
+                        if (!strncmp(ptr, "POV", 3))
+                        {
+                            if (pov >= 4)
+                            {
+                                WARN("Only 4 POVs supported - ignoring extra\n");
+                                i = -1;
+                            }
+                            else
+                            {
+                                /* Pov takes two axes */
+                                This->axis_map[tokens++] = i;
+                                pov++;
+                            }
+                        }
+                        else
+                        {
+                            if (axis >= 8)
+                            {
+                                FIXME("Only 8 Axes supported - ignoring extra\n");
+                                i = -1;
+                            }
+                            else
+                                axis++;
+                        }
+                        break;
+                    }
+                }
+
+                if (i == sizeof(axis_names) / sizeof(axis_names[0]))
+                {
+                    ERR("invalid joystick axis type: \"%s\"\n", ptr);
+                    i = -1;
+                }
+
+                This->axis_map[tokens] = i;
+                tokens++;
+            } while ((ptr = strtok(NULL, delim)) != NULL);
+
+            if (tokens != This->device_axis_count)
+            {
+                ERR("not all joystick axes mapped: %d axes(%d,%d), %d arguments\n",
+                    This->device_axis_count, axis, pov, tokens);
+                while (tokens < This->device_axis_count)
+                {
+                    This->axis_map[tokens] = -1;
+                    tokens++;
+                }
+            }
+        }
+    }
+    else
+    {
+        int i;
+
+        if (default_axis_map)
+        {
+            /* Use default mapping from the driver */
+            for (i = 0; i < This->device_axis_count; i++)
+            {
+                This->axis_map[i] = default_axis_map[i];
+                tokens = default_axis_map[i];
+                if (tokens < 0)
+                    continue;
+                if (tokens < 8)
+                    axis++;
+                else if (tokens < 15)
+                {
+                    i++;
+                    pov++;
+                    This->axis_map[i] = default_axis_map[i];
+                }
+            }
+        }
+        else
+        {
+            /* No config - set default mapping. */
+            for (i = 0; i < This->device_axis_count; i++)
+            {
+                if (i < 8)
+                    This->axis_map[i] = axis++;
+                else if (i < 15)
+                {
+                    This->axis_map[i++] = 8 + pov;
+                    This->axis_map[i  ] = 8 + pov++;
+                }
+                else
+                    This->axis_map[i] = -1;
+            }
+        }
+    }
+    This->devcaps.dwAxes = axis;
+    This->devcaps.dwPOVs = pov;
+
+    if (appkey) RegCloseKey(appkey);
+    if (hkey)   RegCloseKey(hkey);
+
+    return DI_OK;
+}
diff --git a/dlls/dinput8/joystick_linux.c b/dlls/dinput8/joystick_linux.c
new file mode 100644
index 0000000..963e62f
--- /dev/null
+++ b/dlls/dinput8/joystick_linux.c
@@ -0,0 +1,937 @@
+/*		DirectInput Joystick device
+ *
+ * Copyright 1998 Marcus Meissner
+ * Copyright 1998,1999 Lionel Ulmer
+ * Copyright 2000-2001 TransGaming Technologies Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/*
+ * To Do:
+ *	dead zone
+ *	force feedback
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#ifdef HAVE_SYS_TIME_H
+# include <sys/time.h>
+#endif
+#include <fcntl.h>
+#ifdef HAVE_SYS_IOCTL_H
+# include <sys/ioctl.h>
+#endif
+#include <errno.h>
+#ifdef HAVE_LINUX_IOCTL_H
+# include <linux/ioctl.h>
+#endif
+#ifdef HAVE_LINUX_JOYSTICK_H
+# include <linux/joystick.h>
+# undef SW_MAX
+#endif
+#ifdef HAVE_SYS_POLL_H
+# include <sys/poll.h>
+#endif
+
+#include "wine/debug.h"
+#include "wine/unicode.h"
+#include "windef.h"
+#include "winbase.h"
+#include "winerror.h"
+#include "dinput.h"
+
+#include "dinput_private.h"
+#include "device_private.h"
+#include "joystick_private.h"
+
+#ifdef HAVE_LINUX_22_JOYSTICK_API
+
+WINE_DEFAULT_DEBUG_CHANNEL(dinput);
+
+#define JOYDEV_NEW "/dev/input/js"
+#define JOYDEV_OLD "/dev/js"
+#define JOYDEVDRIVER " (js)"
+
+struct JoyDev
+{
+    char device[MAX_PATH];
+    char name[MAX_PATH];
+    GUID guid_product;
+
+    BYTE axis_count;
+    BYTE button_count;
+    int  *dev_axes_map;
+
+    WORD vendor_id, product_id, bus_type;
+};
+
+typedef struct JoystickImpl JoystickImpl;
+static const IDirectInputDevice8AVtbl JoystickAvt;
+static const IDirectInputDevice8WVtbl JoystickWvt;
+struct JoystickImpl
+{
+        struct JoystickGenericImpl generic;
+
+        struct JoyDev                  *joydev;
+
+	/* joystick private */
+	int				joyfd;
+        POINTL                          povs[4];
+};
+
+static inline JoystickImpl *impl_from_IDirectInputDevice8A(IDirectInputDevice8A *iface)
+{
+    return CONTAINING_RECORD(CONTAINING_RECORD(CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8A_iface),
+           JoystickGenericImpl, base), JoystickImpl, generic);
+}
+static inline JoystickImpl *impl_from_IDirectInputDevice8W(IDirectInputDevice8W *iface)
+{
+    return CONTAINING_RECORD(CONTAINING_RECORD(CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8W_iface),
+           JoystickGenericImpl, base), JoystickImpl, generic);
+}
+
+static inline IDirectInputDevice8W *IDirectInputDevice8W_from_impl(JoystickImpl *This)
+{
+    return &This->generic.base.IDirectInputDevice8W_iface;
+}
+
+static const GUID DInput_Wine_Joystick_GUID = { /* 9e573ed9-7734-11d2-8d4a-23903fb6bdf7 */
+  0x9e573ed9,
+  0x7734,
+  0x11d2,
+  {0x8d, 0x4a, 0x23, 0x90, 0x3f, 0xb6, 0xbd, 0xf7}
+};
+
+/*
+ * Construct the GUID in the same way of Windows doing this.
+ * Data1 is concatenation of productid and vendorid.
+ * Data2 and Data3 are NULL.
+ * Data4 seems to be a constant.
+ */
+static const GUID DInput_Wine_Joystick_Constant_Part_GUID = {
+  0x000000000,
+  0x0000,
+  0x0000,
+  {0x00, 0x00, 0x50, 0x49, 0x44, 0x56, 0x49, 0x44}
+};
+
+#define MAX_JOYSTICKS 64
+static INT joystick_devices_count = -1;
+static struct JoyDev *joystick_devices;
+
+static void joy_polldev(LPDIRECTINPUTDEVICE8A iface);
+
+#define SYS_PATH_FORMAT "/sys/class/input/js%d/device/id/%s"
+static BOOL read_sys_id_variable(int index, const char *property, WORD *value)
+{
+    char sys_path[sizeof(SYS_PATH_FORMAT) + 16], id_str[5];
+    int sys_fd;
+    BOOL ret = FALSE;
+
+    sprintf(sys_path, SYS_PATH_FORMAT, index, property);
+    if ((sys_fd = open(sys_path, O_RDONLY)) != -1)
+    {
+        if (read(sys_fd, id_str, 4) == 4)
+        {
+            id_str[4] = '\0';
+            *value = strtol(id_str, NULL, 16);
+            ret = TRUE;
+        }
+
+        close(sys_fd);
+    }
+    return ret;
+}
+#undef SYS_PATH_FORMAT
+
+static INT find_joystick_devices(void)
+{
+    INT i;
+
+    if (joystick_devices_count != -1) return joystick_devices_count;
+
+    joystick_devices_count = 0;
+    for (i = 0; i < MAX_JOYSTICKS; i++)
+    {
+        int fd;
+        struct JoyDev joydev, *new_joydevs;
+        BYTE axes_map[ABS_MAX + 1];
+
+        snprintf(joydev.device, sizeof(joydev.device), "%s%d", JOYDEV_NEW, i);
+        if ((fd = open(joydev.device, O_RDONLY)) == -1)
+        {
+            snprintf(joydev.device, sizeof(joydev.device), "%s%d", JOYDEV_OLD, i);
+            if ((fd = open(joydev.device, O_RDONLY)) == -1) continue;
+        }
+
+        strcpy(joydev.name, "Wine Joystick");
+#if defined(JSIOCGNAME)
+        if (ioctl(fd, JSIOCGNAME(sizeof(joydev.name) - sizeof(JOYDEVDRIVER)), joydev.name) < 0)
+            WARN("ioctl(%s,JSIOCGNAME) failed: %s\n", joydev.device, strerror(errno));
+#endif
+
+        /* Append driver name */
+        strcat(joydev.name, JOYDEVDRIVER);
+
+        if (device_disabled_registry(joydev.name)) {
+            close(fd);
+            continue;
+        }
+
+#ifdef JSIOCGAXES
+        if (ioctl(fd, JSIOCGAXES, &joydev.axis_count) < 0)
+        {
+            WARN("ioctl(%s,JSIOCGAXES) failed: %s, defaulting to 2\n", joydev.device, strerror(errno));
+            joydev.axis_count = 2;
+        }
+#else
+        WARN("reading number of joystick axes unsupported in this platform, defaulting to 2\n");
+        joydev.axis_count = 2;
+#endif
+#ifdef JSIOCGBUTTONS
+        if (ioctl(fd, JSIOCGBUTTONS, &joydev.button_count) < 0)
+        {
+            WARN("ioctl(%s,JSIOCGBUTTONS) failed: %s, defaulting to 2\n", joydev.device, strerror(errno));
+            joydev.button_count = 2;
+        }
+#else
+        WARN("reading number of joystick buttons unsupported in this platform, defaulting to 2\n");
+        joydev.button_count = 2;
+#endif
+
+        if (ioctl(fd, JSIOCGAXMAP, axes_map) < 0)
+        {
+            WARN("ioctl(%s,JSIOCGAXMAP) failed: %s\n", joydev.device, strerror(errno));
+            joydev.dev_axes_map = NULL;
+        }
+        else
+            if ((joydev.dev_axes_map = HeapAlloc(GetProcessHeap(), 0, joydev.axis_count * sizeof(int))))
+            {
+                INT j, found_axes = 0;
+
+                /* Remap to DI numbers */
+                for (j = 0; j < joydev.axis_count; j++)
+                {
+                    if (axes_map[j] < 8)
+                    {
+                        /* Axis match 1-to-1 */
+                        joydev.dev_axes_map[j] = j;
+                        found_axes++;
+                    }
+                    else if (axes_map[j] == 16 ||
+                             axes_map[j] == 17)
+                    {
+                        /* POV axis */
+                        joydev.dev_axes_map[j] = 8;
+                        found_axes++;
+                    }
+                    else
+                        joydev.dev_axes_map[j] = -1;
+                }
+
+                /* If no axes were configured but there are axes assume a 1-to-1 (wii controller) */
+                if (joydev.axis_count && !found_axes)
+                {
+                    int axes_limit = min(joydev.axis_count, 8); /* generic driver limit */
+
+                    ERR("Incoherent joystick data, advertised %d axes, detected 0. Assuming 1-to-1.\n",
+                        joydev.axis_count);
+                    for (j = 0; j < axes_limit; j++)
+                        joydev.dev_axes_map[j] = j;
+
+                    joydev.axis_count = axes_limit;
+                }
+            }
+
+        /* Find vendor_id and product_id in sysfs */
+        joydev.vendor_id  = 0;
+        joydev.product_id = 0;
+
+        read_sys_id_variable(i, "vendor", &joydev.vendor_id);
+        read_sys_id_variable(i, "product", &joydev.product_id);
+        read_sys_id_variable(i, "bustype", &joydev.bus_type);
+
+        if (joydev.vendor_id == 0 || joydev.product_id == 0)
+        {
+            joydev.guid_product = DInput_Wine_Joystick_GUID;
+        }
+        else
+        {
+            /* Concatenate product_id with vendor_id to mimic Windows behaviour */
+            joydev.guid_product       = DInput_Wine_Joystick_Constant_Part_GUID;
+            joydev.guid_product.Data1 = MAKELONG(joydev.vendor_id, joydev.product_id);
+        }
+
+        close(fd);
+
+        if (!joystick_devices_count)
+            new_joydevs = HeapAlloc(GetProcessHeap(), 0, sizeof(struct JoyDev));
+        else
+            new_joydevs = HeapReAlloc(GetProcessHeap(), 0, joystick_devices,
+                                      (joystick_devices_count + 1) * sizeof(struct JoyDev));
+        if (!new_joydevs) continue;
+
+        TRACE("Found a joystick on %s: %s\n  with %d axes and %d buttons\n", joydev.device,
+              joydev.name, joydev.axis_count, joydev.button_count);
+
+        joystick_devices = new_joydevs;
+        joystick_devices[joystick_devices_count++] = joydev;
+    }
+
+    return joystick_devices_count;
+}
+
+static void fill_joystick_dideviceinstanceW(LPDIDEVICEINSTANCEW lpddi, DWORD version, int id)
+{
+    DWORD dwSize = lpddi->dwSize;
+
+    TRACE("%d %p\n", dwSize, lpddi);
+    memset(lpddi, 0, dwSize);
+
+    /* Return joystick */
+    lpddi->dwSize = dwSize;
+    lpddi->guidInstance = DInput_Wine_Joystick_GUID;
+    lpddi->guidInstance.Data3 = id;
+    lpddi->guidProduct = joystick_devices[id].guid_product;
+    /* we only support traditional joysticks for now */
+    if (version >= 0x0800)
+        lpddi->dwDevType = DI8DEVTYPE_JOYSTICK | (DI8DEVTYPEJOYSTICK_STANDARD << 8);
+    else
+        lpddi->dwDevType = DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_TRADITIONAL << 8);
+
+    /* Assume the joystick as HID if it is attached to USB bus and has a valid VID/PID */
+    if (joystick_devices[id].bus_type == BUS_USB &&
+        joystick_devices[id].vendor_id && joystick_devices[id].product_id)
+    {
+        lpddi->dwDevType |= DIDEVTYPE_HID;
+        lpddi->wUsagePage = 0x01; /* Desktop */
+        if (lpddi->dwDevType == DI8DEVTYPE_JOYSTICK || lpddi->dwDevType == DIDEVTYPE_JOYSTICK)
+            lpddi->wUsage = 0x04; /* Joystick */
+        else
+            lpddi->wUsage = 0x05; /* Game Pad */
+    }
+
+    MultiByteToWideChar(CP_ACP, 0, joystick_devices[id].name, -1, lpddi->tszInstanceName, MAX_PATH);
+    MultiByteToWideChar(CP_ACP, 0, joystick_devices[id].name, -1, lpddi->tszProductName, MAX_PATH);
+    lpddi->guidFFDriver = GUID_NULL;
+}
+
+static void fill_joystick_dideviceinstanceA(LPDIDEVICEINSTANCEA lpddi, DWORD version, int id)
+{
+    DIDEVICEINSTANCEW lpddiW;
+    DWORD dwSize = lpddi->dwSize;
+
+    lpddiW.dwSize = sizeof(lpddiW);
+    fill_joystick_dideviceinstanceW(&lpddiW, version, id);
+
+    TRACE("%d %p\n", dwSize, lpddi);
+    memset(lpddi, 0, dwSize);
+
+    /* Convert W->A */
+    lpddi->dwSize = dwSize;
+    lpddi->guidInstance = lpddiW.guidInstance;
+    lpddi->guidProduct = lpddiW.guidProduct;
+    lpddi->dwDevType = lpddiW.dwDevType;
+    strcpy(lpddi->tszInstanceName, joystick_devices[id].name);
+    strcpy(lpddi->tszProductName,  joystick_devices[id].name);
+    lpddi->guidFFDriver = lpddiW.guidFFDriver;
+    lpddi->wUsagePage = lpddiW.wUsagePage;
+    lpddi->wUsage = lpddiW.wUsage;
+}
+
+static HRESULT joydev_enum_deviceA(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEA lpddi, DWORD version, int id)
+{
+    int fd = -1;
+
+    if (id >= find_joystick_devices()) return E_FAIL;
+
+    if (dwFlags & DIEDFL_FORCEFEEDBACK) {
+        WARN("force feedback not supported\n");
+        return S_FALSE;
+    }
+
+    if ((dwDevType == 0) ||
+	((dwDevType == DIDEVTYPE_JOYSTICK) && (version > 0x0300 && version < 0x0800)) ||
+	(((dwDevType == DI8DEVCLASS_GAMECTRL) || (dwDevType == DI8DEVTYPE_JOYSTICK)) && (version >= 0x0800))) {
+        /* check whether we have a joystick */
+        if ((fd = open(joystick_devices[id].device, O_RDONLY)) == -1)
+        {
+            WARN("open(%s, O_RDONLY) failed: %s\n", joystick_devices[id].device, strerror(errno));
+            return S_FALSE;
+        }
+        fill_joystick_dideviceinstanceA( lpddi, version, id );
+        close(fd);
+        TRACE("Enumerating the linux Joystick device: %s (%s)\n", joystick_devices[id].device, joystick_devices[id].name);
+        return S_OK;
+    }
+
+    return S_FALSE;
+}
+
+static HRESULT joydev_enum_deviceW(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEW lpddi, DWORD version, int id)
+{
+    int fd = -1;
+
+    if (id >= find_joystick_devices()) return E_FAIL;
+
+    if (dwFlags & DIEDFL_FORCEFEEDBACK) {
+        WARN("force feedback not supported\n");
+        return S_FALSE;
+    }
+
+    if ((dwDevType == 0) ||
+	((dwDevType == DIDEVTYPE_JOYSTICK) && (version > 0x0300 && version < 0x0800)) ||
+	(((dwDevType == DI8DEVCLASS_GAMECTRL) || (dwDevType == DI8DEVTYPE_JOYSTICK)) && (version >= 0x0800))) {
+        /* check whether we have a joystick */
+        if ((fd = open(joystick_devices[id].device, O_RDONLY)) == -1)
+        {
+            WARN("open(%s, O_RDONLY) failed: %s\n", joystick_devices[id].device, strerror(errno));
+            return S_FALSE;
+        }
+        fill_joystick_dideviceinstanceW( lpddi, version, id );
+        close(fd);
+        TRACE("Enumerating the linux Joystick device: %s (%s)\n", joystick_devices[id].device, joystick_devices[id].name);
+        return S_OK;
+    }
+
+    return S_FALSE;
+}
+
+static HRESULT alloc_device(REFGUID rguid, IDirectInputImpl *dinput,
+                            JoystickImpl **pdev, unsigned short index)
+{
+    DWORD i;
+    JoystickImpl* newDevice;
+    HRESULT hr;
+    LPDIDATAFORMAT df = NULL;
+    int idx = 0;
+    DIDEVICEINSTANCEW ddi;
+
+    TRACE("%s %p %p %hu\n", debugstr_guid(rguid), dinput, pdev, index);
+
+    newDevice = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(JoystickImpl));
+    if (newDevice == 0) {
+        WARN("out of memory\n");
+        *pdev = 0;
+        return DIERR_OUTOFMEMORY;
+    }
+
+    newDevice->joydev = &joystick_devices[index];
+    newDevice->joyfd = -1;
+    newDevice->generic.guidInstance = DInput_Wine_Joystick_GUID;
+    newDevice->generic.guidInstance.Data3 = index;
+    newDevice->generic.guidProduct = DInput_Wine_Joystick_GUID;
+    newDevice->generic.joy_polldev = joy_polldev;
+    newDevice->generic.name        = newDevice->joydev->name;
+    newDevice->generic.device_axis_count = newDevice->joydev->axis_count;
+    newDevice->generic.devcaps.dwButtons = newDevice->joydev->button_count;
+
+    if (newDevice->generic.devcaps.dwButtons > 128)
+    {
+        WARN("Can't support %d buttons. Clamping down to 128\n", newDevice->generic.devcaps.dwButtons);
+        newDevice->generic.devcaps.dwButtons = 128;
+    }
+
+    newDevice->generic.base.IDirectInputDevice8A_iface.lpVtbl = &JoystickAvt;
+    newDevice->generic.base.IDirectInputDevice8W_iface.lpVtbl = &JoystickWvt;
+    newDevice->generic.base.ref = 1;
+    newDevice->generic.base.dinput = dinput;
+    newDevice->generic.base.guid = *rguid;
+    InitializeCriticalSection(&newDevice->generic.base.crit);
+    newDevice->generic.base.crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": JoystickImpl*->generic.base.crit");
+
+    /* setup_dinput_options may change these */
+    newDevice->generic.deadzone = 0;
+
+    /* do any user specified configuration */
+    hr = setup_dinput_options(&newDevice->generic, newDevice->joydev->dev_axes_map);
+    if (hr != DI_OK)
+        goto FAILED1;
+
+    /* Create copy of default data format */
+    if (!(df = HeapAlloc(GetProcessHeap(), 0, c_dfDIJoystick2.dwSize))) goto FAILED;
+    memcpy(df, &c_dfDIJoystick2, c_dfDIJoystick2.dwSize);
+
+    df->dwNumObjs = newDevice->generic.devcaps.dwAxes + newDevice->generic.devcaps.dwPOVs + newDevice->generic.devcaps.dwButtons;
+    if (!(df->rgodf = HeapAlloc(GetProcessHeap(), 0, df->dwNumObjs * df->dwObjSize))) goto FAILED;
+
+    for (i = 0; i < newDevice->generic.device_axis_count; i++)
+    {
+        int wine_obj = newDevice->generic.axis_map[i];
+
+        if (wine_obj < 0) continue;
+
+        memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[wine_obj], df->dwObjSize);
+        if (wine_obj < 8)
+            df->rgodf[idx++].dwType = DIDFT_MAKEINSTANCE(wine_obj) | DIDFT_ABSAXIS;
+        else
+        {
+            df->rgodf[idx++].dwType = DIDFT_MAKEINSTANCE(wine_obj - 8) | DIDFT_POV;
+            i++; /* POV takes 2 axes */
+        }
+    }
+    for (i = 0; i < newDevice->generic.devcaps.dwButtons; i++)
+    {
+        memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[i + 12], df->dwObjSize);
+        df->rgodf[idx  ].pguid = &GUID_Button;
+        df->rgodf[idx++].dwType = DIDFT_MAKEINSTANCE(i) | DIDFT_PSHBUTTON;
+    }
+    newDevice->generic.base.data_format.wine_df = df;
+
+    /* initialize default properties */
+    for (i = 0; i < c_dfDIJoystick2.dwNumObjs; i++) {
+        newDevice->generic.props[i].lDevMin = -32767;
+        newDevice->generic.props[i].lDevMax = +32767;
+        newDevice->generic.props[i].lMin = 0;
+        newDevice->generic.props[i].lMax = 0xffff;
+        newDevice->generic.props[i].lDeadZone = newDevice->generic.deadzone; /* % * 1000 */
+        newDevice->generic.props[i].lSaturation = 0;
+    }
+
+    IDirectInput_AddRef(&newDevice->generic.base.dinput->IDirectInput7A_iface);
+
+    EnterCriticalSection(&dinput->crit);
+    list_add_tail(&dinput->devices_list, &newDevice->generic.base.entry);
+    LeaveCriticalSection(&dinput->crit);
+
+    newDevice->generic.devcaps.dwSize = sizeof(newDevice->generic.devcaps);
+    newDevice->generic.devcaps.dwFlags = DIDC_ATTACHED;
+
+    ddi.dwSize = sizeof(ddi);
+    fill_joystick_dideviceinstanceW(&ddi, newDevice->generic.base.dinput->dwVersion, index);
+    newDevice->generic.devcaps.dwDevType = ddi.dwDevType;
+
+    newDevice->generic.devcaps.dwFFSamplePeriod = 0;
+    newDevice->generic.devcaps.dwFFMinTimeResolution = 0;
+    newDevice->generic.devcaps.dwFirmwareRevision = 0;
+    newDevice->generic.devcaps.dwHardwareRevision = 0;
+    newDevice->generic.devcaps.dwFFDriverVersion = 0;
+
+    if (TRACE_ON(dinput)) {
+        _dump_DIDATAFORMAT(newDevice->generic.base.data_format.wine_df);
+       for (i = 0; i < (newDevice->generic.device_axis_count); i++)
+           TRACE("axis_map[%d] = %d\n", i, newDevice->generic.axis_map[i]);
+        _dump_DIDEVCAPS(&newDevice->generic.devcaps);
+    }
+
+    *pdev = newDevice;
+
+    return DI_OK;
+
+FAILED:
+    hr = DIERR_OUTOFMEMORY;
+FAILED1:
+    if (df) HeapFree(GetProcessHeap(), 0, df->rgodf);
+    HeapFree(GetProcessHeap(), 0, df);
+    release_DataFormat(&newDevice->generic.base.data_format);
+    HeapFree(GetProcessHeap(),0,newDevice->generic.axis_map);
+    HeapFree(GetProcessHeap(),0,newDevice);
+    *pdev = 0;
+
+    return hr;
+}
+
+/******************************************************************************
+  *     get_joystick_index : Get the joystick index from a given GUID
+  */
+static unsigned short get_joystick_index(REFGUID guid)
+{
+    GUID wine_joystick = DInput_Wine_Joystick_GUID;
+    GUID dev_guid = *guid;
+
+    wine_joystick.Data3 = 0;
+    dev_guid.Data3 = 0;
+
+    /* for the standard joystick GUID use index 0 */
+    if(IsEqualGUID(&GUID_Joystick,guid)) return 0;
+
+    /* for the wine joystick GUIDs use the index stored in Data3 */
+    if(IsEqualGUID(&wine_joystick, &dev_guid)) return guid->Data3;
+
+    return MAX_JOYSTICKS;
+}
+
+static HRESULT joydev_create_device(IDirectInputImpl *dinput, REFGUID rguid, REFIID riid, LPVOID *pdev, int unicode)
+{
+    unsigned short index;
+
+    TRACE("%p %s %s %p %i\n", dinput, debugstr_guid(rguid), debugstr_guid(riid), pdev, unicode);
+    find_joystick_devices();
+    *pdev = NULL;
+
+    if ((index = get_joystick_index(rguid)) < MAX_JOYSTICKS &&
+        joystick_devices_count && index < joystick_devices_count)
+    {
+        JoystickImpl *This;
+        HRESULT hr;
+
+        if (riid == NULL)
+            ;/* nothing */
+        else if (IsEqualGUID(&IID_IDirectInputDeviceA,  riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice2A, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice7A, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice8A, riid))
+        {
+            unicode = 0;
+        }
+        else if (IsEqualGUID(&IID_IDirectInputDeviceW,  riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice2W, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice7W, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice8W, riid))
+        {
+            unicode = 1;
+        }
+        else
+        {
+            WARN("no interface\n");
+            return DIERR_NOINTERFACE;
+        }
+
+        hr = alloc_device(rguid, dinput, &This, index);
+        if (!This) return hr;
+
+        if (unicode)
+            *pdev = &This->generic.base.IDirectInputDevice8W_iface;
+        else
+            *pdev = &This->generic.base.IDirectInputDevice8A_iface;
+
+        return hr;
+    }
+
+    return DIERR_DEVICENOTREG;
+}
+
+#undef MAX_JOYSTICKS
+
+const struct dinput_device joystick_linux_device = {
+  "Wine Linux joystick driver",
+  joydev_enum_deviceA,
+  joydev_enum_deviceW,
+  joydev_create_device
+};
+
+/******************************************************************************
+  *     Acquire : gets exclusive control of the joystick
+  */
+static HRESULT WINAPI JoystickLinuxWImpl_Acquire(LPDIRECTINPUTDEVICE8W iface)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+    HRESULT res;
+
+    TRACE("(%p)\n",This);
+
+    res = IDirectInputDevice2WImpl_Acquire(iface);
+    if (res != DI_OK)
+        return res;
+
+    /* open the joystick device */
+    if (This->joyfd==-1) {
+        TRACE("opening joystick device %s\n", This->joydev->device);
+
+        This->joyfd = open(This->joydev->device, O_RDONLY);
+        if (This->joyfd==-1) {
+            ERR("open(%s) failed: %s\n", This->joydev->device, strerror(errno));
+            IDirectInputDevice2WImpl_Unacquire(iface);
+            return DIERR_NOTFOUND;
+        }
+    }
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickLinuxAImpl_Acquire(LPDIRECTINPUTDEVICE8A iface)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickLinuxWImpl_Acquire(IDirectInputDevice8W_from_impl(This));
+}
+
+/******************************************************************************
+  *     GetProperty : get input device properties
+  */
+static HRESULT WINAPI JoystickLinuxWImpl_GetProperty(LPDIRECTINPUTDEVICE8W iface, REFGUID rguid, LPDIPROPHEADER pdiph)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(this=%p,%s,%p)\n", iface, debugstr_guid(rguid), pdiph);
+    _dump_DIPROPHEADER(pdiph);
+
+    if (!IS_DIPROP(rguid)) return DI_OK;
+
+    switch (LOWORD(rguid)) {
+
+        case (DWORD_PTR) DIPROP_VIDPID:
+        {
+            LPDIPROPDWORD pd = (LPDIPROPDWORD)pdiph;
+
+            if (!This->joydev->product_id || !This->joydev->vendor_id)
+                return DIERR_UNSUPPORTED;
+            pd->dwData = MAKELONG(This->joydev->vendor_id, This->joydev->product_id);
+            TRACE("DIPROP_VIDPID(%08x)\n", pd->dwData);
+            break;
+        }
+        case (DWORD_PTR) DIPROP_JOYSTICKID:
+        {
+            LPDIPROPDWORD pd = (LPDIPROPDWORD)pdiph;
+
+            pd->dwData = get_joystick_index(&This->generic.base.guid);
+            TRACE("DIPROP_JOYSTICKID(%d)\n", pd->dwData);
+            break;
+        }
+
+    default:
+        return JoystickWGenericImpl_GetProperty(iface, rguid, pdiph);
+    }
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickLinuxAImpl_GetProperty(LPDIRECTINPUTDEVICE8A iface, REFGUID rguid, LPDIPROPHEADER pdiph)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickLinuxWImpl_GetProperty(IDirectInputDevice8W_from_impl(This), rguid, pdiph);
+}
+
+/******************************************************************************
+  *     GetDeviceInfo : get information about a device's identity
+  */
+static HRESULT WINAPI JoystickLinuxAImpl_GetDeviceInfo(LPDIRECTINPUTDEVICE8A iface, LPDIDEVICEINSTANCEA ddi)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+
+    TRACE("(%p) %p\n", This, ddi);
+
+    if (ddi == NULL) return E_POINTER;
+    if ((ddi->dwSize != sizeof(DIDEVICEINSTANCE_DX3A)) &&
+        (ddi->dwSize != sizeof(DIDEVICEINSTANCEA)))
+        return DIERR_INVALIDPARAM;
+
+    fill_joystick_dideviceinstanceA( ddi, This->generic.base.dinput->dwVersion,
+                                     get_joystick_index(&This->generic.base.guid) );
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickLinuxWImpl_GetDeviceInfo(LPDIRECTINPUTDEVICE8W iface, LPDIDEVICEINSTANCEW ddi)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(%p) %p\n", This, ddi);
+
+    if (ddi == NULL) return E_POINTER;
+    if ((ddi->dwSize != sizeof(DIDEVICEINSTANCE_DX3W)) &&
+        (ddi->dwSize != sizeof(DIDEVICEINSTANCEW)))
+        return DIERR_INVALIDPARAM;
+
+    fill_joystick_dideviceinstanceW( ddi, This->generic.base.dinput->dwVersion,
+                                     get_joystick_index(&This->generic.base.guid) );
+    return DI_OK;
+}
+
+/******************************************************************************
+  *     Unacquire : frees the joystick
+  */
+static HRESULT WINAPI JoystickLinuxWImpl_Unacquire(LPDIRECTINPUTDEVICE8W iface)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+    HRESULT res;
+
+    TRACE("(%p)\n",This);
+
+    res = IDirectInputDevice2WImpl_Unacquire(iface);
+
+    if (res != DI_OK)
+        return res;
+
+    if (This->joyfd!=-1) {
+        TRACE("closing joystick device\n");
+        close(This->joyfd);
+        This->joyfd = -1;
+        return DI_OK;
+    }
+
+    return DI_NOEFFECT;
+}
+
+static HRESULT WINAPI JoystickLinuxAImpl_Unacquire(LPDIRECTINPUTDEVICE8A iface)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickLinuxWImpl_Unacquire(IDirectInputDevice8W_from_impl(This));
+}
+
+static void joy_polldev(LPDIRECTINPUTDEVICE8A iface)
+{
+    struct pollfd plfd;
+    struct js_event jse;
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+
+    TRACE("(%p)\n", This);
+
+    if (This->joyfd==-1) {
+        WARN("no device\n");
+        return;
+    }
+    while (1)
+    {
+        LONG value;
+        int inst_id = -1;
+
+	plfd.fd = This->joyfd;
+	plfd.events = POLLIN;
+	if (poll(&plfd,1,0) != 1)
+	    return;
+	/* we have one event, so we can read */
+	if (sizeof(jse)!=read(This->joyfd,&jse,sizeof(jse))) {
+	    return;
+	}
+        TRACE("js_event: type 0x%x, number %d, value %d\n",
+              jse.type,jse.number,jse.value);
+        if (jse.type & JS_EVENT_BUTTON)
+        {
+            if (jse.number >= This->generic.devcaps.dwButtons) return;
+
+            inst_id = DIDFT_MAKEINSTANCE(jse.number) | DIDFT_PSHBUTTON;
+            This->generic.js.rgbButtons[jse.number] = value = jse.value ? 0x80 : 0x00;
+        }
+        else if (jse.type & JS_EVENT_AXIS)
+        {
+            int number = This->generic.axis_map[jse.number];	/* wine format object index */
+
+            if (number < 0) return;
+            inst_id = number < 8 ?  DIDFT_MAKEINSTANCE(number) | DIDFT_ABSAXIS :
+                                    DIDFT_MAKEINSTANCE(number - 8) | DIDFT_POV;
+            value = joystick_map_axis(&This->generic.props[id_to_object(This->generic.base.data_format.wine_df, inst_id)], jse.value);
+
+            TRACE("changing axis %d => %d\n", jse.number, number);
+            switch (number)
+            {
+                case 0: This->generic.js.lX  = value; break;
+                case 1: This->generic.js.lY  = value; break;
+                case 2: This->generic.js.lZ  = value; break;
+                case 3: This->generic.js.lRx = value; break;
+                case 4: This->generic.js.lRy = value; break;
+                case 5: This->generic.js.lRz = value; break;
+                case 6: This->generic.js.rglSlider[0] = value; break;
+                case 7: This->generic.js.rglSlider[1] = value; break;
+                case 8: case 9: case 10: case 11:
+                {
+                    int idx = number - 8;
+
+                    if (jse.number % 2)
+                        This->povs[idx].y = jse.value;
+                    else
+                        This->povs[idx].x = jse.value;
+
+                    This->generic.js.rgdwPOV[idx] = value = joystick_map_pov(&This->povs[idx]);
+                    break;
+                }
+                default:
+                    WARN("axis %d not supported\n", number);
+            }
+        }
+        if (inst_id >= 0)
+            queue_event(iface, inst_id, value, GetCurrentTime(), This->generic.base.dinput->evsequence++);
+    }
+}
+
+static const IDirectInputDevice8AVtbl JoystickAvt =
+{
+	IDirectInputDevice2AImpl_QueryInterface,
+	IDirectInputDevice2AImpl_AddRef,
+        IDirectInputDevice2AImpl_Release,
+	JoystickAGenericImpl_GetCapabilities,
+        IDirectInputDevice2AImpl_EnumObjects,
+	JoystickLinuxAImpl_GetProperty,
+	JoystickAGenericImpl_SetProperty,
+	JoystickLinuxAImpl_Acquire,
+	JoystickLinuxAImpl_Unacquire,
+	JoystickAGenericImpl_GetDeviceState,
+	IDirectInputDevice2AImpl_GetDeviceData,
+	IDirectInputDevice2AImpl_SetDataFormat,
+	IDirectInputDevice2AImpl_SetEventNotification,
+	IDirectInputDevice2AImpl_SetCooperativeLevel,
+	JoystickAGenericImpl_GetObjectInfo,
+	JoystickLinuxAImpl_GetDeviceInfo,
+	IDirectInputDevice2AImpl_RunControlPanel,
+	IDirectInputDevice2AImpl_Initialize,
+	IDirectInputDevice2AImpl_CreateEffect,
+	IDirectInputDevice2AImpl_EnumEffects,
+	IDirectInputDevice2AImpl_GetEffectInfo,
+	IDirectInputDevice2AImpl_GetForceFeedbackState,
+	IDirectInputDevice2AImpl_SendForceFeedbackCommand,
+	IDirectInputDevice2AImpl_EnumCreatedEffectObjects,
+	IDirectInputDevice2AImpl_Escape,
+	JoystickAGenericImpl_Poll,
+	IDirectInputDevice2AImpl_SendDeviceData,
+	IDirectInputDevice7AImpl_EnumEffectsInFile,
+	IDirectInputDevice7AImpl_WriteEffectToFile,
+	JoystickAGenericImpl_BuildActionMap,
+	JoystickAGenericImpl_SetActionMap,
+	IDirectInputDevice8AImpl_GetImageInfo
+};
+
+static const IDirectInputDevice8WVtbl JoystickWvt =
+{
+    IDirectInputDevice2WImpl_QueryInterface,
+    IDirectInputDevice2WImpl_AddRef,
+    IDirectInputDevice2WImpl_Release,
+    JoystickWGenericImpl_GetCapabilities,
+    IDirectInputDevice2WImpl_EnumObjects,
+    JoystickLinuxWImpl_GetProperty,
+    JoystickWGenericImpl_SetProperty,
+    JoystickLinuxWImpl_Acquire,
+    JoystickLinuxWImpl_Unacquire,
+    JoystickWGenericImpl_GetDeviceState,
+    IDirectInputDevice2WImpl_GetDeviceData,
+    IDirectInputDevice2WImpl_SetDataFormat,
+    IDirectInputDevice2WImpl_SetEventNotification,
+    IDirectInputDevice2WImpl_SetCooperativeLevel,
+    JoystickWGenericImpl_GetObjectInfo,
+    JoystickLinuxWImpl_GetDeviceInfo,
+    IDirectInputDevice2WImpl_RunControlPanel,
+    IDirectInputDevice2WImpl_Initialize,
+    IDirectInputDevice2WImpl_CreateEffect,
+    IDirectInputDevice2WImpl_EnumEffects,
+    IDirectInputDevice2WImpl_GetEffectInfo,
+    IDirectInputDevice2WImpl_GetForceFeedbackState,
+    IDirectInputDevice2WImpl_SendForceFeedbackCommand,
+    IDirectInputDevice2WImpl_EnumCreatedEffectObjects,
+    IDirectInputDevice2WImpl_Escape,
+    JoystickWGenericImpl_Poll,
+    IDirectInputDevice2WImpl_SendDeviceData,
+    IDirectInputDevice7WImpl_EnumEffectsInFile,
+    IDirectInputDevice7WImpl_WriteEffectToFile,
+    JoystickWGenericImpl_BuildActionMap,
+    JoystickWGenericImpl_SetActionMap,
+    IDirectInputDevice8WImpl_GetImageInfo
+};
+
+#else  /* HAVE_LINUX_22_JOYSTICK_API */
+
+const struct dinput_device joystick_linux_device = {
+  "Wine Linux joystick driver",
+  NULL,
+  NULL,
+  NULL
+};
+
+#endif  /* HAVE_LINUX_22_JOYSTICK_API */
diff --git a/dlls/dinput8/joystick_linuxinput.c b/dlls/dinput8/joystick_linuxinput.c
new file mode 100644
index 0000000..910e755
--- /dev/null
+++ b/dlls/dinput8/joystick_linuxinput.c
@@ -0,0 +1,1526 @@
+/*		DirectInput Joystick device
+ *
+ * Copyright 1998,2000 Marcus Meissner
+ * Copyright 1998,1999 Lionel Ulmer
+ * Copyright 2000-2001 TransGaming Technologies Inc.
+ * Copyright 2005 Daniel Remenak
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include <assert.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#ifdef HAVE_SYS_TIME_H
+# include <sys/time.h>
+#endif
+#include <fcntl.h>
+#ifdef HAVE_SYS_IOCTL_H
+# include <sys/ioctl.h>
+#endif
+#include <errno.h>
+#ifdef HAVE_LINUX_INPUT_H
+# include <linux/input.h>
+# undef SW_MAX
+# if defined(EVIOCGBIT) && defined(EV_ABS) && defined(BTN_PINKIE)
+#  define HAS_PROPER_HEADER
+# endif
+#endif
+#ifdef HAVE_SYS_POLL_H
+# include <sys/poll.h>
+#endif
+
+#include "wine/debug.h"
+#include "wine/unicode.h"
+#include "wine/list.h"
+#include "windef.h"
+#include "winbase.h"
+#include "winerror.h"
+#include "winreg.h"
+#include "dinput.h"
+
+#include "dinput_private.h"
+#include "device_private.h"
+#include "joystick_private.h"
+
+#ifdef HAS_PROPER_HEADER
+
+WINE_DEFAULT_DEBUG_CHANNEL(dinput);
+
+#define EVDEVPREFIX "/dev/input/event"
+#define EVDEVDRIVER " (event)"
+
+/* Wine joystick driver object instances */
+#define WINE_JOYSTICK_MAX_AXES    8
+#define WINE_JOYSTICK_MAX_POVS    4
+#define WINE_JOYSTICK_MAX_BUTTONS 128
+
+struct wine_input_absinfo {
+    LONG value;
+    LONG minimum;
+    LONG maximum;
+    LONG fuzz;
+    LONG flat;
+};
+
+/* implemented in effect_linuxinput.c */
+HRESULT linuxinput_create_effect(int* fd, REFGUID rguid, struct list *parent_list_entry, LPDIRECTINPUTEFFECT* peff);
+HRESULT linuxinput_get_info_A(int fd, REFGUID rguid, LPDIEFFECTINFOA info);
+HRESULT linuxinput_get_info_W(int fd, REFGUID rguid, LPDIEFFECTINFOW info);
+
+static HRESULT WINAPI JoystickWImpl_SendForceFeedbackCommand(LPDIRECTINPUTDEVICE8W iface, DWORD dwFlags);
+
+typedef struct JoystickImpl JoystickImpl;
+static const IDirectInputDevice8AVtbl JoystickAvt;
+static const IDirectInputDevice8WVtbl JoystickWvt;
+
+struct JoyDev {
+	char *device;
+	char *name;
+	GUID guid;
+	GUID guid_product;
+
+        BOOL has_ff;
+        int num_effects;
+
+	/* data returned by EVIOCGBIT for caps, EV_ABS, EV_KEY, and EV_FF */
+	BYTE				evbits[(EV_MAX+7)/8];
+	BYTE				absbits[(ABS_MAX+7)/8];
+	BYTE				keybits[(KEY_MAX+7)/8];
+	BYTE				ffbits[(FF_MAX+7)/8];	
+
+	/* data returned by the EVIOCGABS() ioctl */
+        struct wine_input_absinfo       axes[ABS_MAX];
+
+        WORD vendor_id, product_id, bus_type;
+};
+
+struct JoystickImpl
+{
+        struct JoystickGenericImpl      generic;
+        struct JoyDev                  *joydev;
+
+	/* joystick private */
+	int				joyfd;
+
+	int                             dev_axes_to_di[ABS_MAX];
+        POINTL                          povs[4];
+
+	/* LUT for KEY_ to offset in rgbButtons */
+	BYTE				buttons[KEY_MAX];
+
+	/* Force feedback variables */
+        struct list                     ff_effects;
+	int				ff_state;
+	int				ff_autocenter;
+	int				ff_gain;
+};
+
+static inline JoystickImpl *impl_from_IDirectInputDevice8A(IDirectInputDevice8A *iface)
+{
+    return CONTAINING_RECORD(CONTAINING_RECORD(CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8A_iface),
+           JoystickGenericImpl, base), JoystickImpl, generic);
+}
+static inline JoystickImpl *impl_from_IDirectInputDevice8W(IDirectInputDevice8W *iface)
+{
+    return CONTAINING_RECORD(CONTAINING_RECORD(CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8W_iface),
+           JoystickGenericImpl, base), JoystickImpl, generic);
+}
+
+static inline IDirectInputDevice8W *IDirectInputDevice8W_from_impl(JoystickImpl *This)
+{
+    return &This->generic.base.IDirectInputDevice8W_iface;
+}
+
+static void fake_current_js_state(JoystickImpl *ji);
+static void find_joydevs(void);
+static void joy_polldev(LPDIRECTINPUTDEVICE8A iface);
+
+/* This GUID is slightly different from the linux joystick one. Take note. */
+static const GUID DInput_Wine_Joystick_Base_GUID = { /* 9e573eda-7734-11d2-8d4a-23903fb6bdf7 */
+  0x9e573eda,
+  0x7734,
+  0x11d2,
+  {0x8d, 0x4a, 0x23, 0x90, 0x3f, 0xb6, 0xbd, 0xf7}
+};
+
+/*
+ * Construct the GUID in the same way of Windows doing this.
+ * Data1 is concatenation of productid and vendorid.
+ * Data2 and Data3 are NULL.
+ * Data4 seems to be a constant.
+ */
+static const GUID DInput_Wine_Joystick_Constant_Part_GUID = {
+  0x000000000,
+  0x0000,
+  0x0000,
+  {0x00, 0x00, 0x50, 0x49, 0x44, 0x56, 0x49, 0x44}
+};
+
+#define test_bit(arr,bit) (((BYTE*)(arr))[(bit)>>3]&(1<<((bit)&7)))
+
+#define MAX_JOYDEV 64
+
+static int have_joydevs = -1;
+static struct JoyDev *joydevs = NULL;
+
+static void find_joydevs(void)
+{
+    int i;
+
+    if (InterlockedCompareExchange(&have_joydevs, 0, -1) != -1)
+        /* Someone beat us to it */
+        return;
+
+    for (i = 0; i < MAX_JOYDEV; i++)
+    {
+        char buf[MAX_PATH];
+        struct JoyDev joydev = {0};
+        int fd;
+        BOOL no_ff_check = FALSE;
+        int j;
+        struct JoyDev *new_joydevs;
+        struct input_id device_id = {0};
+
+        snprintf(buf, sizeof(buf), EVDEVPREFIX"%d", i);
+
+        if ((fd = open(buf, O_RDWR)) == -1)
+        {
+            fd = open(buf, O_RDONLY);
+            no_ff_check = TRUE;
+        }
+
+        if (fd == -1)
+        {
+            WARN("Failed to open \"%s\": %d %s\n", buf, errno, strerror(errno));
+            continue;
+        }
+
+        if (ioctl(fd, EVIOCGBIT(0, sizeof(joydev.evbits)), joydev.evbits) == -1)
+        {
+            WARN("ioctl(EVIOCGBIT, 0) failed: %d %s\n", errno, strerror(errno));
+            close(fd);
+            continue;
+        }
+        if (ioctl(fd, EVIOCGBIT(EV_ABS, sizeof(joydev.absbits)), joydev.absbits) == -1)
+        {
+            WARN("ioctl(EVIOCGBIT, EV_ABS) failed: %d %s\n", errno, strerror(errno));
+            close(fd);
+            continue;
+        }
+        if (ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(joydev.keybits)), joydev.keybits) == -1)
+        {
+            WARN("ioctl(EVIOCGBIT, EV_KEY) failed: %d %s\n", errno, strerror(errno));
+            close(fd);
+            continue;
+        }
+
+        /* A true joystick has at least axis X and Y, and at least 1
+         * button. copied from linux/drivers/input/joydev.c */
+        if (!test_bit(joydev.absbits, ABS_X) || !test_bit(joydev.absbits, ABS_Y) ||
+            !(test_bit(joydev.keybits, BTN_TRIGGER) ||
+              test_bit(joydev.keybits, BTN_A) ||
+              test_bit(joydev.keybits, BTN_1)))
+        {
+            close(fd);
+            continue;
+        }
+
+        if (!(joydev.device = HeapAlloc(GetProcessHeap(), 0, strlen(buf) + 1)))
+        {
+            close(fd);
+            continue;
+        }
+        strcpy(joydev.device, buf);
+
+        buf[MAX_PATH - 1] = 0;
+        if (ioctl(fd, EVIOCGNAME(MAX_PATH - 1), buf) != -1 &&
+            (joydev.name = HeapAlloc(GetProcessHeap(), 0, strlen(buf) + strlen(EVDEVDRIVER) + 1)))
+        {
+            strcpy(joydev.name, buf);
+            /* Append driver name */
+            strcat(joydev.name, EVDEVDRIVER);
+        }
+        else
+            joydev.name = joydev.device;
+
+        if (device_disabled_registry(joydev.name)) {
+            close(fd);
+            HeapFree(GetProcessHeap(), 0, joydev.name);
+            if (joydev.name != joydev.device)
+                HeapFree(GetProcessHeap(), 0, joydev.device);
+            continue;
+        }
+
+        joydev.guid = DInput_Wine_Joystick_Base_GUID;
+        joydev.guid.Data3 += have_joydevs;
+
+        TRACE("Found a joystick on %s: %s (%s)\n",
+            joydev.device, joydev.name, 
+            debugstr_guid(&joydev.guid)
+            );
+
+#ifdef HAVE_STRUCT_FF_EFFECT_DIRECTION
+        if (!no_ff_check &&
+            test_bit(joydev.evbits, EV_FF) &&
+            ioctl(fd, EVIOCGBIT(EV_FF, sizeof(joydev.ffbits)), joydev.ffbits) != -1 &&
+            ioctl(fd, EVIOCGEFFECTS, &joydev.num_effects) != -1 &&
+            joydev.num_effects > 0)
+        {
+	    TRACE(" ... with force feedback\n");
+            joydev.has_ff = TRUE;
+        }
+#endif
+
+        for (j = 0; j < ABS_MAX;j ++)
+        {
+            if (!test_bit(joydev.absbits, j)) continue;
+            if (ioctl(fd, EVIOCGABS(j), &(joydev.axes[j])) != -1)
+            {
+	      TRACE(" ... with axis %d: cur=%d, min=%d, max=%d, fuzz=%d, flat=%d\n",
+		  j,
+		  joydev.axes[j].value,
+		  joydev.axes[j].minimum,
+		  joydev.axes[j].maximum,
+		  joydev.axes[j].fuzz,
+		  joydev.axes[j].flat
+		  );
+	    }
+	}
+
+        if (ioctl(fd, EVIOCGID, &device_id) == -1)
+        {
+            WARN("ioctl(EVIOCGID) failed: %d %s\n", errno, strerror(errno));
+            joydev.guid_product = DInput_Wine_Joystick_Base_GUID;
+        }
+        else
+        {
+            joydev.vendor_id = device_id.vendor;
+            joydev.product_id = device_id.product;
+            joydev.bus_type = device_id.bustype;
+
+            /* Concatenate product_id with vendor_id to mimic Windows behaviour */
+            joydev.guid_product       = DInput_Wine_Joystick_Constant_Part_GUID;
+            joydev.guid_product.Data1 = MAKELONG(joydev.vendor_id, joydev.product_id);
+        }
+
+        if (!have_joydevs)
+            new_joydevs = HeapAlloc(GetProcessHeap(), 0, sizeof(struct JoyDev));
+        else
+            new_joydevs = HeapReAlloc(GetProcessHeap(), 0, joydevs, (1 + have_joydevs) * sizeof(struct JoyDev));
+
+        if (!new_joydevs)
+        {
+            close(fd);
+            continue;
+        }
+        joydevs = new_joydevs;
+        joydevs[have_joydevs] = joydev;
+        have_joydevs++;
+
+        close(fd);
+    }
+}
+
+static void fill_joystick_dideviceinstanceW(LPDIDEVICEINSTANCEW lpddi, DWORD version, int id)
+{
+    DWORD dwSize = lpddi->dwSize;
+
+    TRACE("%d %p\n", dwSize, lpddi);
+    memset(lpddi, 0, dwSize);
+
+    lpddi->dwSize       = dwSize;
+    lpddi->guidInstance = joydevs[id].guid;
+    lpddi->guidProduct  = joydevs[id].guid_product;
+    lpddi->guidFFDriver = GUID_NULL;
+
+    if (version >= 0x0800)
+        lpddi->dwDevType = DI8DEVTYPE_JOYSTICK | (DI8DEVTYPEJOYSTICK_STANDARD << 8);
+    else
+        lpddi->dwDevType = DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_TRADITIONAL << 8);
+
+    /* Assume the joystick as HID if it is attached to USB bus and has a valid VID/PID */
+    if (joydevs[id].bus_type == BUS_USB &&
+        joydevs[id].vendor_id && joydevs[id].product_id)
+    {
+        lpddi->dwDevType |= DIDEVTYPE_HID;
+        lpddi->wUsagePage = 0x01; /* Desktop */
+        if (lpddi->dwDevType == DI8DEVTYPE_JOYSTICK || lpddi->dwDevType == DIDEVTYPE_JOYSTICK)
+            lpddi->wUsage = 0x04; /* Joystick */
+        else
+            lpddi->wUsage = 0x05; /* Game Pad */
+    }
+
+    MultiByteToWideChar(CP_ACP, 0, joydevs[id].name, -1, lpddi->tszInstanceName, MAX_PATH);
+    MultiByteToWideChar(CP_ACP, 0, joydevs[id].name, -1, lpddi->tszProductName, MAX_PATH);
+}
+
+static void fill_joystick_dideviceinstanceA(LPDIDEVICEINSTANCEA lpddi, DWORD version, int id)
+{
+    DIDEVICEINSTANCEW lpddiW;
+    DWORD dwSize = lpddi->dwSize;
+
+    lpddiW.dwSize = sizeof(lpddiW);
+    fill_joystick_dideviceinstanceW(&lpddiW, version, id);
+
+    TRACE("%d %p\n", dwSize, lpddi);
+    memset(lpddi, 0, dwSize);
+
+    /* Convert W->A */
+    lpddi->dwSize = dwSize;
+    lpddi->guidInstance = lpddiW.guidInstance;
+    lpddi->guidProduct = lpddiW.guidProduct;
+    lpddi->dwDevType = lpddiW.dwDevType;
+    strcpy(lpddi->tszInstanceName, joydevs[id].name);
+    strcpy(lpddi->tszProductName,  joydevs[id].name);
+    lpddi->guidFFDriver = lpddiW.guidFFDriver;
+    lpddi->wUsagePage = lpddiW.wUsagePage;
+    lpddi->wUsage = lpddiW.wUsage;
+}
+
+static HRESULT joydev_enum_deviceA(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEA lpddi, DWORD version, int id)
+{
+  find_joydevs();
+
+  if (id >= have_joydevs) {
+    return E_FAIL;
+  }
+
+  if (!((dwDevType == 0) ||
+        ((dwDevType == DIDEVTYPE_JOYSTICK) && (version > 0x0300 && version < 0x0800)) ||
+        (((dwDevType == DI8DEVCLASS_GAMECTRL) || (dwDevType == DI8DEVTYPE_JOYSTICK)) && (version >= 0x0800))))
+    return S_FALSE;
+
+#ifndef HAVE_STRUCT_FF_EFFECT_DIRECTION
+  if (dwFlags & DIEDFL_FORCEFEEDBACK)
+    return S_FALSE;
+#endif
+
+  if (!(dwFlags & DIEDFL_FORCEFEEDBACK) || joydevs[id].has_ff) {
+    fill_joystick_dideviceinstanceA(lpddi, version, id);
+    return S_OK;
+  }
+  return S_FALSE;
+}
+
+static HRESULT joydev_enum_deviceW(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEW lpddi, DWORD version, int id)
+{
+  find_joydevs();
+
+  if (id >= have_joydevs) {
+    return E_FAIL;
+  }
+
+  if (!((dwDevType == 0) ||
+        ((dwDevType == DIDEVTYPE_JOYSTICK) && (version > 0x0300 && version < 0x0800)) ||
+        (((dwDevType == DI8DEVCLASS_GAMECTRL) || (dwDevType == DI8DEVTYPE_JOYSTICK)) && (version >= 0x0800))))
+    return S_FALSE;
+
+#ifndef HAVE_STRUCT_FF_EFFECT_DIRECTION
+  if (dwFlags & DIEDFL_FORCEFEEDBACK)
+    return S_FALSE;
+#endif
+
+  if (!(dwFlags & DIEDFL_FORCEFEEDBACK) || joydevs[id].has_ff) {
+    fill_joystick_dideviceinstanceW(lpddi, version, id);
+    return S_OK;
+  }
+  return S_FALSE;
+}
+
+static JoystickImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput, unsigned short index)
+{
+    JoystickImpl* newDevice;
+    LPDIDATAFORMAT df = NULL;
+    int i, idx = 0;
+    int default_axis_map[WINE_JOYSTICK_MAX_AXES + WINE_JOYSTICK_MAX_POVS*2];
+    DIDEVICEINSTANCEW ddi;
+
+    newDevice = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(JoystickImpl));
+    if (!newDevice) return NULL;
+
+    newDevice->generic.base.IDirectInputDevice8A_iface.lpVtbl = &JoystickAvt;
+    newDevice->generic.base.IDirectInputDevice8W_iface.lpVtbl = &JoystickWvt;
+    newDevice->generic.base.ref    = 1;
+    newDevice->generic.base.guid   = *rguid;
+    newDevice->generic.base.dinput = dinput;
+    newDevice->generic.joy_polldev = joy_polldev;
+    newDevice->joyfd       = -1;
+    newDevice->joydev      = &joydevs[index];
+    newDevice->generic.name        = newDevice->joydev->name;
+    list_init(&newDevice->ff_effects);
+#ifdef HAVE_STRUCT_FF_EFFECT_DIRECTION
+    newDevice->ff_state    = FF_STATUS_STOPPED;
+#endif
+    /* There is no way in linux to query force feedback autocenter status.
+       Instead, track it with ff_autocenter, and assume it's initially
+       enabled. */
+    newDevice->ff_autocenter = 1;
+    newDevice->ff_gain = 0xFFFF;
+    InitializeCriticalSection(&newDevice->generic.base.crit);
+    newDevice->generic.base.crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": JoystickImpl*->base.crit");
+
+    /* Count number of available axes - supported Axis & POVs */
+    for (i = 0; i < ABS_MAX; i++)
+    {
+        if (i < WINE_JOYSTICK_MAX_AXES &&
+            test_bit(newDevice->joydev->absbits, i))
+        {
+            newDevice->generic.device_axis_count++;
+            newDevice->dev_axes_to_di[i] = idx;
+            newDevice->generic.props[idx].lDevMin = newDevice->joydev->axes[i].minimum;
+            newDevice->generic.props[idx].lDevMax = newDevice->joydev->axes[i].maximum;
+            default_axis_map[idx] = i;
+            idx++;
+        }
+        else
+            newDevice->dev_axes_to_di[i] = -1;
+    }
+
+    for (i = 0; i < WINE_JOYSTICK_MAX_POVS; i++)
+    {
+        if (test_bit(newDevice->joydev->absbits, ABS_HAT0X + i * 2) &&
+            test_bit(newDevice->joydev->absbits, ABS_HAT0Y + i * 2))
+        {
+            newDevice->generic.device_axis_count += 2;
+            newDevice->generic.props[idx  ].lDevMin = newDevice->joydev->axes[ABS_HAT0X + i * 2].minimum;
+            newDevice->generic.props[idx  ].lDevMax = newDevice->joydev->axes[ABS_HAT0X + i * 2].maximum;
+            newDevice->dev_axes_to_di[ABS_HAT0X + i * 2] = idx;
+            newDevice->generic.props[idx+1].lDevMin = newDevice->joydev->axes[ABS_HAT0Y + i * 2].minimum;
+            newDevice->generic.props[idx+1].lDevMax = newDevice->joydev->axes[ABS_HAT0Y + i * 2].maximum;
+            newDevice->dev_axes_to_di[ABS_HAT0Y + i * 2] = idx + 1;
+
+            default_axis_map[idx] = default_axis_map[idx + 1] = WINE_JOYSTICK_MAX_AXES + i;
+            idx += 2;
+        }
+        else
+            newDevice->dev_axes_to_di[ABS_HAT0X + i * 2] = newDevice->dev_axes_to_di[ABS_HAT0Y + i * 2] = -1;
+    }
+
+    /* do any user specified configuration */
+    if (setup_dinput_options(&newDevice->generic, default_axis_map) != DI_OK) goto failed;
+
+    /* Create copy of default data format */
+    if (!(df = HeapAlloc(GetProcessHeap(), 0, c_dfDIJoystick2.dwSize))) goto failed;
+    memcpy(df, &c_dfDIJoystick2, c_dfDIJoystick2.dwSize);
+    if (!(df->rgodf = HeapAlloc(GetProcessHeap(), 0, df->dwNumObjs * df->dwObjSize))) goto failed;
+
+
+    /* Construct internal data format */
+
+    /* Supported Axis & POVs */
+    for (i = 0, idx = 0; i < newDevice->generic.device_axis_count; i++)
+    {
+        int wine_obj = newDevice->generic.axis_map[i];
+
+        if (wine_obj < 0) continue;
+
+        memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[wine_obj], df->dwObjSize);
+        if (wine_obj < 8)
+            df->rgodf[idx].dwType = DIDFT_MAKEINSTANCE(wine_obj) | DIDFT_ABSAXIS;
+        else
+        {
+            df->rgodf[idx].dwType = DIDFT_MAKEINSTANCE(wine_obj - 8) | DIDFT_POV;
+            i++; /* POV takes 2 axes */
+        }
+
+        newDevice->generic.props[idx].lMin        = 0;
+        newDevice->generic.props[idx].lMax        = 0xffff;
+        newDevice->generic.props[idx].lSaturation = 0;
+        newDevice->generic.props[idx].lDeadZone   = newDevice->generic.deadzone;
+
+        /* Linux supports force-feedback on X & Y axes only */
+        if (newDevice->joydev->has_ff && (i == 0 || i == 1))
+            df->rgodf[idx].dwFlags |= DIDOI_FFACTUATOR;
+
+        idx++;
+    }
+
+    /* Buttons can be anywhere, so check all */
+    for (i = 0; i < KEY_MAX && newDevice->generic.devcaps.dwButtons < WINE_JOYSTICK_MAX_BUTTONS; i++)
+    {
+        if (!test_bit(newDevice->joydev->keybits, i)) continue;
+
+        memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[newDevice->generic.devcaps.dwButtons + 12], df->dwObjSize);
+        newDevice->buttons[i] = 0x80 | newDevice->generic.devcaps.dwButtons;
+        df->rgodf[idx  ].pguid = &GUID_Button;
+        df->rgodf[idx++].dwType = DIDFT_MAKEINSTANCE(newDevice->generic.devcaps.dwButtons++) | DIDFT_PSHBUTTON;
+    }
+    df->dwNumObjs = idx;
+    newDevice->generic.base.data_format.wine_df = df;
+
+    fake_current_js_state(newDevice);
+
+    /* Fill the caps */
+    newDevice->generic.devcaps.dwSize = sizeof(newDevice->generic.devcaps);
+    newDevice->generic.devcaps.dwFlags = DIDC_ATTACHED;
+
+    ddi.dwSize = sizeof(ddi);
+    fill_joystick_dideviceinstanceW(&ddi, newDevice->generic.base.dinput->dwVersion, index);
+    newDevice->generic.devcaps.dwDevType = ddi.dwDevType;
+
+    if (newDevice->joydev->has_ff)
+        newDevice->generic.devcaps.dwFlags |= DIDC_FORCEFEEDBACK;
+
+    IDirectInput_AddRef(&newDevice->generic.base.dinput->IDirectInput7A_iface);
+
+    EnterCriticalSection(&dinput->crit);
+    list_add_tail(&dinput->devices_list, &newDevice->generic.base.entry);
+    LeaveCriticalSection(&dinput->crit);
+
+    return newDevice;
+
+failed:
+    if (df) HeapFree(GetProcessHeap(), 0, df->rgodf);
+    HeapFree(GetProcessHeap(), 0, df);
+    HeapFree(GetProcessHeap(), 0, newDevice->generic.axis_map);
+    HeapFree(GetProcessHeap(), 0, newDevice);
+    return NULL;
+}
+
+/******************************************************************************
+  *     get_joystick_index : Get the joystick index from a given GUID
+  */
+static unsigned short get_joystick_index(REFGUID guid)
+{
+    GUID wine_joystick = DInput_Wine_Joystick_Base_GUID;
+    GUID dev_guid = *guid;
+
+    wine_joystick.Data3 = 0;
+    dev_guid.Data3 = 0;
+
+    /* for the standard joystick GUID use index 0 */
+    if(IsEqualGUID(&GUID_Joystick,guid)) return 0;
+
+    /* for the wine joystick GUIDs use the index stored in Data3 */
+    if(IsEqualGUID(&wine_joystick, &dev_guid)) return guid->Data3 - DInput_Wine_Joystick_Base_GUID.Data3;
+
+    return MAX_JOYDEV;
+}
+
+static HRESULT joydev_create_device(IDirectInputImpl *dinput, REFGUID rguid, REFIID riid, LPVOID *pdev, int unicode)
+{
+    unsigned short index;
+
+    TRACE("%p %s %s %p %i\n", dinput, debugstr_guid(rguid), debugstr_guid(riid), pdev, unicode);
+    find_joydevs();
+    *pdev = NULL;
+
+    if ((index = get_joystick_index(rguid)) < MAX_JOYDEV &&
+        have_joydevs && index < have_joydevs)
+    {
+        JoystickImpl *This;
+
+        if (riid == NULL)
+            ;/* nothing */
+        else if (IsEqualGUID(&IID_IDirectInputDeviceA,  riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice2A, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice7A, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice8A, riid))
+        {
+            unicode = 0;
+        }
+        else if (IsEqualGUID(&IID_IDirectInputDeviceW,  riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice2W, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice7W, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice8W, riid))
+        {
+            unicode = 1;
+        }
+        else
+        {
+            WARN("no interface\n");
+            return DIERR_NOINTERFACE;
+        }
+
+        This = alloc_device(rguid, dinput, index);
+        TRACE("Created a Joystick device (%p)\n", This);
+
+        if (!This) return DIERR_OUTOFMEMORY;
+
+        if (unicode)
+            *pdev = &This->generic.base.IDirectInputDevice8W_iface;
+        else
+            *pdev = &This->generic.base.IDirectInputDevice8A_iface;
+
+        return DI_OK;
+    }
+
+    return DIERR_DEVICENOTREG;
+}
+
+
+const struct dinput_device joystick_linuxinput_device = {
+  "Wine Linux-input joystick driver",
+  joydev_enum_deviceA,
+  joydev_enum_deviceW,
+  joydev_create_device
+};
+
+/******************************************************************************
+  *     Acquire : gets exclusive control of the joystick
+  */
+static HRESULT WINAPI JoystickWImpl_Acquire(LPDIRECTINPUTDEVICE8W iface)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+    HRESULT res;
+
+    TRACE("(this=%p)\n",This);
+
+    if ((res = IDirectInputDevice2WImpl_Acquire(iface)) != DI_OK)
+    {
+        WARN("Failed to acquire: %x\n", res);
+        return res;
+    }
+
+    if ((This->joyfd = open(This->joydev->device, O_RDWR)) == -1)
+    {
+        if ((This->joyfd = open(This->joydev->device, O_RDONLY)) == -1)
+        {
+            /* Couldn't open the device at all */
+            ERR("Failed to open device %s: %d %s\n", This->joydev->device, errno, strerror(errno));
+            IDirectInputDevice2WImpl_Unacquire(iface);
+            return DIERR_NOTFOUND;
+        }
+        else
+        {
+            /* Couldn't open in r/w but opened in read-only. */
+            WARN("Could not open %s in read-write mode.  Force feedback will be disabled.\n", This->joydev->device);
+        }
+    }
+    else
+    {
+        struct input_event event;
+
+        event.type = EV_FF;
+        event.code = FF_GAIN;
+        event.value = This->ff_gain;
+        if (write(This->joyfd, &event, sizeof(event)) == -1)
+            ERR("Failed to set gain (%i): %d %s\n", This->ff_gain, errno, strerror(errno));
+        if (!This->ff_autocenter)
+        {
+            /* Disable autocenter. */
+            event.code = FF_AUTOCENTER;
+            event.value = 0;
+            if (write(This->joyfd, &event, sizeof(event)) == -1)
+                ERR("Failed disabling autocenter: %d %s\n", errno, strerror(errno));
+        }
+    }
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickAImpl_Acquire(LPDIRECTINPUTDEVICE8A iface)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickWImpl_Acquire(IDirectInputDevice8W_from_impl(This));
+}
+
+/******************************************************************************
+  *     Unacquire : frees the joystick
+  */
+static HRESULT WINAPI JoystickWImpl_Unacquire(LPDIRECTINPUTDEVICE8W iface)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+    HRESULT res;
+
+    TRACE("(this=%p)\n",This);
+    res = IDirectInputDevice2WImpl_Unacquire(iface);
+    if (res==DI_OK && This->joyfd!=-1) {
+      struct input_event event;
+
+      /* Stop and unload all effects */
+      JoystickWImpl_SendForceFeedbackCommand(iface, DISFFC_RESET);
+
+      /* Enable autocenter. */
+      event.type = EV_FF;
+      event.code = FF_AUTOCENTER;
+      /* TODO: Read autocenter strength before disabling it, and use it here
+       * instead of 0xFFFF (maximum strength).
+       */
+      event.value = 0xFFFF;
+      if (write(This->joyfd, &event, sizeof(event)) == -1)
+        ERR("Failed to set autocenter to %04x: %d %s\n", event.value, errno, strerror(errno));
+
+      close(This->joyfd);
+      This->joyfd = -1;
+    }
+    return res;
+}
+
+static HRESULT WINAPI JoystickAImpl_Unacquire(LPDIRECTINPUTDEVICE8A iface)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickWImpl_Unacquire(IDirectInputDevice8W_from_impl(This));
+}
+
+/* 
+ * set the current state of the js device as it would be with the middle
+ * values on the axes
+ */
+#define CENTER_AXIS(a) \
+    (ji->dev_axes_to_di[a] == -1 ? 0 : joystick_map_axis( &ji->generic.props[ji->dev_axes_to_di[a]], \
+                                                          ji->joydev->axes[a].value ))
+static void fake_current_js_state(JoystickImpl *ji)
+{
+    int i;
+
+    /* center the axes */
+    ji->generic.js.lX           = CENTER_AXIS(ABS_X);
+    ji->generic.js.lY           = CENTER_AXIS(ABS_Y);
+    ji->generic.js.lZ           = CENTER_AXIS(ABS_Z);
+    ji->generic.js.lRx          = CENTER_AXIS(ABS_RX);
+    ji->generic.js.lRy          = CENTER_AXIS(ABS_RY);
+    ji->generic.js.lRz          = CENTER_AXIS(ABS_RZ);
+    ji->generic.js.rglSlider[0] = CENTER_AXIS(ABS_THROTTLE);
+    ji->generic.js.rglSlider[1] = CENTER_AXIS(ABS_RUDDER);
+
+    /* POV center is -1 */
+    for (i = 0; i < 4; i++)
+        ji->generic.js.rgdwPOV[i] = -1;
+}
+#undef CENTER_AXIS
+
+/* convert wine format offset to user format object index */
+static void joy_polldev(LPDIRECTINPUTDEVICE8A iface)
+{
+    struct pollfd plfd;
+    struct input_event ie;
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+
+    if (This->joyfd==-1)
+	return;
+
+    while (1)
+    {
+        LONG value = 0;
+        int inst_id = -1;
+
+	plfd.fd = This->joyfd;
+	plfd.events = POLLIN;
+
+	if (poll(&plfd,1,0) != 1)
+	    return;
+
+	/* we have one event, so we can read */
+	if (sizeof(ie)!=read(This->joyfd,&ie,sizeof(ie)))
+	    return;
+
+	TRACE("input_event: type %d, code %d, value %d\n",ie.type,ie.code,ie.value);
+	switch (ie.type) {
+	case EV_KEY:	/* button */
+        {
+            int btn = This->buttons[ie.code];
+
+            TRACE("(%p) %d -> %d\n", This, ie.code, btn);
+            if (btn & 0x80)
+            {
+                btn &= 0x7F;
+                inst_id = DIDFT_MAKEINSTANCE(btn) | DIDFT_PSHBUTTON;
+                This->generic.js.rgbButtons[btn] = value = ie.value ? 0x80 : 0x00;
+            }
+            break;
+        }
+	case EV_ABS:
+        {
+            int axis = This->dev_axes_to_di[ie.code];
+
+            /* User axis remapping */
+            if (axis < 0) break;
+            axis = This->generic.axis_map[axis];
+            if (axis < 0) break;
+
+            inst_id = axis < 8 ?  DIDFT_MAKEINSTANCE(axis) | DIDFT_ABSAXIS :
+                                  DIDFT_MAKEINSTANCE(axis - 8) | DIDFT_POV;
+            value = joystick_map_axis(&This->generic.props[id_to_object(This->generic.base.data_format.wine_df, inst_id)], ie.value);
+
+	    switch (axis) {
+            case 0: This->generic.js.lX  = value; break;
+            case 1: This->generic.js.lY  = value; break;
+            case 2: This->generic.js.lZ  = value; break;
+            case 3: This->generic.js.lRx = value; break;
+            case 4: This->generic.js.lRy = value; break;
+            case 5: This->generic.js.lRz = value; break;
+            case 6: This->generic.js.rglSlider[0] = value; break;
+            case 7: This->generic.js.rglSlider[1] = value; break;
+            case 8: case 9: case 10: case 11:
+            {
+                int idx = axis - 8;
+
+                if (ie.code % 2)
+                    This->povs[idx].y = ie.value;
+                else
+                    This->povs[idx].x = ie.value;
+
+                This->generic.js.rgdwPOV[idx] = value = joystick_map_pov(&This->povs[idx]);
+                break;
+            }
+	    default:
+		FIXME("unhandled joystick axis event (code %d, value %d)\n",ie.code,ie.value);
+	    }
+	    break;
+        }
+#ifdef HAVE_STRUCT_FF_EFFECT_DIRECTION
+	case EV_FF_STATUS:
+	    This->ff_state = ie.value;
+	    break;
+#endif
+#ifdef EV_SYN
+	case EV_SYN:
+	    /* there is nothing to do */
+	    break;
+#endif
+#ifdef EV_MSC
+        case EV_MSC:
+            /* Ignore */
+            break;
+#endif
+	default:
+	    TRACE("skipping event\n");
+	    break;
+	}
+        if (inst_id >= 0)
+            queue_event(iface, inst_id,
+                        value, GetCurrentTime(), This->generic.base.dinput->evsequence++);
+    }
+}
+
+/******************************************************************************
+  *     SetProperty : change input device properties
+  */
+static HRESULT WINAPI JoystickWImpl_SetProperty(LPDIRECTINPUTDEVICE8W iface, REFGUID rguid, LPCDIPROPHEADER ph)
+{
+  JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+  if (!ph) {
+    WARN("invalid argument\n");
+    return DIERR_INVALIDPARAM;
+  }
+
+  TRACE("(this=%p,%s,%p)\n",This,debugstr_guid(rguid),ph);
+  TRACE("ph.dwSize = %d, ph.dwHeaderSize =%d, ph.dwObj = %d, ph.dwHow= %d\n",
+        ph->dwSize, ph->dwHeaderSize, ph->dwObj, ph->dwHow);
+
+  if (IS_DIPROP(rguid)) {
+    switch (LOWORD(rguid)) {
+    case (DWORD_PTR)DIPROP_CALIBRATIONMODE: {
+      LPCDIPROPDWORD	pd = (LPCDIPROPDWORD)ph;
+      FIXME("DIPROP_CALIBRATIONMODE(%d)\n", pd->dwData);
+      break;
+    }
+    case (DWORD_PTR)DIPROP_AUTOCENTER: {
+      LPCDIPROPDWORD pd = (LPCDIPROPDWORD)ph;
+
+      TRACE("autocenter(%d)\n", pd->dwData);
+      This->ff_autocenter = pd->dwData == DIPROPAUTOCENTER_ON;
+
+      break;
+    }
+    case (DWORD_PTR)DIPROP_FFGAIN: {
+      LPCDIPROPDWORD pd = (LPCDIPROPDWORD)ph;
+
+      TRACE("DIPROP_FFGAIN(%d)\n", pd->dwData);
+      This->ff_gain = MulDiv(pd->dwData, 0xFFFF, 10000);
+      if (This->generic.base.acquired) {
+        /* Update immediately. */
+        struct input_event event;
+
+        event.type = EV_FF;
+        event.code = FF_GAIN;
+        event.value = This->ff_gain;
+        if (write(This->joyfd, &event, sizeof(event)) == -1)
+          ERR("Failed to set gain (%i): %d %s\n", This->ff_gain, errno, strerror(errno));
+      }
+      break;
+    }
+    default:
+      return JoystickWGenericImpl_SetProperty(iface, rguid, ph);
+    }
+  }
+  return DI_OK;
+}
+
+static HRESULT WINAPI JoystickAImpl_SetProperty(LPDIRECTINPUTDEVICE8A iface, REFGUID rguid, LPCDIPROPHEADER ph)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickWImpl_SetProperty(IDirectInputDevice8W_from_impl(This), rguid, ph);
+}
+
+/******************************************************************************
+  *     GetProperty : get input device properties
+  */
+static HRESULT WINAPI JoystickWImpl_GetProperty(LPDIRECTINPUTDEVICE8W iface, REFGUID rguid, LPDIPROPHEADER pdiph)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(this=%p,%s,%p)\n", iface, debugstr_guid(rguid), pdiph);
+    _dump_DIPROPHEADER(pdiph);
+
+    if (!IS_DIPROP(rguid)) return DI_OK;
+
+    switch (LOWORD(rguid)) {
+    case (DWORD_PTR) DIPROP_AUTOCENTER:
+    {
+        LPDIPROPDWORD pd = (LPDIPROPDWORD)pdiph;
+
+        pd->dwData = This->ff_autocenter ? DIPROPAUTOCENTER_ON : DIPROPAUTOCENTER_OFF;
+        TRACE("autocenter(%d)\n", pd->dwData);
+        break;
+    }
+    case (DWORD_PTR) DIPROP_FFGAIN:
+    {
+        LPDIPROPDWORD pd = (LPDIPROPDWORD)pdiph;
+
+        pd->dwData = MulDiv(This->ff_gain, 10000, 0xFFFF);
+        TRACE("DIPROP_FFGAIN(%d)\n", pd->dwData);
+        break;
+    }
+
+    case (DWORD_PTR) DIPROP_VIDPID:
+    {
+        LPDIPROPDWORD pd = (LPDIPROPDWORD)pdiph;
+
+        if (!This->joydev->product_id || !This->joydev->vendor_id)
+            return DIERR_UNSUPPORTED;
+        pd->dwData = MAKELONG(This->joydev->vendor_id, This->joydev->product_id);
+        TRACE("DIPROP_VIDPID(%08x)\n", pd->dwData);
+        break;
+    }
+
+    case (DWORD_PTR) DIPROP_JOYSTICKID:
+    {
+        LPDIPROPDWORD pd = (LPDIPROPDWORD)pdiph;
+
+        pd->dwData = get_joystick_index(&This->generic.base.guid);
+        TRACE("DIPROP_JOYSTICKID(%d)\n", pd->dwData);
+        break;
+    }
+
+    default:
+        return JoystickWGenericImpl_GetProperty(iface, rguid, pdiph);
+    }
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickAImpl_GetProperty(LPDIRECTINPUTDEVICE8A iface, REFGUID rguid, LPDIPROPHEADER pdiph)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickWImpl_GetProperty(IDirectInputDevice8W_from_impl(This), rguid, pdiph);
+}
+
+/****************************************************************************** 
+  *	CreateEffect - Create a new FF effect with the specified params
+  */
+static HRESULT WINAPI JoystickWImpl_CreateEffect(LPDIRECTINPUTDEVICE8W iface, REFGUID rguid,
+                                                 LPCDIEFFECT lpeff, LPDIRECTINPUTEFFECT *ppdef,
+                                                 LPUNKNOWN pUnkOuter)
+{
+#ifdef HAVE_STRUCT_FF_EFFECT_DIRECTION
+    effect_list_item* new_effect = NULL;
+    HRESULT retval = DI_OK;
+#endif
+
+    JoystickImpl* This = impl_from_IDirectInputDevice8W(iface);
+    TRACE("(this=%p,%p,%p,%p,%p)\n", This, rguid, lpeff, ppdef, pUnkOuter);
+
+    *ppdef = NULL;
+    if (!This->joydev->has_ff)
+    {
+        TRACE("No force feedback support\n");
+        return DIERR_UNSUPPORTED;
+    }
+
+#ifndef HAVE_STRUCT_FF_EFFECT_DIRECTION
+    TRACE("not available (compiled w/o force feedback support)\n");
+    return DIERR_UNSUPPORTED;
+#else
+
+    if (!(new_effect = HeapAlloc(GetProcessHeap(), 0, sizeof(*new_effect))))
+        return DIERR_OUTOFMEMORY;
+
+    retval = linuxinput_create_effect(&This->joyfd, rguid, &new_effect->entry, &new_effect->ref);
+    if (retval != DI_OK)
+    {
+        HeapFree(GetProcessHeap(), 0, new_effect);
+        return retval;
+    }
+
+    if (lpeff != NULL)
+    {
+        retval = IDirectInputEffect_SetParameters(new_effect->ref, lpeff, 0);
+
+        if (retval != DI_OK && retval != DI_DOWNLOADSKIPPED)
+        {
+            HeapFree(GetProcessHeap(), 0, new_effect);
+            return retval;
+        }
+    }
+
+    list_add_tail(&This->ff_effects, &new_effect->entry);
+    *ppdef = new_effect->ref;
+
+    if (pUnkOuter != NULL)
+	FIXME("Interface aggregation not implemented.\n");
+
+    return DI_OK;
+
+#endif /* HAVE_STRUCT_FF_EFFECT_DIRECTION */
+}
+
+static HRESULT WINAPI JoystickAImpl_CreateEffect(LPDIRECTINPUTDEVICE8A iface, REFGUID rguid,
+                                                 LPCDIEFFECT lpeff, LPDIRECTINPUTEFFECT *ppdef,
+                                                 LPUNKNOWN pUnkOuter)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickWImpl_CreateEffect(IDirectInputDevice8W_from_impl(This), rguid, lpeff, ppdef, pUnkOuter);
+}
+
+/*******************************************************************************
+ *	EnumEffects - Enumerate available FF effects
+ */
+static HRESULT WINAPI JoystickAImpl_EnumEffects(LPDIRECTINPUTDEVICE8A iface,
+						LPDIENUMEFFECTSCALLBACKA lpCallback,
+						LPVOID pvRef,
+						DWORD dwEffType)
+{
+#ifdef HAVE_STRUCT_FF_EFFECT_DIRECTION
+    DIEFFECTINFOA dei; /* feif */
+    DWORD type = DIEFT_GETTYPE(dwEffType);
+    JoystickImpl* This = impl_from_IDirectInputDevice8A(iface);
+
+    TRACE("(this=%p,%p,%d) type=%d\n", This, pvRef, dwEffType, type);
+
+    dei.dwSize = sizeof(DIEFFECTINFOA);          
+
+    if ((type == DIEFT_ALL || type == DIEFT_CONSTANTFORCE)
+	&& test_bit(This->joydev->ffbits, FF_CONSTANT)) {
+	IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_ConstantForce);
+	(*lpCallback)(&dei, pvRef);
+    }
+
+    if ((type == DIEFT_ALL || type == DIEFT_PERIODIC)
+	&& test_bit(This->joydev->ffbits, FF_PERIODIC)) {
+	if (test_bit(This->joydev->ffbits, FF_SQUARE)) {
+	    IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Square);
+	    (*lpCallback)(&dei, pvRef);
+	}
+	if (test_bit(This->joydev->ffbits, FF_SINE)) {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Sine);
+	    (*lpCallback)(&dei, pvRef);
+	}
+	if (test_bit(This->joydev->ffbits, FF_TRIANGLE)) {
+	    IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Triangle);
+	    (*lpCallback)(&dei, pvRef);
+	}
+	if (test_bit(This->joydev->ffbits, FF_SAW_UP)) {
+	    IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_SawtoothUp);
+	    (*lpCallback)(&dei, pvRef);
+	}
+	if (test_bit(This->joydev->ffbits, FF_SAW_DOWN)) {
+	    IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_SawtoothDown);
+	    (*lpCallback)(&dei, pvRef);
+	}
+    } 
+
+    if ((type == DIEFT_ALL || type == DIEFT_RAMPFORCE)
+	&& test_bit(This->joydev->ffbits, FF_RAMP)) {
+        IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_RampForce);
+        (*lpCallback)(&dei, pvRef);
+    }
+
+    if (type == DIEFT_ALL || type == DIEFT_CONDITION) {
+	if (test_bit(This->joydev->ffbits, FF_SPRING)) {
+	    IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Spring);
+	    (*lpCallback)(&dei, pvRef);
+	}
+	if (test_bit(This->joydev->ffbits, FF_DAMPER)) {
+	    IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Damper);
+	    (*lpCallback)(&dei, pvRef);
+	}
+	if (test_bit(This->joydev->ffbits, FF_INERTIA)) {
+	    IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Inertia);
+	    (*lpCallback)(&dei, pvRef);
+	}
+	if (test_bit(This->joydev->ffbits, FF_FRICTION)) {
+	    IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Friction);
+	    (*lpCallback)(&dei, pvRef);
+	}
+    }
+
+#endif
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickWImpl_EnumEffects(LPDIRECTINPUTDEVICE8W iface,
+                                                LPDIENUMEFFECTSCALLBACKW lpCallback,
+                                                LPVOID pvRef,
+                                                DWORD dwEffType)
+{
+#ifdef HAVE_STRUCT_FF_EFFECT_DIRECTION
+    /* seems silly to duplicate all this code but all the structures and functions
+     * are actually different (A/W) */
+    DIEFFECTINFOW dei; /* feif */
+    DWORD type = DIEFT_GETTYPE(dwEffType);
+    JoystickImpl* This = impl_from_IDirectInputDevice8W(iface);
+    int xfd = This->joyfd;
+
+    TRACE("(this=%p,%p,%d) type=%d fd=%d\n", This, pvRef, dwEffType, type, xfd);
+
+    dei.dwSize = sizeof(DIEFFECTINFOW);          
+
+    if ((type == DIEFT_ALL || type == DIEFT_CONSTANTFORCE)
+	&& test_bit(This->joydev->ffbits, FF_CONSTANT)) {
+	IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_ConstantForce);
+	(*lpCallback)(&dei, pvRef);
+    }
+
+    if ((type == DIEFT_ALL || type == DIEFT_PERIODIC)
+	&& test_bit(This->joydev->ffbits, FF_PERIODIC)) {
+	if (test_bit(This->joydev->ffbits, FF_SQUARE)) {
+	    IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Square);
+	    (*lpCallback)(&dei, pvRef);
+	}
+	if (test_bit(This->joydev->ffbits, FF_SINE)) {
+            IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Sine);
+	    (*lpCallback)(&dei, pvRef);
+	}
+	if (test_bit(This->joydev->ffbits, FF_TRIANGLE)) {
+	    IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Triangle);
+	    (*lpCallback)(&dei, pvRef);
+	}
+	if (test_bit(This->joydev->ffbits, FF_SAW_UP)) {
+	    IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_SawtoothUp);
+	    (*lpCallback)(&dei, pvRef);
+	}
+	if (test_bit(This->joydev->ffbits, FF_SAW_DOWN)) {
+	    IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_SawtoothDown);
+	    (*lpCallback)(&dei, pvRef);
+	}
+    } 
+
+    if ((type == DIEFT_ALL || type == DIEFT_RAMPFORCE)
+	&& test_bit(This->joydev->ffbits, FF_RAMP)) {
+        IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_RampForce);
+        (*lpCallback)(&dei, pvRef);
+    }
+
+    if (type == DIEFT_ALL || type == DIEFT_CONDITION) {
+	if (test_bit(This->joydev->ffbits, FF_SPRING)) {
+	    IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Spring);
+	    (*lpCallback)(&dei, pvRef);
+	}
+	if (test_bit(This->joydev->ffbits, FF_DAMPER)) {
+	    IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Damper);
+	    (*lpCallback)(&dei, pvRef);
+	}
+	if (test_bit(This->joydev->ffbits, FF_INERTIA)) {
+	    IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Inertia);
+	    (*lpCallback)(&dei, pvRef);
+	}
+	if (test_bit(This->joydev->ffbits, FF_FRICTION)) {
+	    IDirectInputDevice8_GetEffectInfo(iface, &dei, &GUID_Friction);
+	    (*lpCallback)(&dei, pvRef);
+	}
+    }
+
+    /* return to unacquired state if that's where it was */
+    if (xfd == -1)
+	IDirectInputDevice8_Unacquire(iface);
+#endif
+
+    return DI_OK;
+}
+
+/*******************************************************************************
+ *      GetEffectInfo - Get information about a particular effect 
+ */
+static HRESULT WINAPI JoystickAImpl_GetEffectInfo(LPDIRECTINPUTDEVICE8A iface,
+						  LPDIEFFECTINFOA pdei,
+						  REFGUID guid)
+{
+    JoystickImpl* This = impl_from_IDirectInputDevice8A(iface);
+
+    TRACE("(this=%p,%p,%s)\n", This, pdei, _dump_dinput_GUID(guid));
+
+#ifdef HAVE_STRUCT_FF_EFFECT_DIRECTION
+    return linuxinput_get_info_A(This->joyfd, guid, pdei); 
+#else
+    return DI_OK;
+#endif
+}
+
+static HRESULT WINAPI JoystickWImpl_GetEffectInfo(LPDIRECTINPUTDEVICE8W iface,
+                                                  LPDIEFFECTINFOW pdei,
+                                                  REFGUID guid)
+{
+    JoystickImpl* This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(this=%p,%p,%s)\n", This, pdei, _dump_dinput_GUID(guid));
+
+#ifdef HAVE_STRUCT_FF_EFFECT_DIRECTION
+    return linuxinput_get_info_W(This->joyfd, guid, pdei);
+#else
+    return DI_OK;
+#endif
+}
+
+/*******************************************************************************
+ *      GetForceFeedbackState - Get information about the device's FF state 
+ */
+static HRESULT WINAPI JoystickWImpl_GetForceFeedbackState(LPDIRECTINPUTDEVICE8W iface, LPDWORD pdwOut)
+{
+    JoystickImpl* This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(this=%p,%p)\n", This, pdwOut);
+
+    (*pdwOut) = 0;
+
+#ifdef HAVE_STRUCT_FF_EFFECT_DIRECTION
+    /* DIGFFS_STOPPED is the only mandatory flag to report */
+    if (This->ff_state == FF_STATUS_STOPPED)
+	(*pdwOut) |= DIGFFS_STOPPED;
+#endif
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickAImpl_GetForceFeedbackState(LPDIRECTINPUTDEVICE8A iface, LPDWORD pdwOut)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickWImpl_GetForceFeedbackState(IDirectInputDevice8W_from_impl(This), pdwOut);
+}
+
+/*******************************************************************************
+ *      SendForceFeedbackCommand - Send a command to the device's FF system
+ */
+static HRESULT WINAPI JoystickWImpl_SendForceFeedbackCommand(LPDIRECTINPUTDEVICE8W iface, DWORD dwFlags)
+{
+    JoystickImpl* This = impl_from_IDirectInputDevice8W(iface);
+    TRACE("(this=%p,%d)\n", This, dwFlags);
+
+#ifdef HAVE_STRUCT_FF_EFFECT_DIRECTION
+    switch (dwFlags)
+    {
+    case DISFFC_STOPALL:
+    {
+        effect_list_item *itr;
+
+        /* Stop all effects */
+        LIST_FOR_EACH_ENTRY(itr, &This->ff_effects, effect_list_item, entry)
+            IDirectInputEffect_Stop(itr->ref);
+        break;
+    }
+
+    case DISFFC_RESET:
+    {
+        effect_list_item *itr;
+
+        /* Stop and unload all effects. It is not true that effects are released */
+        LIST_FOR_EACH_ENTRY(itr, &This->ff_effects, effect_list_item, entry)
+        {
+            IDirectInputEffect_Stop(itr->ref);
+            IDirectInputEffect_Unload(itr->ref);
+        }
+        break;
+    }
+    case DISFFC_PAUSE:
+    case DISFFC_CONTINUE:
+        FIXME("No support for Pause or Continue in linux\n");
+        break;
+
+    case DISFFC_SETACTUATORSOFF:
+    case DISFFC_SETACTUATORSON:
+        FIXME("No direct actuator control in linux\n");
+        break;
+
+    default:
+        WARN("Unknown Force Feedback Command %u!\n", dwFlags);
+        return DIERR_INVALIDPARAM;
+    }
+    return DI_OK;
+#else
+    return DIERR_UNSUPPORTED;
+#endif
+}
+
+static HRESULT WINAPI JoystickAImpl_SendForceFeedbackCommand(LPDIRECTINPUTDEVICE8A iface, DWORD dwFlags)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickWImpl_SendForceFeedbackCommand(IDirectInputDevice8W_from_impl(This), dwFlags);
+}
+
+/*******************************************************************************
+ *      EnumCreatedEffectObjects - Enumerate all the effects that have been
+ *		created for this device.
+ */
+static HRESULT WINAPI JoystickWImpl_EnumCreatedEffectObjects(LPDIRECTINPUTDEVICE8W iface,
+                                                             LPDIENUMCREATEDEFFECTOBJECTSCALLBACK lpCallback,
+                                                             LPVOID pvRef, DWORD dwFlags)
+{
+    /* this function is safe to call on non-ff-enabled builds */
+    JoystickImpl* This = impl_from_IDirectInputDevice8W(iface);
+    effect_list_item *itr, *ptr;
+
+    TRACE("(this=%p,%p,%p,%d)\n", This, lpCallback, pvRef, dwFlags);
+
+    if (!lpCallback)
+	return DIERR_INVALIDPARAM;
+
+    if (dwFlags != 0)
+	FIXME("Flags specified, but no flags exist yet (DX9)!\n");
+
+    LIST_FOR_EACH_ENTRY_SAFE(itr, ptr, &This->ff_effects, effect_list_item, entry)
+        (*lpCallback)(itr->ref, pvRef);
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickAImpl_EnumCreatedEffectObjects(LPDIRECTINPUTDEVICE8A iface,
+                                                             LPDIENUMCREATEDEFFECTOBJECTSCALLBACK lpCallback,
+                                                             LPVOID pvRef, DWORD dwFlags)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return JoystickWImpl_EnumCreatedEffectObjects(IDirectInputDevice8W_from_impl(This), lpCallback, pvRef, dwFlags);
+}
+
+/******************************************************************************
+  *     GetDeviceInfo : get information about a device's identity
+  */
+static HRESULT WINAPI JoystickAImpl_GetDeviceInfo(LPDIRECTINPUTDEVICE8A iface,
+                                                  LPDIDEVICEINSTANCEA pdidi)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+
+    TRACE("(%p) %p\n", This, pdidi);
+
+    if (pdidi == NULL) return E_POINTER;
+    if ((pdidi->dwSize != sizeof(DIDEVICEINSTANCE_DX3A)) &&
+        (pdidi->dwSize != sizeof(DIDEVICEINSTANCEA)))
+        return DIERR_INVALIDPARAM;
+
+    fill_joystick_dideviceinstanceA(pdidi, This->generic.base.dinput->dwVersion,
+                                    get_joystick_index(&This->generic.base.guid));
+    return DI_OK;
+}
+
+static HRESULT WINAPI JoystickWImpl_GetDeviceInfo(LPDIRECTINPUTDEVICE8W iface,
+                                                  LPDIDEVICEINSTANCEW pdidi)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(%p) %p\n", This, pdidi);
+
+    if (pdidi == NULL) return E_POINTER;
+    if ((pdidi->dwSize != sizeof(DIDEVICEINSTANCE_DX3W)) &&
+        (pdidi->dwSize != sizeof(DIDEVICEINSTANCEW)))
+        return DIERR_INVALIDPARAM;
+
+    fill_joystick_dideviceinstanceW(pdidi, This->generic.base.dinput->dwVersion,
+                                    get_joystick_index(&This->generic.base.guid));
+    return DI_OK;
+}
+
+static const IDirectInputDevice8AVtbl JoystickAvt =
+{
+	IDirectInputDevice2AImpl_QueryInterface,
+	IDirectInputDevice2AImpl_AddRef,
+        IDirectInputDevice2AImpl_Release,
+        JoystickAGenericImpl_GetCapabilities,
+        IDirectInputDevice2AImpl_EnumObjects,
+	JoystickAImpl_GetProperty,
+	JoystickAImpl_SetProperty,
+	JoystickAImpl_Acquire,
+	JoystickAImpl_Unacquire,
+        JoystickAGenericImpl_GetDeviceState,
+	IDirectInputDevice2AImpl_GetDeviceData,
+        IDirectInputDevice2AImpl_SetDataFormat,
+	IDirectInputDevice2AImpl_SetEventNotification,
+	IDirectInputDevice2AImpl_SetCooperativeLevel,
+        JoystickAGenericImpl_GetObjectInfo,
+	JoystickAImpl_GetDeviceInfo,
+	IDirectInputDevice2AImpl_RunControlPanel,
+	IDirectInputDevice2AImpl_Initialize,
+	JoystickAImpl_CreateEffect,
+	JoystickAImpl_EnumEffects,
+	JoystickAImpl_GetEffectInfo,
+	JoystickAImpl_GetForceFeedbackState,
+	JoystickAImpl_SendForceFeedbackCommand,
+	JoystickAImpl_EnumCreatedEffectObjects,
+	IDirectInputDevice2AImpl_Escape,
+        JoystickAGenericImpl_Poll,
+	IDirectInputDevice2AImpl_SendDeviceData,
+	IDirectInputDevice7AImpl_EnumEffectsInFile,
+        IDirectInputDevice7AImpl_WriteEffectToFile,
+        JoystickAGenericImpl_BuildActionMap,
+        JoystickAGenericImpl_SetActionMap,
+        IDirectInputDevice8AImpl_GetImageInfo
+};
+
+static const IDirectInputDevice8WVtbl JoystickWvt =
+{
+    IDirectInputDevice2WImpl_QueryInterface,
+    IDirectInputDevice2WImpl_AddRef,
+    IDirectInputDevice2WImpl_Release,
+    JoystickWGenericImpl_GetCapabilities,
+    IDirectInputDevice2WImpl_EnumObjects,
+    JoystickWImpl_GetProperty,
+    JoystickWImpl_SetProperty,
+    JoystickWImpl_Acquire,
+    JoystickWImpl_Unacquire,
+    JoystickWGenericImpl_GetDeviceState,
+    IDirectInputDevice2WImpl_GetDeviceData,
+    IDirectInputDevice2WImpl_SetDataFormat,
+    IDirectInputDevice2WImpl_SetEventNotification,
+    IDirectInputDevice2WImpl_SetCooperativeLevel,
+    JoystickWGenericImpl_GetObjectInfo,
+    JoystickWImpl_GetDeviceInfo,
+    IDirectInputDevice2WImpl_RunControlPanel,
+    IDirectInputDevice2WImpl_Initialize,
+    JoystickWImpl_CreateEffect,
+    JoystickWImpl_EnumEffects,
+    JoystickWImpl_GetEffectInfo,
+    JoystickWImpl_GetForceFeedbackState,
+    JoystickWImpl_SendForceFeedbackCommand,
+    JoystickWImpl_EnumCreatedEffectObjects,
+    IDirectInputDevice2WImpl_Escape,
+    JoystickWGenericImpl_Poll,
+    IDirectInputDevice2WImpl_SendDeviceData,
+    IDirectInputDevice7WImpl_EnumEffectsInFile,
+    IDirectInputDevice7WImpl_WriteEffectToFile,
+    JoystickWGenericImpl_BuildActionMap,
+    JoystickWGenericImpl_SetActionMap,
+    IDirectInputDevice8WImpl_GetImageInfo
+};
+
+#else  /* HAS_PROPER_HEADER */
+
+const struct dinput_device joystick_linuxinput_device = {
+  "Wine Linux-input joystick driver",
+  NULL,
+  NULL,
+  NULL
+};
+
+#endif  /* HAS_PROPER_HEADER */
diff --git a/dlls/dinput8/joystick_osx.c b/dlls/dinput8/joystick_osx.c
new file mode 100644
index 0000000..b0dcdd9
--- /dev/null
+++ b/dlls/dinput8/joystick_osx.c
@@ -0,0 +1,1697 @@
+/*  DirectInput Joystick device for Mac OS/X
+ *
+ * Copyright 1998 Marcus Meissner
+ * Copyright 1998,1999 Lionel Ulmer
+ * Copyright 2000-2001 TransGaming Technologies Inc.
+ * Copyright 2009 CodeWeavers, Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#if defined(HAVE_IOKIT_HID_IOHIDLIB_H)
+#define DWORD UInt32
+#define LPDWORD UInt32*
+#define LONG SInt32
+#define LPLONG SInt32*
+#define E_PENDING __carbon_E_PENDING
+#define ULONG __carbon_ULONG
+#define E_INVALIDARG __carbon_E_INVALIDARG
+#define E_OUTOFMEMORY __carbon_E_OUTOFMEMORY
+#define E_HANDLE __carbon_E_HANDLE
+#define E_ACCESSDENIED __carbon_E_ACCESSDENIED
+#define E_UNEXPECTED __carbon_E_UNEXPECTED
+#define E_FAIL __carbon_E_FAIL
+#define E_ABORT __carbon_E_ABORT
+#define E_POINTER __carbon_E_POINTER
+#define E_NOINTERFACE __carbon_E_NOINTERFACE
+#define E_NOTIMPL __carbon_E_NOTIMPL
+#define S_FALSE __carbon_S_FALSE
+#define S_OK __carbon_S_OK
+#define HRESULT_FACILITY __carbon_HRESULT_FACILITY
+#define IS_ERROR __carbon_IS_ERROR
+#define FAILED __carbon_FAILED
+#define SUCCEEDED __carbon_SUCCEEDED
+#define MAKE_HRESULT __carbon_MAKE_HRESULT
+#define HRESULT __carbon_HRESULT
+#define STDMETHODCALLTYPE __carbon_STDMETHODCALLTYPE
+#include <IOKit/IOKitLib.h>
+#include <IOKit/hid/IOHIDLib.h>
+#include <ForceFeedback/ForceFeedback.h>
+#undef ULONG
+#undef E_INVALIDARG
+#undef E_OUTOFMEMORY
+#undef E_HANDLE
+#undef E_ACCESSDENIED
+#undef E_UNEXPECTED
+#undef E_FAIL
+#undef E_ABORT
+#undef E_POINTER
+#undef E_NOINTERFACE
+#undef E_NOTIMPL
+#undef S_FALSE
+#undef S_OK
+#undef HRESULT_FACILITY
+#undef IS_ERROR
+#undef FAILED
+#undef SUCCEEDED
+#undef MAKE_HRESULT
+#undef HRESULT
+#undef STDMETHODCALLTYPE
+#undef DWORD
+#undef LPDWORD
+#undef LONG
+#undef LPLONG
+#undef E_PENDING
+#endif /* HAVE_IOKIT_HID_IOHIDLIB_H */
+
+#include "wine/debug.h"
+#include "wine/unicode.h"
+#include "windef.h"
+#include "winbase.h"
+#include "winerror.h"
+#include "winreg.h"
+#include "dinput.h"
+
+#include "dinput_private.h"
+#include "device_private.h"
+#include "joystick_private.h"
+
+#ifdef HAVE_IOHIDMANAGERCREATE
+
+WINE_DEFAULT_DEBUG_CHANNEL(dinput);
+
+static CFMutableArrayRef device_main_elements = NULL;
+
+typedef struct JoystickImpl JoystickImpl;
+static const IDirectInputDevice8AVtbl JoystickAvt;
+static const IDirectInputDevice8WVtbl JoystickWvt;
+
+struct JoystickImpl
+{
+    struct JoystickGenericImpl generic;
+
+    /* osx private */
+    int                    id;
+    CFArrayRef             elements;
+    ObjProps               **propmap;
+    FFDeviceObjectReference ff;
+    struct list effects;
+};
+
+static inline JoystickImpl *impl_from_IDirectInputDevice8A(IDirectInputDevice8A *iface)
+{
+    return CONTAINING_RECORD(CONTAINING_RECORD(CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8A_iface),
+           JoystickGenericImpl, base), JoystickImpl, generic);
+}
+static inline JoystickImpl *impl_from_IDirectInputDevice8W(IDirectInputDevice8W *iface)
+{
+    return CONTAINING_RECORD(CONTAINING_RECORD(CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8W_iface),
+           JoystickGenericImpl, base), JoystickImpl, generic);
+}
+
+typedef struct _EffectImpl {
+    IDirectInputEffect IDirectInputEffect_iface;
+    LONG ref;
+
+    JoystickImpl *device;
+    FFEffectObjectReference effect;
+    GUID guid;
+
+    struct list entry;
+} EffectImpl;
+
+static EffectImpl *impl_from_IDirectInputEffect(IDirectInputEffect *iface)
+{
+    return CONTAINING_RECORD(iface, EffectImpl, IDirectInputEffect_iface);
+}
+
+static const IDirectInputEffectVtbl EffectVtbl;
+
+static const GUID DInput_Wine_OsX_Joystick_GUID = { /* 59CAD8F6-E617-41E2-8EB7-47B23EEEDC5A */
+  0x59CAD8F6, 0xE617, 0x41E2, {0x8E, 0xB7, 0x47, 0xB2, 0x3E, 0xEE, 0xDC, 0x5A}
+};
+
+static HRESULT osx_to_win32_hresult(HRESULT in)
+{
+    /* OSX returns 16-bit COM runtime errors, which we should
+     * convert to win32 */
+    switch(in){
+    case 0x80000001:
+        return E_NOTIMPL;
+    case 0x80000002:
+        return E_OUTOFMEMORY;
+    case 0x80000003:
+        return E_INVALIDARG;
+    case 0x80000004:
+        return E_NOINTERFACE;
+    case 0x80000005:
+        return E_POINTER;
+    case 0x80000006:
+        return E_HANDLE;
+    case 0x80000007:
+        return E_ABORT;
+    case 0x80000008:
+        return E_FAIL;
+    case 0x80000009:
+        return E_ACCESSDENIED;
+    case 0x8000FFFF:
+        return E_UNEXPECTED;
+    }
+    return in;
+}
+
+static long get_device_property_long(IOHIDDeviceRef device, CFStringRef key)
+{
+    CFTypeRef ref;
+    long result = 0;
+
+    if (device)
+    {
+        assert(IOHIDDeviceGetTypeID() == CFGetTypeID(device));
+
+        ref = IOHIDDeviceGetProperty(device, key);
+
+        if (ref && CFNumberGetTypeID() == CFGetTypeID(ref))
+            CFNumberGetValue((CFNumberRef)ref, kCFNumberLongType, &result);
+    }
+
+    return result;
+}
+
+static CFStringRef copy_device_name(IOHIDDeviceRef device)
+{
+    CFStringRef name;
+
+    if (device)
+    {
+        CFTypeRef ref_name;
+
+        assert(IOHIDDeviceGetTypeID() == CFGetTypeID(device));
+
+        ref_name = IOHIDDeviceGetProperty(device, CFSTR(kIOHIDProductKey));
+
+        if (ref_name && CFStringGetTypeID() == CFGetTypeID(ref_name))
+            name = CFStringCreateCopy(kCFAllocatorDefault, ref_name);
+        else
+        {
+            long vendID, prodID;
+
+            vendID = get_device_property_long(device, CFSTR(kIOHIDVendorIDKey));
+            prodID = get_device_property_long(device, CFSTR(kIOHIDProductIDKey));
+            name = CFStringCreateWithFormat(kCFAllocatorDefault, NULL, CFSTR("0x%04lx 0x%04lx"), vendID, prodID);
+        }
+    }
+    else
+    {
+        ERR("NULL device\n");
+        name = CFStringCreateCopy(kCFAllocatorDefault, CFSTR(""));
+    }
+
+    return name;
+}
+
+static long get_device_location_ID(IOHIDDeviceRef device)
+{
+    return get_device_property_long(device, CFSTR(kIOHIDLocationIDKey));
+}
+
+static void copy_set_to_array(const void *value, void *context)
+{
+    CFArrayAppendValue(context, value);
+}
+
+static CFComparisonResult device_name_comparator(IOHIDDeviceRef device1, IOHIDDeviceRef device2)
+{
+    CFStringRef name1 = copy_device_name(device1), name2 = copy_device_name(device2);
+    CFComparisonResult result = CFStringCompare(name1, name2, (kCFCompareForcedOrdering | kCFCompareNumerically));
+    CFRelease(name1);
+    CFRelease(name2);
+    return  result;
+}
+
+static CFComparisonResult device_location_name_comparator(const void *val1, const void *val2, void *context)
+{
+    IOHIDDeviceRef device1 = (IOHIDDeviceRef)val1, device2 = (IOHIDDeviceRef)val2;
+    long loc1 = get_device_location_ID(device1), loc2 = get_device_location_ID(device2);
+
+    if (loc1 < loc2)
+        return kCFCompareLessThan;
+    else if (loc1 > loc2)
+        return kCFCompareGreaterThan;
+    /* virtual joysticks may not have a kIOHIDLocationIDKey and will default to location ID of 0, this orders virtual joysticks by their name */
+    return device_name_comparator(device1, device2);
+}
+
+static const char* debugstr_cf(CFTypeRef t)
+{
+    CFStringRef s;
+    const char* ret;
+
+    if (!t) return "(null)";
+
+    if (CFGetTypeID(t) == CFStringGetTypeID())
+        s = t;
+    else
+        s = CFCopyDescription(t);
+    ret = CFStringGetCStringPtr(s, kCFStringEncodingUTF8);
+    if (ret) ret = debugstr_a(ret);
+    if (!ret)
+    {
+        const UniChar* u = CFStringGetCharactersPtr(s);
+        if (u)
+            ret = debugstr_wn((const WCHAR*)u, CFStringGetLength(s));
+    }
+    if (!ret)
+    {
+        UniChar buf[200];
+        int len = min(CFStringGetLength(s), sizeof(buf)/sizeof(buf[0]));
+        CFStringGetCharacters(s, CFRangeMake(0, len), buf);
+        ret = debugstr_wn(buf, len);
+    }
+    if (s != t) CFRelease(s);
+    return ret;
+}
+
+static const char* debugstr_device(IOHIDDeviceRef device)
+{
+    return wine_dbg_sprintf("<IOHIDDevice %p product %s IOHIDLocationID %lu>", device,
+                            debugstr_cf(IOHIDDeviceGetProperty(device, CFSTR(kIOHIDProductKey))),
+                            get_device_location_ID(device));
+}
+
+static const char* debugstr_element(IOHIDElementRef element)
+{
+    return wine_dbg_sprintf("<IOHIDElement %p type %d usage %u/%u device %p>", element,
+                            IOHIDElementGetType(element), IOHIDElementGetUsagePage(element),
+                            IOHIDElementGetUsage(element), IOHIDElementGetDevice(element));
+}
+
+static IOHIDDeviceRef get_device_ref(int id)
+{
+    IOHIDElementRef device_main_element;
+    IOHIDDeviceRef hid_device;
+
+    TRACE("id %d\n", id);
+
+    if (!device_main_elements || id >= CFArrayGetCount(device_main_elements))
+        return 0;
+
+    device_main_element = (IOHIDElementRef)CFArrayGetValueAtIndex(device_main_elements, id);
+    if (!device_main_element)
+    {
+        ERR("Invalid Element requested %i\n",id);
+        return 0;
+    }
+
+    hid_device = IOHIDElementGetDevice(device_main_element);
+    if (!hid_device)
+    {
+        ERR("Invalid Device requested %i\n",id);
+        return 0;
+    }
+
+    TRACE("-> %s\n", debugstr_device(hid_device));
+    return hid_device;
+}
+
+static HRESULT get_ff(IOHIDDeviceRef device, FFDeviceObjectReference *ret)
+{
+    io_service_t service;
+    CFMutableDictionaryRef matching;
+    CFTypeRef location_id;
+    HRESULT hr;
+
+    TRACE("device %s\n", debugstr_device(device));
+
+    matching = IOServiceMatching(kIOHIDDeviceKey);
+    if(!matching){
+        WARN("IOServiceMatching failed, force feedback disabled\n");
+        return DIERR_DEVICENOTREG;
+    }
+
+    location_id = IOHIDDeviceGetProperty(device, CFSTR(kIOHIDLocationIDKey));
+    if(!location_id){
+        CFRelease(matching);
+        WARN("IOHIDDeviceGetProperty failed, force feedback disabled\n");
+        return DIERR_DEVICENOTREG;
+    }
+
+    CFDictionaryAddValue(matching, CFSTR(kIOHIDLocationIDKey), location_id);
+
+    service = IOServiceGetMatchingService(kIOMasterPortDefault, matching);
+
+    if (ret)
+        hr = osx_to_win32_hresult(FFCreateDevice(service, ret));
+    else
+        hr = FFIsForceFeedback(service) == FF_OK ? S_OK : S_FALSE;
+
+    IOObjectRelease(service);
+    TRACE("-> hr 0x%08x *ret %p\n", hr, ret ? *ret : NULL);
+    return hr;
+}
+
+static CFMutableDictionaryRef create_osx_device_match(int usage)
+{
+    CFMutableDictionaryRef result;
+
+    TRACE("usage %d\n", usage);
+
+    result = CFDictionaryCreateMutable( kCFAllocatorDefault, 0,
+            &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks );
+
+    if ( result )
+    {
+        int number = kHIDPage_GenericDesktop;
+        CFNumberRef page = CFNumberCreate( kCFAllocatorDefault,
+                          kCFNumberIntType, &number);
+
+        if (page)
+        {
+            CFNumberRef cf_usage;
+
+            CFDictionarySetValue( result, CFSTR( kIOHIDDeviceUsagePageKey ), page );
+            CFRelease( page );
+
+            cf_usage = CFNumberCreate( kCFAllocatorDefault,
+                        kCFNumberIntType, &usage);
+            if (cf_usage)
+            {
+                CFDictionarySetValue( result, CFSTR( kIOHIDDeviceUsageKey ), cf_usage );
+                CFRelease( cf_usage );
+            }
+            else
+            {
+                ERR("CFNumberCreate() failed.\n");
+                CFRelease(result);
+                return NULL;
+            }
+        }
+        else
+        {
+            ERR("CFNumberCreate failed.\n");
+            CFRelease(result);
+            return NULL;
+        }
+    }
+    else
+    {
+        ERR("CFDictionaryCreateMutable failed.\n");
+        return NULL;
+    }
+
+    return result;
+}
+
+static CFIndex find_top_level(IOHIDDeviceRef hid_device, CFMutableArrayRef main_elements)
+{
+    CFArrayRef      elements;
+    CFIndex         total = 0;
+
+    TRACE("hid_device %s\n", debugstr_device(hid_device));
+
+    if (!hid_device)
+        return 0;
+
+    elements = IOHIDDeviceCopyMatchingElements(hid_device, NULL, 0);
+
+    if (elements)
+    {
+        CFIndex idx, cnt = CFArrayGetCount(elements);
+        for (idx=0; idx<cnt; idx++)
+        {
+            IOHIDElementRef element = (IOHIDElementRef)CFArrayGetValueAtIndex(elements, idx);
+            int type = IOHIDElementGetType(element);
+
+            TRACE("element %s\n", debugstr_element(element));
+
+            /* Check for top-level gaming device collections */
+            if (type == kIOHIDElementTypeCollection && IOHIDElementGetParent(element) == 0)
+            {
+                int usage_page = IOHIDElementGetUsagePage(element);
+                int usage = IOHIDElementGetUsage(element);
+
+                if (usage_page == kHIDPage_GenericDesktop &&
+                    (usage == kHIDUsage_GD_Joystick || usage == kHIDUsage_GD_GamePad))
+                {
+                    CFArrayAppendValue(main_elements, element);
+                    total++;
+                }
+            }
+        }
+        CFRelease(elements);
+    }
+
+    TRACE("-> total %d\n", (int)total);
+    return total;
+}
+
+static void get_element_children(IOHIDElementRef element, CFMutableArrayRef all_children)
+{
+    CFIndex    idx, cnt;
+    CFArrayRef element_children = IOHIDElementGetChildren(element);
+
+    TRACE("element %s\n", debugstr_element(element));
+
+    cnt = CFArrayGetCount(element_children);
+
+    /* Either add the element to the array or grab its children */
+    for (idx=0; idx<cnt; idx++)
+    {
+        IOHIDElementRef child;
+
+        child = (IOHIDElementRef)CFArrayGetValueAtIndex(element_children, idx);
+        TRACE("child %s\n", debugstr_element(child));
+        if (IOHIDElementGetType(child) == kIOHIDElementTypeCollection)
+            get_element_children(child, all_children);
+        else
+            CFArrayAppendValue(all_children, child);
+    }
+}
+
+static int find_osx_devices(void)
+{
+    IOHIDManagerRef hid_manager;
+    CFMutableDictionaryRef result;
+    CFSetRef devset;
+    CFMutableArrayRef matching;
+
+    TRACE("()\n");
+
+    hid_manager = IOHIDManagerCreate( kCFAllocatorDefault, 0L );
+    if (IOHIDManagerOpen( hid_manager, 0 ) != kIOReturnSuccess)
+    {
+        ERR("Couldn't open IOHIDManager.\n");
+        CFRelease( hid_manager );
+        return 0;
+    }
+
+     matching = CFArrayCreateMutable( kCFAllocatorDefault, 0,
+                        &kCFTypeArrayCallBacks );
+
+    /* build matching dictionary */
+    result = create_osx_device_match(kHIDUsage_GD_Joystick);
+    if (!result)
+    {
+        CFRelease(matching);
+        goto fail;
+    }
+    CFArrayAppendValue( matching, result );
+    CFRelease( result );
+    result = create_osx_device_match(kHIDUsage_GD_GamePad);
+    if (!result)
+    {
+        CFRelease(matching);
+        goto fail;
+    }
+    CFArrayAppendValue( matching, result );
+    CFRelease( result );
+
+    IOHIDManagerSetDeviceMatchingMultiple( hid_manager, matching);
+    CFRelease( matching );
+    devset = IOHIDManagerCopyDevices( hid_manager );
+    if (devset)
+    {
+        CFIndex num_devices, num_main_elements, idx;
+        CFMutableArrayRef devices;
+
+        num_devices = CFSetGetCount(devset);
+        devices = CFArrayCreateMutable(kCFAllocatorDefault, num_devices, &kCFTypeArrayCallBacks);
+        CFSetApplyFunction(devset, copy_set_to_array, devices);
+        CFRelease(devset);
+        CFArraySortValues(devices, CFRangeMake(0, num_devices), device_location_name_comparator, NULL);
+
+        device_main_elements = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
+        if (!device_main_elements)
+        {
+            CFRelease( devices );
+            goto fail;
+        }
+
+        num_main_elements = 0;
+        for (idx = 0; idx < num_devices; idx++)
+        {
+            CFIndex top;
+            IOHIDDeviceRef hid_device;
+
+            hid_device = (IOHIDDeviceRef) CFArrayGetValueAtIndex(devices, idx);
+            TRACE("hid_device %s\n", debugstr_device(hid_device));
+            top = find_top_level(hid_device, device_main_elements);
+            num_main_elements += top;
+        }
+
+        CFRelease(devices);
+
+        TRACE("found %i device(s), %i collection(s)\n",(int)num_devices,(int)num_main_elements);
+        return (int)num_main_elements;
+    }
+
+fail:
+    IOHIDManagerClose( hid_manager, 0 );
+    CFRelease( hid_manager );
+    return 0;
+}
+
+static int get_osx_device_name(int id, char *name, int length)
+{
+    CFStringRef str;
+    IOHIDDeviceRef hid_device;
+
+    hid_device = get_device_ref(id);
+
+    TRACE("id %d hid_device %s\n", id, debugstr_device(hid_device));
+
+    if (name)
+        name[0] = 0;
+
+    if (!hid_device)
+        return 0;
+
+    str = IOHIDDeviceGetProperty(hid_device, CFSTR( kIOHIDProductKey ));
+    if (str)
+    {
+        CFIndex len = CFStringGetLength(str);
+        if (length >= len)
+        {
+            CFStringGetCString(str,name,length,kCFStringEncodingASCII);
+            return len;
+        }
+        else
+            return (len+1);
+    }
+    return 0;
+}
+
+static CFComparisonResult button_usage_comparator(const void *val1, const void *val2, void *context)
+{
+    IOHIDElementRef element1 = (IOHIDElementRef)val1, element2 = (IOHIDElementRef)val2;
+    int usage1 = IOHIDElementGetUsage(element1), usage2 = IOHIDElementGetUsage(element2);
+
+    if (usage1 < usage2)
+        return kCFCompareLessThan;
+    if (usage1 > usage2)
+        return kCFCompareGreaterThan;
+    return kCFCompareEqualTo;
+}
+
+static void get_osx_device_elements(JoystickImpl *device, int axis_map[8])
+{
+    IOHIDElementRef device_main_element;
+    CFMutableArrayRef elements;
+    DWORD           sliders = 0;
+
+    TRACE("device %p device->id %d\n", device, device->id);
+
+    device->elements = NULL;
+
+    if (!device_main_elements || device->id >= CFArrayGetCount(device_main_elements))
+        return;
+
+    device_main_element = (IOHIDElementRef)CFArrayGetValueAtIndex(device_main_elements, device->id);
+    TRACE("device_main_element %s\n", debugstr_element(device_main_element));
+    if (!device_main_element)
+        return;
+
+    elements = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
+    get_element_children(device_main_element, elements);
+
+    if (elements)
+    {
+        CFIndex idx, cnt = CFArrayGetCount( elements );
+        CFMutableArrayRef axes = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
+        CFMutableArrayRef buttons = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
+        CFMutableArrayRef povs = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
+
+        for ( idx = 0; idx < cnt; idx++ )
+        {
+            IOHIDElementRef element = ( IOHIDElementRef ) CFArrayGetValueAtIndex( elements, idx );
+            int type = IOHIDElementGetType( element );
+            int usage_page = IOHIDElementGetUsagePage( element );
+
+            TRACE("element %s\n", debugstr_element(element));
+
+            if (usage_page >= kHIDPage_VendorDefinedStart)
+            {
+                /* vendor pages can repurpose type ids, resulting in incorrect case matches below (e.g. ds4 controllers) */
+                continue;
+            }
+
+            switch(type)
+            {
+                case kIOHIDElementTypeInput_Button:
+                {
+                    TRACE("kIOHIDElementTypeInput_Button usage_page %d\n", usage_page);
+                    if (usage_page != kHIDPage_Button)
+                    {
+                        /* avoid strange elements found on the 360 controller */
+                        continue;
+                    }
+
+                    if (CFArrayGetCount(buttons) < 128)
+                        CFArrayAppendValue(buttons, element);
+                    break;
+                }
+                case kIOHIDElementTypeInput_Axis:
+                {
+                    TRACE("kIOHIDElementTypeInput_Axis\n");
+                    CFArrayAppendValue(axes, element);
+                    break;
+                }
+                case kIOHIDElementTypeInput_Misc:
+                {
+                    uint32_t usage = IOHIDElementGetUsage( element );
+                    switch(usage)
+                    {
+                        case kHIDUsage_GD_Hatswitch:
+                        {
+                            TRACE("kIOHIDElementTypeInput_Misc / kHIDUsage_GD_Hatswitch\n");
+                            CFArrayAppendValue(povs, element);
+                            break;
+                        }
+                        case kHIDUsage_GD_Slider:
+                            sliders ++;
+                            if (sliders > 2)
+                                break;
+                            /* fallthrough, sliders are axis */
+                        case kHIDUsage_GD_X:
+                        case kHIDUsage_GD_Y:
+                        case kHIDUsage_GD_Z:
+                        case kHIDUsage_GD_Rx:
+                        case kHIDUsage_GD_Ry:
+                        case kHIDUsage_GD_Rz:
+                        {
+                            TRACE("kIOHIDElementTypeInput_Misc / kHIDUsage_GD_* (%d)\n", usage);
+                            axis_map[CFArrayGetCount(axes)]=usage;
+                            CFArrayAppendValue(axes, element);
+                            break;
+                        }
+                        default:
+                            FIXME("kIOHIDElementTypeInput_Misc / Unhandled usage %i\n", usage);
+                    }
+                    break;
+                }
+                default:
+                    FIXME("Unhandled type %i\n",type);
+            }
+        }
+
+        /* Sort buttons into correct order */
+        CFArraySortValues(buttons, CFRangeMake(0, CFArrayGetCount(buttons)), button_usage_comparator, NULL);
+
+        device->generic.devcaps.dwAxes = CFArrayGetCount(axes);
+        device->generic.devcaps.dwButtons = CFArrayGetCount(buttons);
+        device->generic.devcaps.dwPOVs = CFArrayGetCount(povs);
+
+        TRACE("axes %u povs %u buttons %u\n", device->generic.devcaps.dwAxes, device->generic.devcaps.dwPOVs,
+              device->generic.devcaps.dwButtons);
+
+        /* build our element array in the order that dinput expects */
+        CFArrayAppendArray(axes, povs, CFRangeMake(0, device->generic.devcaps.dwPOVs));
+        CFArrayAppendArray(axes, buttons, CFRangeMake(0, device->generic.devcaps.dwButtons));
+        device->elements = axes;
+        axes = NULL;
+
+        CFRelease(povs);
+        CFRelease(buttons);
+        CFRelease(elements);
+    }
+    else
+    {
+        device->generic.devcaps.dwAxes = 0;
+        device->generic.devcaps.dwButtons = 0;
+        device->generic.devcaps.dwPOVs = 0;
+    }
+}
+
+static void get_osx_device_elements_props(JoystickImpl *device)
+{
+    TRACE("device %p\n", device);
+
+    if (device->elements)
+    {
+        CFIndex idx, cnt = CFArrayGetCount( device->elements );
+
+        for ( idx = 0; idx < cnt; idx++ )
+        {
+            IOHIDElementRef element = ( IOHIDElementRef ) CFArrayGetValueAtIndex( device->elements, idx );
+
+            TRACE("element %s\n", debugstr_element(element));
+
+            device->generic.props[idx].lDevMin = IOHIDElementGetLogicalMin(element);
+            device->generic.props[idx].lDevMax = IOHIDElementGetLogicalMax(element);
+            device->generic.props[idx].lMin =  0;
+            device->generic.props[idx].lMax =  0xffff;
+            device->generic.props[idx].lDeadZone = 0;
+            device->generic.props[idx].lSaturation = 0;
+        }
+    }
+}
+
+static void poll_osx_device_state(LPDIRECTINPUTDEVICE8A iface)
+{
+    JoystickImpl *device = impl_from_IDirectInputDevice8A(iface);
+    IOHIDElementRef device_main_element;
+    IOHIDDeviceRef hid_device;
+
+    TRACE("device %p device->id %i\n", device, device->id);
+
+    if (!device_main_elements || device->id >= CFArrayGetCount(device_main_elements))
+        return;
+
+    device_main_element = (IOHIDElementRef) CFArrayGetValueAtIndex(device_main_elements, device->id);
+    hid_device = IOHIDElementGetDevice(device_main_element);
+    TRACE("main element %s hid_device %s\n", debugstr_element(device_main_element), debugstr_device(hid_device));
+    if (!hid_device)
+        return;
+
+    if (device->elements)
+    {
+        int button_idx = 0;
+        int pov_idx = 0;
+        int slider_idx = 0;
+        int inst_id;
+        CFIndex idx, cnt = CFArrayGetCount( device->elements );
+
+        for ( idx = 0; idx < cnt; idx++ )
+        {
+            IOHIDValueRef valueRef;
+            int val, oldVal, newVal;
+            IOHIDElementRef element = ( IOHIDElementRef ) CFArrayGetValueAtIndex( device->elements, idx );
+            int type = IOHIDElementGetType( element );
+
+            TRACE("element %s\n", debugstr_element(element));
+
+            switch(type)
+            {
+                case kIOHIDElementTypeInput_Button:
+                    TRACE("kIOHIDElementTypeInput_Button\n");
+                    if(button_idx < 128)
+                    {
+                        IOHIDDeviceGetValue(hid_device, element, &valueRef);
+                        val = IOHIDValueGetIntegerValue(valueRef);
+                        newVal = val ? 0x80 : 0x0;
+                        oldVal = device->generic.js.rgbButtons[button_idx];
+                        device->generic.js.rgbButtons[button_idx] = newVal;
+                        TRACE("valueRef %s val %d oldVal %d newVal %d\n", debugstr_cf(valueRef), val, oldVal, newVal);
+                        if (oldVal != newVal)
+                        {
+                            inst_id = DIDFT_MAKEINSTANCE(button_idx) | DIDFT_PSHBUTTON;
+                            queue_event(iface,inst_id,newVal,GetCurrentTime(),device->generic.base.dinput->evsequence++);
+                        }
+                        button_idx ++;
+                    }
+                    break;
+                case kIOHIDElementTypeInput_Misc:
+                {
+                    uint32_t usage = IOHIDElementGetUsage( element );
+                    switch(usage)
+                    {
+                        case kHIDUsage_GD_Hatswitch:
+                        {
+                            TRACE("kIOHIDElementTypeInput_Misc / kHIDUsage_GD_Hatswitch\n");
+                            IOHIDDeviceGetValue(hid_device, element, &valueRef);
+                            val = IOHIDValueGetIntegerValue(valueRef);
+                            oldVal = device->generic.js.rgdwPOV[pov_idx];
+                            if (val >= 8)
+                                newVal = -1;
+                            else
+                                newVal = val * 4500;
+                            device->generic.js.rgdwPOV[pov_idx] = newVal;
+                            TRACE("valueRef %s val %d oldVal %d newVal %d\n", debugstr_cf(valueRef), val, oldVal, newVal);
+                            if (oldVal != newVal)
+                            {
+                                inst_id = DIDFT_MAKEINSTANCE(pov_idx) | DIDFT_POV;
+                                queue_event(iface,inst_id,newVal,GetCurrentTime(),device->generic.base.dinput->evsequence++);
+                            }
+                            pov_idx ++;
+                            break;
+                        }
+                        case kHIDUsage_GD_X:
+                        case kHIDUsage_GD_Y:
+                        case kHIDUsage_GD_Z:
+                        case kHIDUsage_GD_Rx:
+                        case kHIDUsage_GD_Ry:
+                        case kHIDUsage_GD_Rz:
+                        case kHIDUsage_GD_Slider:
+                        {
+                            int wine_obj = -1;
+
+                            IOHIDDeviceGetValue(hid_device, element, &valueRef);
+                            val = IOHIDValueGetIntegerValue(valueRef);
+                            newVal = joystick_map_axis(&device->generic.props[idx], val);
+                            switch (usage)
+                            {
+                            case kHIDUsage_GD_X:
+                                TRACE("kIOHIDElementTypeInput_Misc / kHIDUsage_GD_X\n");
+                                wine_obj = 0;
+                                oldVal = device->generic.js.lX;
+                                device->generic.js.lX = newVal;
+                                break;
+                            case kHIDUsage_GD_Y:
+                                TRACE("kIOHIDElementTypeInput_Misc / kHIDUsage_GD_Y\n");
+                                wine_obj = 1;
+                                oldVal = device->generic.js.lY;
+                                device->generic.js.lY = newVal;
+                                break;
+                            case kHIDUsage_GD_Z:
+                                TRACE("kIOHIDElementTypeInput_Misc / kHIDUsage_GD_Z\n");
+                                wine_obj = 2;
+                                oldVal = device->generic.js.lZ;
+                                device->generic.js.lZ = newVal;
+                                break;
+                            case kHIDUsage_GD_Rx:
+                                TRACE("kIOHIDElementTypeInput_Misc / kHIDUsage_GD_Rx\n");
+                                wine_obj = 3;
+                                oldVal = device->generic.js.lRx;
+                                device->generic.js.lRx = newVal;
+                                break;
+                            case kHIDUsage_GD_Ry:
+                                TRACE("kIOHIDElementTypeInput_Misc / kHIDUsage_GD_Ry\n");
+                                wine_obj = 4;
+                                oldVal = device->generic.js.lRy;
+                                device->generic.js.lRy = newVal;
+                                break;
+                            case kHIDUsage_GD_Rz:
+                                TRACE("kIOHIDElementTypeInput_Misc / kHIDUsage_GD_Rz\n");
+                                wine_obj = 5;
+                                oldVal = device->generic.js.lRz;
+                                device->generic.js.lRz = newVal;
+                                break;
+                            case kHIDUsage_GD_Slider:
+                                TRACE("kIOHIDElementTypeInput_Misc / kHIDUsage_GD_Slider\n");
+                                wine_obj = 6 + slider_idx;
+                                oldVal = device->generic.js.rglSlider[slider_idx];
+                                device->generic.js.rglSlider[slider_idx] = newVal;
+                                slider_idx ++;
+                                break;
+                            }
+                            TRACE("valueRef %s val %d oldVal %d newVal %d\n", debugstr_cf(valueRef), val, oldVal, newVal);
+                            if ((wine_obj != -1) &&
+                                 (oldVal != newVal))
+                            {
+                                inst_id = DIDFT_MAKEINSTANCE(wine_obj) | DIDFT_ABSAXIS;
+                                queue_event(iface,inst_id,newVal,GetCurrentTime(),device->generic.base.dinput->evsequence++);
+                            }
+
+                            break;
+                        }
+                        default:
+                            FIXME("kIOHIDElementTypeInput_Misc / unhandled usage %i\n", usage);
+                    }
+                    break;
+                }
+                default:
+                    FIXME("Unhandled type %i\n",type);
+            }
+        }
+    }
+}
+
+static INT find_joystick_devices(void)
+{
+    static INT joystick_devices_count = -1;
+
+    if (joystick_devices_count != -1) return joystick_devices_count;
+
+    joystick_devices_count = find_osx_devices();
+
+    return  joystick_devices_count;
+}
+
+static HRESULT joydev_enum_deviceA(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEA lpddi, DWORD version, int id)
+{
+    TRACE("dwDevType %u dwFlags 0x%08x version 0x%04x id %d\n", dwDevType, dwFlags, version, id);
+
+    if (id >= find_joystick_devices()) return E_FAIL;
+
+    if ((dwDevType == 0) ||
+    ((dwDevType == DIDEVTYPE_JOYSTICK) && (version > 0x0300 && version < 0x0800)) ||
+    (((dwDevType == DI8DEVCLASS_GAMECTRL) || (dwDevType == DI8DEVTYPE_JOYSTICK)) && (version >= 0x0800)))
+    {
+        if (dwFlags & DIEDFL_FORCEFEEDBACK) {
+            IOHIDDeviceRef device = get_device_ref(id);
+            if(!device)
+                return S_FALSE;
+            if(get_ff(device, NULL) != S_OK)
+                return S_FALSE;
+        }
+        /* Return joystick */
+        lpddi->guidInstance = DInput_Wine_OsX_Joystick_GUID;
+        lpddi->guidInstance.Data3 = id;
+        lpddi->guidProduct = DInput_Wine_OsX_Joystick_GUID;
+        /* we only support traditional joysticks for now */
+        if (version >= 0x0800)
+            lpddi->dwDevType = DI8DEVTYPE_JOYSTICK | (DI8DEVTYPEJOYSTICK_STANDARD << 8);
+        else
+            lpddi->dwDevType = DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_TRADITIONAL << 8);
+        sprintf(lpddi->tszInstanceName, "Joystick %d", id);
+
+        /* get the device name */
+        get_osx_device_name(id, lpddi->tszProductName, MAX_PATH);
+
+        lpddi->guidFFDriver = GUID_NULL;
+        return S_OK;
+    }
+
+    return S_FALSE;
+}
+
+static HRESULT joydev_enum_deviceW(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEW lpddi, DWORD version, int id)
+{
+    char name[MAX_PATH];
+    char friendly[32];
+
+    TRACE("dwDevType %u dwFlags 0x%08x version 0x%04x id %d\n", dwDevType, dwFlags, version, id);
+
+    if (id >= find_joystick_devices()) return E_FAIL;
+
+    if ((dwDevType == 0) ||
+    ((dwDevType == DIDEVTYPE_JOYSTICK) && (version > 0x0300 && version < 0x0800)) ||
+    (((dwDevType == DI8DEVCLASS_GAMECTRL) || (dwDevType == DI8DEVTYPE_JOYSTICK)) && (version >= 0x0800))) {
+        if (dwFlags & DIEDFL_FORCEFEEDBACK) {
+            IOHIDDeviceRef device = get_device_ref(id);
+            if(!device)
+                return S_FALSE;
+            if(get_ff(device, NULL) != S_OK)
+                return S_FALSE;
+        }
+        /* Return joystick */
+        lpddi->guidInstance = DInput_Wine_OsX_Joystick_GUID;
+        lpddi->guidInstance.Data3 = id;
+        lpddi->guidProduct = DInput_Wine_OsX_Joystick_GUID;
+        /* we only support traditional joysticks for now */
+        if (version >= 0x0800)
+            lpddi->dwDevType = DI8DEVTYPE_JOYSTICK | (DI8DEVTYPEJOYSTICK_STANDARD << 8);
+        else
+            lpddi->dwDevType = DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_TRADITIONAL << 8);
+        sprintf(friendly, "Joystick %d", id);
+        MultiByteToWideChar(CP_ACP, 0, friendly, -1, lpddi->tszInstanceName, MAX_PATH);
+        /* get the device name */
+        get_osx_device_name(id, name, MAX_PATH);
+
+        MultiByteToWideChar(CP_ACP, 0, name, -1, lpddi->tszProductName, MAX_PATH);
+        lpddi->guidFFDriver = GUID_NULL;
+        return S_OK;
+    }
+
+    return S_FALSE;
+}
+
+static const char *osx_ff_axis_name(UInt8 axis)
+{
+    static char ret[6];
+    switch(axis){
+    case FFJOFS_X:
+        return "FFJOFS_X";
+    case FFJOFS_Y:
+        return "FFJOFS_Y";
+    case FFJOFS_Z:
+        return "FFJOFS_Z";
+    }
+    sprintf(ret, "%u", (unsigned int)axis);
+    return ret;
+}
+
+static BOOL osx_axis_has_ff(FFCAPABILITIES *ffcaps, UInt8 axis)
+{
+    int i;
+    for(i = 0; i < ffcaps->numFfAxes; ++i)
+        if(ffcaps->ffAxes[i] == axis)
+            return TRUE;
+    return FALSE;
+}
+
+static HRESULT alloc_device(REFGUID rguid, IDirectInputImpl *dinput,
+                            JoystickImpl **pdev, unsigned short index)
+{
+    DWORD i;
+    IOHIDDeviceRef device;
+    JoystickImpl* newDevice;
+    char name[MAX_PATH];
+    HRESULT hr;
+    LPDIDATAFORMAT df = NULL;
+    int idx = 0;
+    int axis_map[8]; /* max axes */
+    int slider_count = 0;
+    FFCAPABILITIES ffcaps;
+
+    TRACE("%s %p %p %hu\n", debugstr_guid(rguid), dinput, pdev, index);
+
+    newDevice = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(JoystickImpl));
+    if (newDevice == 0) {
+        WARN("out of memory\n");
+        *pdev = 0;
+        return DIERR_OUTOFMEMORY;
+    }
+
+    newDevice->id = index;
+
+    newDevice->generic.guidInstance = DInput_Wine_OsX_Joystick_GUID;
+    newDevice->generic.guidInstance.Data3 = index;
+    newDevice->generic.guidProduct = DInput_Wine_OsX_Joystick_GUID;
+    newDevice->generic.joy_polldev = poll_osx_device_state;
+
+    /* get the device name */
+    get_osx_device_name(index, name, MAX_PATH);
+    TRACE("Name %s\n",name);
+
+    /* copy the device name */
+    newDevice->generic.name = HeapAlloc(GetProcessHeap(),0,strlen(name) + 1);
+    strcpy(newDevice->generic.name, name);
+
+    list_init(&newDevice->effects);
+    device = get_device_ref(index);
+    if(get_ff(device, &newDevice->ff) == S_OK){
+        newDevice->generic.devcaps.dwFlags |= DIDC_FORCEFEEDBACK;
+
+        hr = FFDeviceGetForceFeedbackCapabilities(newDevice->ff, &ffcaps);
+        if(SUCCEEDED(hr)){
+            TRACE("FF Capabilities:\n");
+            TRACE("\tsupportedEffects: 0x%x\n", (unsigned int)ffcaps.supportedEffects);
+            TRACE("\temulatedEffects: 0x%x\n", (unsigned int)ffcaps.emulatedEffects);
+            TRACE("\tsubType: 0x%x\n", (unsigned int)ffcaps.subType);
+            TRACE("\tnumFfAxes: %u\n", (unsigned int)ffcaps.numFfAxes);
+            TRACE("\tffAxes: [");
+            for(i = 0; i < ffcaps.numFfAxes; ++i){
+                TRACE("%s", osx_ff_axis_name(ffcaps.ffAxes[i]));
+                if(i < ffcaps.numFfAxes - 1)
+                    TRACE(", ");
+            }
+            TRACE("]\n");
+            TRACE("\tstorageCapacity: %u\n", (unsigned int)ffcaps.storageCapacity);
+            TRACE("\tplaybackCapacity: %u\n", (unsigned int)ffcaps.playbackCapacity);
+        }
+
+        hr = FFDeviceSendForceFeedbackCommand(newDevice->ff, FFSFFC_RESET);
+        if(FAILED(hr))
+            WARN("FFDeviceSendForceFeedbackCommand(FFSFFC_RESET) failed: %08x\n", hr);
+
+        hr = FFDeviceSendForceFeedbackCommand(newDevice->ff, FFSFFC_SETACTUATORSON);
+        if(FAILED(hr))
+            WARN("FFDeviceSendForceFeedbackCommand(FFSFFC_SETACTUATORSON) failed: %08x\n", hr);
+    }
+
+    memset(axis_map, 0, sizeof(axis_map));
+    get_osx_device_elements(newDevice, axis_map);
+
+    TRACE("%i axes %i buttons %i povs\n",newDevice->generic.devcaps.dwAxes,newDevice->generic.devcaps.dwButtons,newDevice->generic.devcaps.dwPOVs);
+
+    if (newDevice->generic.devcaps.dwButtons > 128)
+    {
+        WARN("Can't support %d buttons. Clamping down to 128\n", newDevice->generic.devcaps.dwButtons);
+        newDevice->generic.devcaps.dwButtons = 128;
+    }
+
+    newDevice->generic.base.IDirectInputDevice8A_iface.lpVtbl = &JoystickAvt;
+    newDevice->generic.base.IDirectInputDevice8W_iface.lpVtbl = &JoystickWvt;
+    newDevice->generic.base.ref = 1;
+    newDevice->generic.base.dinput = dinput;
+    newDevice->generic.base.guid = *rguid;
+    InitializeCriticalSection(&newDevice->generic.base.crit);
+    newDevice->generic.base.crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": JoystickImpl*->generic.base.crit");
+
+    /* Create copy of default data format */
+    if (!(df = HeapAlloc(GetProcessHeap(), 0, c_dfDIJoystick2.dwSize))) goto FAILED;
+    memcpy(df, &c_dfDIJoystick2, c_dfDIJoystick2.dwSize);
+
+    df->dwNumObjs = newDevice->generic.devcaps.dwAxes + newDevice->generic.devcaps.dwPOVs + newDevice->generic.devcaps.dwButtons;
+    if (!(df->rgodf = HeapAlloc(GetProcessHeap(), 0, df->dwNumObjs * df->dwObjSize))) goto FAILED;
+
+    for (i = 0; i < newDevice->generic.devcaps.dwAxes; i++)
+    {
+        int wine_obj = -1;
+        BOOL has_ff  = FALSE;
+        switch (axis_map[i])
+        {
+            case kHIDUsage_GD_X:
+                wine_obj = 0;
+                has_ff = (newDevice->ff != 0) && osx_axis_has_ff(&ffcaps, FFJOFS_X);
+                break;
+            case kHIDUsage_GD_Y:
+                wine_obj = 1;
+                has_ff = (newDevice->ff != 0) && osx_axis_has_ff(&ffcaps, FFJOFS_Y);
+                break;
+            case kHIDUsage_GD_Z:
+                wine_obj = 2;
+                has_ff = (newDevice->ff != 0) && osx_axis_has_ff(&ffcaps, FFJOFS_Z);
+                break;
+            case kHIDUsage_GD_Rx:
+                wine_obj = 3;
+                has_ff = (newDevice->ff != 0) && osx_axis_has_ff(&ffcaps, FFJOFS_RX);
+                break;
+            case kHIDUsage_GD_Ry:
+                wine_obj = 4;
+                has_ff = (newDevice->ff != 0) && osx_axis_has_ff(&ffcaps, FFJOFS_RY);
+                break;
+            case kHIDUsage_GD_Rz:
+                wine_obj = 5;
+                has_ff = (newDevice->ff != 0) && osx_axis_has_ff(&ffcaps, FFJOFS_RZ);
+                break;
+            case kHIDUsage_GD_Slider:
+                wine_obj = 6 + slider_count;
+                has_ff = (newDevice->ff != 0) && osx_axis_has_ff(&ffcaps, FFJOFS_SLIDER(slider_count));
+                slider_count++;
+                break;
+        }
+        if (wine_obj < 0 ) continue;
+
+        memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[wine_obj], df->dwObjSize);
+        df->rgodf[idx].dwType = DIDFT_MAKEINSTANCE(wine_obj) | DIDFT_ABSAXIS;
+        if(has_ff)
+            df->rgodf[idx].dwFlags |= DIDOI_FFACTUATOR;
+        ++idx;
+    }
+
+    for (i = 0; i < newDevice->generic.devcaps.dwPOVs; i++)
+    {
+        memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[i + 8], df->dwObjSize);
+        df->rgodf[idx++].dwType = DIDFT_MAKEINSTANCE(i) | DIDFT_POV;
+    }
+
+    for (i = 0; i < newDevice->generic.devcaps.dwButtons; i++)
+    {
+        memcpy(&df->rgodf[idx], &c_dfDIJoystick2.rgodf[i + 12], df->dwObjSize);
+        df->rgodf[idx  ].pguid = &GUID_Button;
+        df->rgodf[idx++].dwType = DIDFT_MAKEINSTANCE(i) | DIDFT_PSHBUTTON;
+    }
+    newDevice->generic.base.data_format.wine_df = df;
+
+    /* initialize default properties */
+    get_osx_device_elements_props(newDevice);
+
+    IDirectInput_AddRef(&newDevice->generic.base.dinput->IDirectInput7A_iface);
+
+    EnterCriticalSection(&dinput->crit);
+    list_add_tail(&dinput->devices_list, &newDevice->generic.base.entry);
+    LeaveCriticalSection(&dinput->crit);
+
+    newDevice->generic.devcaps.dwSize = sizeof(newDevice->generic.devcaps);
+    newDevice->generic.devcaps.dwFlags |= DIDC_ATTACHED;
+    if (newDevice->generic.base.dinput->dwVersion >= 0x0800)
+        newDevice->generic.devcaps.dwDevType = DI8DEVTYPE_JOYSTICK | (DI8DEVTYPEJOYSTICK_STANDARD << 8);
+    else
+        newDevice->generic.devcaps.dwDevType = DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_TRADITIONAL << 8);
+    newDevice->generic.devcaps.dwFFSamplePeriod = 0;
+    newDevice->generic.devcaps.dwFFMinTimeResolution = 0;
+    newDevice->generic.devcaps.dwFirmwareRevision = 0;
+    newDevice->generic.devcaps.dwHardwareRevision = 0;
+    newDevice->generic.devcaps.dwFFDriverVersion = 0;
+
+    if (TRACE_ON(dinput)) {
+        TRACE("allocated device %p\n", newDevice);
+        _dump_DIDATAFORMAT(newDevice->generic.base.data_format.wine_df);
+        _dump_DIDEVCAPS(&newDevice->generic.devcaps);
+    }
+
+    *pdev = newDevice;
+
+    return DI_OK;
+
+FAILED:
+    hr = DIERR_OUTOFMEMORY;
+    if (newDevice->ff) FFReleaseDevice(newDevice->ff);
+    if (newDevice->elements) CFRelease(newDevice->elements);
+    if (df) HeapFree(GetProcessHeap(), 0, df->rgodf);
+    HeapFree(GetProcessHeap(), 0, df);
+    release_DataFormat(&newDevice->generic.base.data_format);
+    HeapFree(GetProcessHeap(),0,newDevice->generic.name);
+    HeapFree(GetProcessHeap(),0,newDevice);
+    *pdev = 0;
+
+    return hr;
+}
+
+/******************************************************************************
+  *     get_joystick_index : Get the joystick index from a given GUID
+  */
+static unsigned short get_joystick_index(REFGUID guid)
+{
+    GUID wine_joystick = DInput_Wine_OsX_Joystick_GUID;
+    GUID dev_guid = *guid;
+
+    wine_joystick.Data3 = 0;
+    dev_guid.Data3 = 0;
+
+    /* for the standard joystick GUID use index 0 */
+    if(IsEqualGUID(&GUID_Joystick,guid)) return 0;
+
+    /* for the wine joystick GUIDs use the index stored in Data3 */
+    if(IsEqualGUID(&wine_joystick, &dev_guid)) return guid->Data3;
+
+    return 0xffff;
+}
+
+static HRESULT joydev_create_device(IDirectInputImpl *dinput, REFGUID rguid, REFIID riid, LPVOID *pdev, int unicode)
+{
+    unsigned short index;
+    int joystick_devices_count;
+
+    TRACE("%p %s %s %p %i\n", dinput, debugstr_guid(rguid), debugstr_guid(riid), pdev, unicode);
+    *pdev = NULL;
+
+    if ((joystick_devices_count = find_joystick_devices()) == 0)
+        return DIERR_DEVICENOTREG;
+
+    if ((index = get_joystick_index(rguid)) < 0xffff &&
+        joystick_devices_count && index < joystick_devices_count)
+    {
+        JoystickImpl *This;
+        HRESULT hr;
+
+        if (riid == NULL)
+            ;/* nothing */
+        else if (IsEqualGUID(&IID_IDirectInputDeviceA,  riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice2A, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice7A, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice8A, riid))
+        {
+            unicode = 0;
+        }
+        else if (IsEqualGUID(&IID_IDirectInputDeviceW,  riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice2W, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice7W, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice8W, riid))
+        {
+            unicode = 1;
+        }
+        else
+        {
+            WARN("no interface\n");
+            return DIERR_NOINTERFACE;
+        }
+
+        hr = alloc_device(rguid, dinput, &This, index);
+        if (!This) return hr;
+
+        if (unicode)
+            *pdev = &This->generic.base.IDirectInputDevice8W_iface;
+        else
+            *pdev = &This->generic.base.IDirectInputDevice8A_iface;
+        return hr;
+    }
+
+    return DIERR_DEVICENOTREG;
+}
+
+static HRESULT osx_set_autocenter(JoystickImpl *This,
+        const DIPROPDWORD *header)
+{
+    UInt32 v;
+    HRESULT hr;
+    if(!This->ff)
+        return DIERR_UNSUPPORTED;
+    v = header->dwData;
+    hr = osx_to_win32_hresult(FFDeviceSetForceFeedbackProperty(This->ff, FFPROP_AUTOCENTER, &v));
+    TRACE("returning: %08x\n", hr);
+    return hr;
+}
+
+static HRESULT osx_set_ffgain(JoystickImpl *This, const DIPROPDWORD *header)
+{
+    UInt32 v;
+    HRESULT hr;
+    if(!This->ff)
+        return DIERR_UNSUPPORTED;
+    v = header->dwData;
+    hr = osx_to_win32_hresult(FFDeviceSetForceFeedbackProperty(This->ff, FFPROP_FFGAIN, &v));
+    TRACE("returning: %08x\n", hr);
+    return hr;
+}
+
+static HRESULT WINAPI JoystickWImpl_SetProperty(IDirectInputDevice8W *iface,
+        const GUID *prop, const DIPROPHEADER *header)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("%p %s %p\n", This, debugstr_guid(prop), header);
+
+    switch(LOWORD(prop))
+    {
+    case (DWORD_PTR)DIPROP_AUTOCENTER:
+        return osx_set_autocenter(This, (const DIPROPDWORD *)header);
+    case (DWORD_PTR)DIPROP_FFGAIN:
+        return osx_set_ffgain(This, (const DIPROPDWORD *)header);
+    }
+
+    return JoystickWGenericImpl_SetProperty(iface, prop, header);
+}
+
+static HRESULT WINAPI JoystickAImpl_SetProperty(IDirectInputDevice8A *iface,
+        const GUID *prop, const DIPROPHEADER *header)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+
+    TRACE("%p %s %p\n", This, debugstr_guid(prop), header);
+
+    switch(LOWORD(prop))
+    {
+    case (DWORD_PTR)DIPROP_AUTOCENTER:
+        return osx_set_autocenter(This, (const DIPROPDWORD *)header);
+    case (DWORD_PTR)DIPROP_FFGAIN:
+        return osx_set_ffgain(This, (const DIPROPDWORD *)header);
+    }
+
+    return JoystickAGenericImpl_SetProperty(iface, prop, header);
+}
+
+static CFUUIDRef effect_win_to_mac(const GUID *effect)
+{
+#define DO_MAP(X) \
+    if(IsEqualGUID(&GUID_##X, effect)) \
+        return kFFEffectType_##X##_ID;
+    DO_MAP(ConstantForce)
+    DO_MAP(RampForce)
+    DO_MAP(Square)
+    DO_MAP(Sine)
+    DO_MAP(Triangle)
+    DO_MAP(SawtoothUp)
+    DO_MAP(SawtoothDown)
+    DO_MAP(Spring)
+    DO_MAP(Damper)
+    DO_MAP(Inertia)
+    DO_MAP(Friction)
+    DO_MAP(CustomForce)
+#undef DO_MAP
+    WARN("Unknown effect GUID! %s\n", debugstr_guid(effect));
+    return 0;
+}
+
+static HRESULT WINAPI JoystickWImpl_CreateEffect(IDirectInputDevice8W *iface,
+        const GUID *type, const DIEFFECT *params, IDirectInputEffect **out,
+        IUnknown *outer)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+    EffectImpl *effect;
+    HRESULT hr;
+
+    TRACE("%p %s %p %p %p\n", iface, debugstr_guid(type), params, out, outer);
+    dump_DIEFFECT(params, type, 0);
+
+    if(!This->ff){
+        TRACE("No force feedback support\n");
+        *out = NULL;
+        return DIERR_UNSUPPORTED;
+    }
+
+    if(outer)
+        WARN("aggregation not implemented\n");
+
+    effect = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*This));
+    effect->IDirectInputEffect_iface.lpVtbl = &EffectVtbl;
+    effect->ref = 1;
+    effect->guid = *type;
+    effect->device = This;
+
+    /* Mac's FFEFFECT and Win's DIEFFECT are binary identical. */
+    hr = osx_to_win32_hresult(FFDeviceCreateEffect(This->ff,
+                effect_win_to_mac(type), (FFEFFECT*)params, &effect->effect));
+    if(FAILED(hr)){
+        WARN("FFDeviceCreateEffect failed: %08x\n", hr);
+        HeapFree(GetProcessHeap(), 0, effect);
+        return hr;
+    }
+
+    list_add_tail(&This->effects, &effect->entry);
+    *out = &effect->IDirectInputEffect_iface;
+
+    TRACE("allocated effect: %p\n", effect);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI JoystickAImpl_CreateEffect(IDirectInputDevice8A *iface,
+        const GUID *type, const DIEFFECT *params, IDirectInputEffect **out,
+        IUnknown *outer)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+
+    TRACE("%p %s %p %p %p\n", iface, debugstr_guid(type), params, out, outer);
+
+    return JoystickWImpl_CreateEffect(&This->generic.base.IDirectInputDevice8W_iface,
+            type, params, out, outer);
+}
+
+static HRESULT WINAPI JoystickWImpl_SendForceFeedbackCommand(IDirectInputDevice8W *iface,
+        DWORD flags)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8W(iface);
+    HRESULT hr;
+
+    TRACE("%p 0x%x\n", This, flags);
+
+    if(!This->ff)
+        return DI_NOEFFECT;
+
+    hr = osx_to_win32_hresult(FFDeviceSendForceFeedbackCommand(This->ff, flags));
+    if(FAILED(hr)){
+        WARN("FFDeviceSendForceFeedbackCommand failed: %08x\n", hr);
+        return hr;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI JoystickAImpl_SendForceFeedbackCommand(IDirectInputDevice8A *iface,
+        DWORD flags)
+{
+    JoystickImpl *This = impl_from_IDirectInputDevice8A(iface);
+
+    TRACE("%p 0x%x\n", This, flags);
+
+    return JoystickWImpl_SendForceFeedbackCommand(&This->generic.base.IDirectInputDevice8W_iface, flags);
+}
+
+const struct dinput_device joystick_osx_device = {
+  "Wine OS X joystick driver",
+  joydev_enum_deviceA,
+  joydev_enum_deviceW,
+  joydev_create_device
+};
+
+static const IDirectInputDevice8AVtbl JoystickAvt =
+{
+    IDirectInputDevice2AImpl_QueryInterface,
+    IDirectInputDevice2AImpl_AddRef,
+    IDirectInputDevice2AImpl_Release,
+    JoystickAGenericImpl_GetCapabilities,
+    IDirectInputDevice2AImpl_EnumObjects,
+    JoystickAGenericImpl_GetProperty,
+    JoystickAImpl_SetProperty,
+    IDirectInputDevice2AImpl_Acquire,
+    IDirectInputDevice2AImpl_Unacquire,
+    JoystickAGenericImpl_GetDeviceState,
+    IDirectInputDevice2AImpl_GetDeviceData,
+    IDirectInputDevice2AImpl_SetDataFormat,
+    IDirectInputDevice2AImpl_SetEventNotification,
+    IDirectInputDevice2AImpl_SetCooperativeLevel,
+    JoystickAGenericImpl_GetObjectInfo,
+    JoystickAGenericImpl_GetDeviceInfo,
+    IDirectInputDevice2AImpl_RunControlPanel,
+    IDirectInputDevice2AImpl_Initialize,
+    JoystickAImpl_CreateEffect,
+    IDirectInputDevice2AImpl_EnumEffects,
+    IDirectInputDevice2AImpl_GetEffectInfo,
+    IDirectInputDevice2AImpl_GetForceFeedbackState,
+    JoystickAImpl_SendForceFeedbackCommand,
+    IDirectInputDevice2AImpl_EnumCreatedEffectObjects,
+    IDirectInputDevice2AImpl_Escape,
+    JoystickAGenericImpl_Poll,
+    IDirectInputDevice2AImpl_SendDeviceData,
+    IDirectInputDevice7AImpl_EnumEffectsInFile,
+    IDirectInputDevice7AImpl_WriteEffectToFile,
+    JoystickAGenericImpl_BuildActionMap,
+    JoystickAGenericImpl_SetActionMap,
+    IDirectInputDevice8AImpl_GetImageInfo
+};
+
+static const IDirectInputDevice8WVtbl JoystickWvt =
+{
+    IDirectInputDevice2WImpl_QueryInterface,
+    IDirectInputDevice2WImpl_AddRef,
+    IDirectInputDevice2WImpl_Release,
+    JoystickWGenericImpl_GetCapabilities,
+    IDirectInputDevice2WImpl_EnumObjects,
+    JoystickWGenericImpl_GetProperty,
+    JoystickWImpl_SetProperty,
+    IDirectInputDevice2WImpl_Acquire,
+    IDirectInputDevice2WImpl_Unacquire,
+    JoystickWGenericImpl_GetDeviceState,
+    IDirectInputDevice2WImpl_GetDeviceData,
+    IDirectInputDevice2WImpl_SetDataFormat,
+    IDirectInputDevice2WImpl_SetEventNotification,
+    IDirectInputDevice2WImpl_SetCooperativeLevel,
+    JoystickWGenericImpl_GetObjectInfo,
+    JoystickWGenericImpl_GetDeviceInfo,
+    IDirectInputDevice2WImpl_RunControlPanel,
+    IDirectInputDevice2WImpl_Initialize,
+    JoystickWImpl_CreateEffect,
+    IDirectInputDevice2WImpl_EnumEffects,
+    IDirectInputDevice2WImpl_GetEffectInfo,
+    IDirectInputDevice2WImpl_GetForceFeedbackState,
+    JoystickWImpl_SendForceFeedbackCommand,
+    IDirectInputDevice2WImpl_EnumCreatedEffectObjects,
+    IDirectInputDevice2WImpl_Escape,
+    JoystickWGenericImpl_Poll,
+    IDirectInputDevice2WImpl_SendDeviceData,
+    IDirectInputDevice7WImpl_EnumEffectsInFile,
+    IDirectInputDevice7WImpl_WriteEffectToFile,
+    JoystickWGenericImpl_BuildActionMap,
+    JoystickWGenericImpl_SetActionMap,
+    IDirectInputDevice8WImpl_GetImageInfo
+};
+
+static HRESULT WINAPI effect_QueryInterface(IDirectInputEffect *iface,
+        const GUID *guid, void **out)
+{
+    EffectImpl *This = impl_from_IDirectInputEffect(iface);
+
+    TRACE("%p %s %p\n", This, debugstr_guid(guid), out);
+
+    if(IsEqualIID(guid, &IID_IUnknown) || IsEqualIID(guid, &IID_IDirectInputEffect)){
+        *out = iface;
+        IDirectInputEffect_AddRef(iface);
+        return S_OK;
+    }
+
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI effect_AddRef(IDirectInputEffect *iface)
+{
+    EffectImpl *This = impl_from_IDirectInputEffect(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
+    TRACE("%p, ref is now: %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI effect_Release(IDirectInputEffect *iface)
+{
+    EffectImpl *This = impl_from_IDirectInputEffect(iface);
+    ULONG ref = InterlockedDecrement(&This->ref);
+    TRACE("%p, ref is now: %u\n", This, ref);
+
+    if(!ref){
+        list_remove(&This->entry);
+        FFDeviceReleaseEffect(This->device->ff, This->effect);
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI effect_Initialize(IDirectInputEffect *iface, HINSTANCE hinst,
+        DWORD version, const GUID *guid)
+{
+    EffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("%p %p 0x%x, %s\n", This, hinst, version, debugstr_guid(guid));
+    return S_OK;
+}
+
+static HRESULT WINAPI effect_GetEffectGuid(IDirectInputEffect *iface, GUID *out)
+{
+    EffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("%p %p\n", This, out);
+    *out = This->guid;
+    return S_OK;
+}
+
+static HRESULT WINAPI effect_GetParameters(IDirectInputEffect *iface,
+        DIEFFECT *effect, DWORD flags)
+{
+    EffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("%p %p 0x%x\n", This, effect, flags);
+    return osx_to_win32_hresult(FFEffectGetParameters(This->effect, (FFEFFECT*)effect, flags));
+}
+
+static HRESULT WINAPI effect_SetParameters(IDirectInputEffect *iface,
+        const DIEFFECT *effect, DWORD flags)
+{
+    EffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("%p %p 0x%x\n", This, effect, flags);
+    dump_DIEFFECT(effect, &This->guid, flags);
+    return osx_to_win32_hresult(FFEffectSetParameters(This->effect, (FFEFFECT*)effect, flags));
+}
+
+static HRESULT WINAPI effect_Start(IDirectInputEffect *iface, DWORD iterations,
+        DWORD flags)
+{
+    EffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("%p 0x%x 0x%x\n", This, iterations, flags);
+    return osx_to_win32_hresult(FFEffectStart(This->effect, iterations, flags));
+}
+
+static HRESULT WINAPI effect_Stop(IDirectInputEffect *iface)
+{
+    EffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("%p\n", This);
+    return osx_to_win32_hresult(FFEffectStop(This->effect));
+}
+
+static HRESULT WINAPI effect_GetEffectStatus(IDirectInputEffect *iface, DWORD *flags)
+{
+    EffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("%p %p\n", This, flags);
+    return osx_to_win32_hresult(FFEffectGetEffectStatus(This->effect, (UInt32*)flags));
+}
+
+static HRESULT WINAPI effect_Download(IDirectInputEffect *iface)
+{
+    EffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("%p\n", This);
+    return osx_to_win32_hresult(FFEffectDownload(This->effect));
+}
+
+static HRESULT WINAPI effect_Unload(IDirectInputEffect *iface)
+{
+    EffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("%p\n", This);
+    return osx_to_win32_hresult(FFEffectUnload(This->effect));
+}
+
+static HRESULT WINAPI effect_Escape(IDirectInputEffect *iface, DIEFFESCAPE *escape)
+{
+    EffectImpl *This = impl_from_IDirectInputEffect(iface);
+    TRACE("%p %p\n", This, escape);
+    return osx_to_win32_hresult(FFEffectEscape(This->effect, (FFEFFESCAPE*)escape));
+}
+
+static const IDirectInputEffectVtbl EffectVtbl = {
+    effect_QueryInterface,
+    effect_AddRef,
+    effect_Release,
+    effect_Initialize,
+    effect_GetEffectGuid,
+    effect_GetParameters,
+    effect_SetParameters,
+    effect_Start,
+    effect_Stop,
+    effect_GetEffectStatus,
+    effect_Download,
+    effect_Unload,
+    effect_Escape
+};
+
+#else /* HAVE_IOHIDMANAGERCREATE */
+
+const struct dinput_device joystick_osx_device = {
+  "Wine OS X joystick driver",
+  NULL,
+  NULL,
+  NULL
+};
+
+#endif /* HAVE_IOHIDMANAGERCREATE */
diff --git a/dlls/dinput8/joystick_private.h b/dlls/dinput8/joystick_private.h
new file mode 100644
index 0000000..e758cac
--- /dev/null
+++ b/dlls/dinput8/joystick_private.h
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2009, Aric Stewart, CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_DLLS_DINPUT_JOYSTICK_PRIVATE_H
+#define __WINE_DLLS_DINPUT_JOYSTICK_PRIVATE_H
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "dinput.h"
+#include "wine/list.h"
+#include "wine/unicode.h"
+#include "dinput_private.h"
+#include "device_private.h"
+
+/* Number of objects in the default data format */
+#define MAX_PROPS 164
+struct JoystickGenericImpl;
+
+typedef void joy_polldev_handler(LPDIRECTINPUTDEVICE8A iface);
+
+typedef struct JoystickGenericImpl
+{
+    struct IDirectInputDeviceImpl base;
+
+    ObjProps    props[MAX_PROPS];
+    DIDEVCAPS   devcaps;
+    DIJOYSTATE2 js;     /* wine data */
+    GUID        guidProduct;
+    GUID        guidInstance;
+    char        *name;
+    int         device_axis_count;      /* Total number of axes in the device */
+    int        *axis_map;               /* User axes remapping */
+    LONG        deadzone;               /* Default dead-zone */
+
+    joy_polldev_handler *joy_polldev;
+} JoystickGenericImpl;
+
+LONG joystick_map_axis(ObjProps *props, int val) DECLSPEC_HIDDEN;
+HRESULT setup_dinput_options(JoystickGenericImpl *This, const int *default_axis_map) DECLSPEC_HIDDEN;
+
+DWORD joystick_map_pov(const POINTL *p) DECLSPEC_HIDDEN;
+
+BOOL device_disabled_registry(const char* name) DECLSPEC_HIDDEN;
+
+HRESULT WINAPI JoystickWGenericImpl_GetObjectInfo(LPDIRECTINPUTDEVICE8W iface,
+        LPDIDEVICEOBJECTINSTANCEW pdidoi, DWORD dwObj, DWORD dwHow) DECLSPEC_HIDDEN;
+
+HRESULT WINAPI JoystickAGenericImpl_GetObjectInfo(LPDIRECTINPUTDEVICE8A iface,
+        LPDIDEVICEOBJECTINSTANCEA pdidoi, DWORD dwObj, DWORD dwHow) DECLSPEC_HIDDEN;
+
+HRESULT WINAPI JoystickAGenericImpl_GetProperty(LPDIRECTINPUTDEVICE8A iface, REFGUID rguid, LPDIPROPHEADER pdiph) DECLSPEC_HIDDEN;
+HRESULT WINAPI JoystickWGenericImpl_GetProperty(LPDIRECTINPUTDEVICE8W iface, REFGUID rguid, LPDIPROPHEADER pdiph) DECLSPEC_HIDDEN;
+
+HRESULT WINAPI JoystickAGenericImpl_GetCapabilities(LPDIRECTINPUTDEVICE8A iface, LPDIDEVCAPS lpDIDevCaps) DECLSPEC_HIDDEN;
+HRESULT WINAPI JoystickWGenericImpl_GetCapabilities(LPDIRECTINPUTDEVICE8W iface, LPDIDEVCAPS lpDIDevCaps) DECLSPEC_HIDDEN;
+
+void _dump_DIDEVCAPS(const DIDEVCAPS *lpDIDevCaps) DECLSPEC_HIDDEN;
+
+HRESULT WINAPI JoystickAGenericImpl_SetProperty(LPDIRECTINPUTDEVICE8A iface, REFGUID rguid, LPCDIPROPHEADER ph) DECLSPEC_HIDDEN;
+HRESULT WINAPI JoystickWGenericImpl_SetProperty(LPDIRECTINPUTDEVICE8W iface, REFGUID rguid, LPCDIPROPHEADER ph) DECLSPEC_HIDDEN;
+
+HRESULT WINAPI JoystickAGenericImpl_GetDeviceInfo( LPDIRECTINPUTDEVICE8A iface,
+    LPDIDEVICEINSTANCEA pdidi) DECLSPEC_HIDDEN;
+
+HRESULT WINAPI JoystickWGenericImpl_GetDeviceInfo( LPDIRECTINPUTDEVICE8W iface,
+    LPDIDEVICEINSTANCEW pdidi) DECLSPEC_HIDDEN;
+
+HRESULT WINAPI JoystickAGenericImpl_Poll(LPDIRECTINPUTDEVICE8A iface) DECLSPEC_HIDDEN;
+HRESULT WINAPI JoystickWGenericImpl_Poll(LPDIRECTINPUTDEVICE8W iface) DECLSPEC_HIDDEN;
+
+HRESULT WINAPI JoystickAGenericImpl_GetDeviceState(LPDIRECTINPUTDEVICE8A iface, DWORD len, LPVOID ptr) DECLSPEC_HIDDEN;
+HRESULT WINAPI JoystickWGenericImpl_GetDeviceState(LPDIRECTINPUTDEVICE8W iface, DWORD len, LPVOID ptr) DECLSPEC_HIDDEN;
+
+HRESULT WINAPI JoystickAGenericImpl_BuildActionMap(LPDIRECTINPUTDEVICE8A iface, LPDIACTIONFORMATA lpdiaf, LPCSTR lpszUserName, DWORD dwFlags) DECLSPEC_HIDDEN;
+HRESULT WINAPI JoystickWGenericImpl_BuildActionMap(LPDIRECTINPUTDEVICE8W iface, LPDIACTIONFORMATW lpdiaf, LPCWSTR lpszUserName, DWORD dwFlags) DECLSPEC_HIDDEN;
+
+HRESULT WINAPI JoystickAGenericImpl_SetActionMap(LPDIRECTINPUTDEVICE8A iface, LPDIACTIONFORMATA lpdiaf, LPCSTR lpszUserName, DWORD dwFlags) DECLSPEC_HIDDEN;
+HRESULT WINAPI JoystickWGenericImpl_SetActionMap(LPDIRECTINPUTDEVICE8W iface, LPDIACTIONFORMATW lpdiaf, LPCWSTR lpszUserName, DWORD dwFlags) DECLSPEC_HIDDEN;
+
+DWORD typeFromGUID(REFGUID guid) DECLSPEC_HIDDEN;
+void dump_DIEFFECT(LPCDIEFFECT eff, REFGUID guid, DWORD dwFlags) DECLSPEC_HIDDEN;
+
+#endif /* __WINE_DLLS_DINPUT_JOYSTICK_PRIVATE_H */
diff --git a/dlls/dinput8/keyboard.c b/dlls/dinput8/keyboard.c
new file mode 100644
index 0000000..8a59ce0
--- /dev/null
+++ b/dlls/dinput8/keyboard.c
@@ -0,0 +1,689 @@
+/*		DirectInput Keyboard device
+ *
+ * Copyright 1998 Marcus Meissner
+ * Copyright 1998,1999 Lionel Ulmer
+ * Copyright 2000-2001 TransGaming Technologies Inc.
+ * Copyright 2005 Raphael Junqueira
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include <stdarg.h>
+#include <string.h>
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+#include "winerror.h"
+#include "dinput.h"
+
+#include "dinput_private.h"
+#include "device_private.h"
+#include "wine/debug.h"
+#include "wine/unicode.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dinput);
+
+#define WINE_DINPUT_KEYBOARD_MAX_KEYS 256
+
+static const IDirectInputDevice8AVtbl SysKeyboardAvt;
+static const IDirectInputDevice8WVtbl SysKeyboardWvt;
+
+typedef struct SysKeyboardImpl SysKeyboardImpl;
+struct SysKeyboardImpl
+{
+    struct IDirectInputDeviceImpl base;
+    BYTE DInputKeyState[WINE_DINPUT_KEYBOARD_MAX_KEYS];
+};
+
+static inline SysKeyboardImpl *impl_from_IDirectInputDevice8A(IDirectInputDevice8A *iface)
+{
+    return CONTAINING_RECORD(CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8A_iface), SysKeyboardImpl, base);
+}
+static inline SysKeyboardImpl *impl_from_IDirectInputDevice8W(IDirectInputDevice8W *iface)
+{
+    return CONTAINING_RECORD(CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8W_iface), SysKeyboardImpl, base);
+}
+static inline IDirectInputDevice8A *IDirectInputDevice8A_from_impl(SysKeyboardImpl *This)
+{
+    return &This->base.IDirectInputDevice8A_iface;
+}
+static inline IDirectInputDevice8W *IDirectInputDevice8W_from_impl(SysKeyboardImpl *This)
+{
+    return &This->base.IDirectInputDevice8W_iface;
+}
+
+static BYTE map_dik_code(DWORD scanCode, DWORD vkCode)
+{
+    if (!scanCode)
+        scanCode = MapVirtualKeyW(vkCode, MAPVK_VK_TO_VSC);
+
+    return scanCode;
+}
+
+static int KeyboardCallback( LPDIRECTINPUTDEVICE8A iface, WPARAM wparam, LPARAM lparam )
+{
+    SysKeyboardImpl *This = impl_from_IDirectInputDevice8A(iface);
+    int dik_code, ret = This->base.dwCoopLevel & DISCL_EXCLUSIVE;
+    KBDLLHOOKSTRUCT *hook = (KBDLLHOOKSTRUCT *)lparam;
+    BYTE new_diks;
+
+    if (wparam != WM_KEYDOWN && wparam != WM_KEYUP &&
+        wparam != WM_SYSKEYDOWN && wparam != WM_SYSKEYUP)
+        return 0;
+
+    TRACE("(%p) wp %08lx, lp %08lx, vk %02x, scan %02x\n",
+          iface, wparam, lparam, hook->vkCode, hook->scanCode);
+
+    switch (hook->vkCode)
+    {
+        /* R-Shift is special - it is an extended key with separate scan code */
+        case VK_RSHIFT  : dik_code = DIK_RSHIFT; break;
+        case VK_PAUSE   : dik_code = DIK_PAUSE; break;
+        case VK_NUMLOCK : dik_code = DIK_NUMLOCK; break;
+        case VK_SUBTRACT: dik_code = DIK_SUBTRACT; break;
+        default:
+            dik_code = map_dik_code(hook->scanCode & 0xff, hook->vkCode);
+            if (hook->flags & LLKHF_EXTENDED) dik_code |= 0x80;
+    }
+    new_diks = hook->flags & LLKHF_UP ? 0 : 0x80;
+
+    /* returns now if key event already known */
+    if (new_diks == This->DInputKeyState[dik_code])
+        return ret;
+
+    This->DInputKeyState[dik_code] = new_diks;
+    TRACE(" setting %02X to %02X\n", dik_code, This->DInputKeyState[dik_code]);
+
+    EnterCriticalSection(&This->base.crit);
+    queue_event(iface, DIDFT_MAKEINSTANCE(dik_code) | DIDFT_PSHBUTTON,
+                new_diks, GetCurrentTime(), This->base.dinput->evsequence++);
+    LeaveCriticalSection(&This->base.crit);
+
+    return ret;
+}
+
+const GUID DInput_Wine_Keyboard_GUID = { /* 0ab8648a-7735-11d2-8c73-71df54a96441 */
+    0x0ab8648a, 0x7735, 0x11d2, {0x8c, 0x73, 0x71, 0xdf, 0x54, 0xa9, 0x64, 0x41}
+};
+
+static void fill_keyboard_dideviceinstanceA(LPDIDEVICEINSTANCEA lpddi, DWORD version) {
+    DWORD dwSize;
+    DIDEVICEINSTANCEA ddi;
+    
+    dwSize = lpddi->dwSize;
+
+    TRACE("%d %p\n", dwSize, lpddi);
+    
+    memset(lpddi, 0, dwSize);
+    memset(&ddi, 0, sizeof(ddi));
+
+    ddi.dwSize = dwSize;
+    ddi.guidInstance = GUID_SysKeyboard;/* DInput's GUID */
+    ddi.guidProduct = DInput_Wine_Keyboard_GUID; /* Vendor's GUID */
+    if (version >= 0x0800)
+        ddi.dwDevType = DI8DEVTYPE_KEYBOARD | (DI8DEVTYPEKEYBOARD_UNKNOWN << 8);
+    else
+        ddi.dwDevType = DIDEVTYPE_KEYBOARD | (DIDEVTYPEKEYBOARD_UNKNOWN << 8);
+    strcpy(ddi.tszInstanceName, "Keyboard");
+    strcpy(ddi.tszProductName, "Wine Keyboard");
+
+    memcpy(lpddi, &ddi, (dwSize < sizeof(ddi) ? dwSize : sizeof(ddi)));
+}
+
+static void fill_keyboard_dideviceinstanceW(LPDIDEVICEINSTANCEW lpddi, DWORD version) {
+    DWORD dwSize;
+    DIDEVICEINSTANCEW ddi;
+    
+    dwSize = lpddi->dwSize;
+
+    TRACE("%d %p\n", dwSize, lpddi);
+    
+    memset(lpddi, 0, dwSize);
+    memset(&ddi, 0, sizeof(ddi));
+ 
+    ddi.dwSize = dwSize;
+    ddi.guidInstance = GUID_SysKeyboard;/* DInput's GUID */
+    ddi.guidProduct = DInput_Wine_Keyboard_GUID; /* Vendor's GUID */
+    if (version >= 0x0800)
+        ddi.dwDevType = DI8DEVTYPE_KEYBOARD | (DI8DEVTYPEKEYBOARD_UNKNOWN << 8);
+    else
+        ddi.dwDevType = DIDEVTYPE_KEYBOARD | (DIDEVTYPEKEYBOARD_UNKNOWN << 8);
+    MultiByteToWideChar(CP_ACP, 0, "Keyboard", -1, ddi.tszInstanceName, MAX_PATH);
+    MultiByteToWideChar(CP_ACP, 0, "Wine Keyboard", -1, ddi.tszProductName, MAX_PATH);
+
+    memcpy(lpddi, &ddi, (dwSize < sizeof(ddi) ? dwSize : sizeof(ddi)));
+}
+ 
+static HRESULT keyboarddev_enum_deviceA(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEA lpddi, DWORD version, int id)
+{
+  if (id != 0)
+    return E_FAIL;
+
+  if ((dwDevType == 0) ||
+      ((dwDevType == DIDEVTYPE_KEYBOARD) && (version < 0x0800)) ||
+      (((dwDevType == DI8DEVCLASS_KEYBOARD) || (dwDevType == DI8DEVTYPE_KEYBOARD)) && (version >= 0x0800))) {
+    TRACE("Enumerating the Keyboard device\n");
+ 
+    fill_keyboard_dideviceinstanceA(lpddi, version);
+    
+    return S_OK;
+  }
+
+  return S_FALSE;
+}
+
+static HRESULT keyboarddev_enum_deviceW(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEW lpddi, DWORD version, int id)
+{
+  if (id != 0)
+    return E_FAIL;
+
+  if ((dwDevType == 0) ||
+      ((dwDevType == DIDEVTYPE_KEYBOARD) && (version < 0x0800)) ||
+      (((dwDevType == DI8DEVCLASS_KEYBOARD) || (dwDevType == DI8DEVTYPE_KEYBOARD)) && (version >= 0x0800))) {
+    TRACE("Enumerating the Keyboard device\n");
+
+    fill_keyboard_dideviceinstanceW(lpddi, version);
+    
+    return S_OK;
+  }
+
+  return S_FALSE;
+}
+
+static SysKeyboardImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput)
+{
+    SysKeyboardImpl* newDevice;
+    LPDIDATAFORMAT df = NULL;
+    int i, idx = 0;
+
+    newDevice = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(SysKeyboardImpl));
+    newDevice->base.IDirectInputDevice8A_iface.lpVtbl = &SysKeyboardAvt;
+    newDevice->base.IDirectInputDevice8W_iface.lpVtbl = &SysKeyboardWvt;
+    newDevice->base.ref = 1;
+    memcpy(&newDevice->base.guid, rguid, sizeof(*rguid));
+    newDevice->base.dinput = dinput;
+    newDevice->base.event_proc = KeyboardCallback;
+    InitializeCriticalSection(&newDevice->base.crit);
+    newDevice->base.crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": SysKeyboardImpl*->base.crit");
+
+    /* Create copy of default data format */
+    if (!(df = HeapAlloc(GetProcessHeap(), 0, c_dfDIKeyboard.dwSize))) goto failed;
+    memcpy(df, &c_dfDIKeyboard, c_dfDIKeyboard.dwSize);
+    if (!(df->rgodf = HeapAlloc(GetProcessHeap(), 0, df->dwNumObjs * df->dwObjSize))) goto failed;
+
+    for (i = 0; i < df->dwNumObjs; i++)
+    {
+        char buf[MAX_PATH];
+
+        if (!GetKeyNameTextA(((i & 0x7f) << 16) | ((i & 0x80) << 17), buf, sizeof(buf)))
+            continue;
+
+        memcpy(&df->rgodf[idx], &c_dfDIKeyboard.rgodf[i], df->dwObjSize);
+        df->rgodf[idx++].dwType = DIDFT_MAKEINSTANCE(i) | DIDFT_PSHBUTTON;
+    }
+    df->dwNumObjs = idx;
+
+    newDevice->base.data_format.wine_df = df;
+    IDirectInput_AddRef(&newDevice->base.dinput->IDirectInput7A_iface);
+
+    EnterCriticalSection(&dinput->crit);
+    list_add_tail(&dinput->devices_list, &newDevice->base.entry);
+    LeaveCriticalSection(&dinput->crit);
+
+    return newDevice;
+
+failed:
+    if (df) HeapFree(GetProcessHeap(), 0, df->rgodf);
+    HeapFree(GetProcessHeap(), 0, df);
+    HeapFree(GetProcessHeap(), 0, newDevice);
+    return NULL;
+}
+
+
+static HRESULT keyboarddev_create_device(IDirectInputImpl *dinput, REFGUID rguid, REFIID riid, LPVOID *pdev, int unicode)
+{
+    TRACE("%p %s %s %p %i\n", dinput, debugstr_guid(rguid), debugstr_guid(riid), pdev, unicode);
+    *pdev = NULL;
+
+    if (IsEqualGUID(&GUID_SysKeyboard, rguid) ||        /* Generic Keyboard */
+        IsEqualGUID(&DInput_Wine_Keyboard_GUID, rguid)) /* Wine Keyboard */
+    {
+        SysKeyboardImpl *This;
+
+        if (riid == NULL)
+            ;/* nothing */
+        else if (IsEqualGUID(&IID_IDirectInputDeviceA,  riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice2A, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice7A, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice8A, riid))
+        {
+            unicode = 0;
+        }
+        else if (IsEqualGUID(&IID_IDirectInputDeviceW,  riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice2W, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice7W, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice8W, riid))
+        {
+            unicode = 1;
+        }
+        else
+        {
+            WARN("no interface\n");
+            return DIERR_NOINTERFACE;
+        }
+
+        This = alloc_device(rguid, dinput);
+        TRACE("Created a Keyboard device (%p)\n", This);
+
+        if (!This) return DIERR_OUTOFMEMORY;
+
+        if (unicode)
+            *pdev = &This->base.IDirectInputDevice8W_iface;
+        else
+            *pdev = &This->base.IDirectInputDevice8A_iface;
+
+        return DI_OK;
+    }
+
+    return DIERR_DEVICENOTREG;
+}
+
+const struct dinput_device keyboard_device = {
+  "Wine keyboard driver",
+  keyboarddev_enum_deviceA,
+  keyboarddev_enum_deviceW,
+  keyboarddev_create_device
+};
+
+static HRESULT WINAPI SysKeyboardWImpl_GetDeviceState(LPDIRECTINPUTDEVICE8W iface, DWORD len, LPVOID ptr)
+{
+    SysKeyboardImpl *This = impl_from_IDirectInputDevice8W(iface);
+    TRACE("(%p)->(%d,%p)\n", This, len, ptr);
+
+    if (!This->base.acquired) return DIERR_NOTACQUIRED;
+
+    if (len != This->base.data_format.user_df->dwDataSize )
+        return DIERR_INVALIDPARAM;
+
+    check_dinput_events();
+
+    EnterCriticalSection(&This->base.crit);
+
+    if (TRACE_ON(dinput)) {
+	int i;
+	for (i = 0; i < WINE_DINPUT_KEYBOARD_MAX_KEYS; i++) {
+	    if (This->DInputKeyState[i] != 0x00)
+		TRACE(" - %02X: %02x\n", i, This->DInputKeyState[i]);
+	}
+    }
+
+    fill_DataFormat(ptr, len, This->DInputKeyState, &This->base.data_format);
+    LeaveCriticalSection(&This->base.crit);
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI SysKeyboardAImpl_GetDeviceState(LPDIRECTINPUTDEVICE8A iface, DWORD len, LPVOID ptr)
+{
+    SysKeyboardImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return SysKeyboardWImpl_GetDeviceState(IDirectInputDevice8W_from_impl(This), len, ptr);
+}
+
+/******************************************************************************
+  *     GetCapabilities : get the device capabilities
+  */
+static HRESULT WINAPI SysKeyboardWImpl_GetCapabilities(LPDIRECTINPUTDEVICE8W iface, LPDIDEVCAPS lpDIDevCaps)
+{
+    SysKeyboardImpl *This = impl_from_IDirectInputDevice8W(iface);
+    DIDEVCAPS devcaps;
+
+    TRACE("(this=%p,%p)\n",This,lpDIDevCaps);
+
+    if ((lpDIDevCaps->dwSize != sizeof(DIDEVCAPS)) && (lpDIDevCaps->dwSize != sizeof(DIDEVCAPS_DX3))) {
+        WARN("invalid parameter\n");
+        return DIERR_INVALIDPARAM;
+    }
+
+    devcaps.dwSize = lpDIDevCaps->dwSize;
+    devcaps.dwFlags = DIDC_ATTACHED | DIDC_EMULATED;
+    if (This->base.dinput->dwVersion >= 0x0800)
+        devcaps.dwDevType = DI8DEVTYPE_KEYBOARD | (DI8DEVTYPEKEYBOARD_PCENH << 8);
+    else
+        devcaps.dwDevType = DIDEVTYPE_KEYBOARD | (DIDEVTYPEKEYBOARD_PCENH << 8);
+    devcaps.dwAxes = 0;
+    devcaps.dwButtons = This->base.data_format.wine_df->dwNumObjs;
+    devcaps.dwPOVs = 0;
+    devcaps.dwFFSamplePeriod = 0;
+    devcaps.dwFFMinTimeResolution = 0;
+    devcaps.dwFirmwareRevision = 100;
+    devcaps.dwHardwareRevision = 100;
+    devcaps.dwFFDriverVersion = 0;
+
+    memcpy(lpDIDevCaps, &devcaps, lpDIDevCaps->dwSize);
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI SysKeyboardAImpl_GetCapabilities(LPDIRECTINPUTDEVICE8A iface, LPDIDEVCAPS lpDIDevCaps)
+{
+    SysKeyboardImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return SysKeyboardWImpl_GetCapabilities(IDirectInputDevice8W_from_impl(This), lpDIDevCaps);
+}
+
+/******************************************************************************
+  *     GetObjectInfo : get information about a device object such as a button
+  *                     or axis
+  */
+static HRESULT WINAPI
+SysKeyboardAImpl_GetObjectInfo(
+	LPDIRECTINPUTDEVICE8A iface,
+	LPDIDEVICEOBJECTINSTANCEA pdidoi,
+	DWORD dwObj,
+	DWORD dwHow)
+{
+    HRESULT res;
+    LONG scan;
+
+    res = IDirectInputDevice2AImpl_GetObjectInfo(iface, pdidoi, dwObj, dwHow);
+    if (res != DI_OK) return res;
+
+    scan = DIDFT_GETINSTANCE(pdidoi->dwType);
+    if (scan == DIK_PAUSE || scan == DIK_NUMLOCK) scan ^= 0x80;
+    if (!GetKeyNameTextA((scan & 0x80) << 17 | (scan & 0x7f) << 16,
+                         pdidoi->tszName, sizeof(pdidoi->tszName)))
+        return DIERR_OBJECTNOTFOUND;
+
+    _dump_OBJECTINSTANCEA(pdidoi);
+    return res;
+}
+
+static HRESULT WINAPI SysKeyboardWImpl_GetObjectInfo(LPDIRECTINPUTDEVICE8W iface,
+						     LPDIDEVICEOBJECTINSTANCEW pdidoi,
+						     DWORD dwObj,
+						     DWORD dwHow)
+{
+    HRESULT res;
+    LONG scan;
+
+    res = IDirectInputDevice2WImpl_GetObjectInfo(iface, pdidoi, dwObj, dwHow);
+    if (res != DI_OK) return res;
+
+    scan = DIDFT_GETINSTANCE(pdidoi->dwType);
+    if (scan == DIK_PAUSE || scan == DIK_NUMLOCK) scan ^= 0x80;
+    if (!GetKeyNameTextW((scan & 0x80) << 17 | (scan & 0x7f) << 16,
+                         pdidoi->tszName, sizeof(pdidoi->tszName)/sizeof(pdidoi->tszName[0])))
+        return DIERR_OBJECTNOTFOUND;
+
+    _dump_OBJECTINSTANCEW(pdidoi);
+    return res;
+}
+
+/******************************************************************************
+  *     GetDeviceInfo : get information about a device's identity
+  */
+static HRESULT WINAPI SysKeyboardAImpl_GetDeviceInfo(
+	LPDIRECTINPUTDEVICE8A iface,
+	LPDIDEVICEINSTANCEA pdidi)
+{
+    SysKeyboardImpl *This = impl_from_IDirectInputDevice8A(iface);
+    TRACE("(this=%p,%p)\n", This, pdidi);
+
+    if (pdidi->dwSize != sizeof(DIDEVICEINSTANCEA)) {
+        WARN(" dinput3 not supported yet...\n");
+	return DI_OK;
+    }
+
+    fill_keyboard_dideviceinstanceA(pdidi, This->base.dinput->dwVersion);
+    
+    return DI_OK;
+}
+
+static HRESULT WINAPI SysKeyboardWImpl_GetDeviceInfo(LPDIRECTINPUTDEVICE8W iface, LPDIDEVICEINSTANCEW pdidi)
+{
+    SysKeyboardImpl *This = impl_from_IDirectInputDevice8W(iface);
+    TRACE("(this=%p,%p)\n", This, pdidi);
+
+    if (pdidi->dwSize != sizeof(DIDEVICEINSTANCEW)) {
+        WARN(" dinput3 not supported yet...\n");
+	return DI_OK;
+    }
+
+    fill_keyboard_dideviceinstanceW(pdidi, This->base.dinput->dwVersion);
+    
+    return DI_OK;
+}
+
+/******************************************************************************
+ *      GetProperty : Retrieves information about the input device.
+ */
+static HRESULT WINAPI SysKeyboardWImpl_GetProperty(LPDIRECTINPUTDEVICE8W iface,
+                                                   REFGUID rguid, LPDIPROPHEADER pdiph)
+{
+    SysKeyboardImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(%p) %s,%p\n", iface, debugstr_guid(rguid), pdiph);
+    _dump_DIPROPHEADER(pdiph);
+
+    if (!IS_DIPROP(rguid)) return DI_OK;
+
+    switch (LOWORD(rguid))
+    {
+        case (DWORD_PTR)DIPROP_KEYNAME:
+        {
+            HRESULT hr;
+            LPDIPROPSTRING ps = (LPDIPROPSTRING)pdiph;
+            DIDEVICEOBJECTINSTANCEW didoi;
+
+            if (pdiph->dwSize != sizeof(DIPROPSTRING))
+                return DIERR_INVALIDPARAM;
+
+            didoi.dwSize = sizeof(DIDEVICEOBJECTINSTANCEW);
+
+            hr = SysKeyboardWImpl_GetObjectInfo(iface, &didoi, ps->diph.dwObj, ps->diph.dwHow);
+            if (hr == DI_OK)
+                memcpy(ps->wsz, didoi.tszName, sizeof(ps->wsz));
+            return hr;
+        }
+        case (DWORD_PTR) DIPROP_RANGE:
+            return DIERR_UNSUPPORTED;
+        default:
+            return IDirectInputDevice2AImpl_GetProperty( IDirectInputDevice8A_from_impl(This), rguid, pdiph );
+    }
+    return DI_OK;
+}
+
+static HRESULT WINAPI SysKeyboardAImpl_GetProperty(LPDIRECTINPUTDEVICE8A iface,
+                                                   REFGUID rguid, LPDIPROPHEADER pdiph)
+{
+    SysKeyboardImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return SysKeyboardWImpl_GetProperty(IDirectInputDevice8W_from_impl(This), rguid, pdiph);
+}
+
+static HRESULT WINAPI SysKeyboardWImpl_Acquire(LPDIRECTINPUTDEVICE8W iface)
+{
+    SysKeyboardImpl *This = impl_from_IDirectInputDevice8W(iface);
+    HRESULT res;
+
+    TRACE("(%p)\n", This);
+
+    res = IDirectInputDevice2WImpl_Acquire(iface);
+    if (res == DI_OK)
+    {
+        TRACE("clearing keystate\n");
+        memset(This->DInputKeyState, 0, sizeof(This->DInputKeyState));
+    }
+
+    return res;
+}
+
+static HRESULT WINAPI SysKeyboardAImpl_Acquire(LPDIRECTINPUTDEVICE8A iface)
+{
+    SysKeyboardImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return SysKeyboardWImpl_Acquire(IDirectInputDevice8W_from_impl(This));
+}
+
+static HRESULT WINAPI SysKeyboardWImpl_BuildActionMap(LPDIRECTINPUTDEVICE8W iface,
+                                                      LPDIACTIONFORMATW lpdiaf,
+                                                      LPCWSTR lpszUserName,
+                                                      DWORD dwFlags)
+{
+    FIXME("(%p)->(%p,%s,%08x): semi-stub !\n", iface, lpdiaf, debugstr_w(lpszUserName), dwFlags);
+
+    return  _build_action_map(iface, lpdiaf, lpszUserName, dwFlags, DIKEYBOARD_MASK, &c_dfDIKeyboard);
+}
+
+static HRESULT WINAPI SysKeyboardAImpl_BuildActionMap(LPDIRECTINPUTDEVICE8A iface,
+                                                      LPDIACTIONFORMATA lpdiaf,
+                                                      LPCSTR lpszUserName,
+                                                      DWORD dwFlags)
+{
+    SysKeyboardImpl *This = impl_from_IDirectInputDevice8A(iface);
+    DIACTIONFORMATW diafW;
+    HRESULT hr;
+    WCHAR *lpszUserNameW = NULL;
+    int username_size;
+
+    diafW.rgoAction = HeapAlloc(GetProcessHeap(), 0, sizeof(DIACTIONW)*lpdiaf->dwNumActions);
+    _copy_diactionformatAtoW(&diafW, lpdiaf);
+
+    if (lpszUserName != NULL)
+    {
+        username_size = MultiByteToWideChar(CP_ACP, 0, lpszUserName, -1, NULL, 0);
+        lpszUserNameW = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR)*username_size);
+        MultiByteToWideChar(CP_ACP, 0, lpszUserName, -1, lpszUserNameW, username_size);
+    }
+
+    hr = SysKeyboardWImpl_BuildActionMap(&This->base.IDirectInputDevice8W_iface, &diafW, lpszUserNameW, dwFlags);
+
+    _copy_diactionformatWtoA(lpdiaf, &diafW);
+    HeapFree(GetProcessHeap(), 0, diafW.rgoAction);
+    HeapFree(GetProcessHeap(), 0, lpszUserNameW);
+
+    return hr;
+}
+
+static HRESULT WINAPI SysKeyboardWImpl_SetActionMap(LPDIRECTINPUTDEVICE8W iface,
+                                                    LPDIACTIONFORMATW lpdiaf,
+                                                    LPCWSTR lpszUserName,
+                                                    DWORD dwFlags)
+{
+    FIXME("(%p)->(%p,%s,%08x): semi-stub !\n", iface, lpdiaf, debugstr_w(lpszUserName), dwFlags);
+
+    return _set_action_map(iface, lpdiaf, lpszUserName, dwFlags, &c_dfDIKeyboard);
+}
+
+static HRESULT WINAPI SysKeyboardAImpl_SetActionMap(LPDIRECTINPUTDEVICE8A iface,
+                                                    LPDIACTIONFORMATA lpdiaf,
+                                                    LPCSTR lpszUserName,
+                                                    DWORD dwFlags)
+{
+    SysKeyboardImpl *This = impl_from_IDirectInputDevice8A(iface);
+    DIACTIONFORMATW diafW;
+    HRESULT hr;
+    WCHAR *lpszUserNameW = NULL;
+    int username_size;
+
+    diafW.rgoAction = HeapAlloc(GetProcessHeap(), 0, sizeof(DIACTIONW)*lpdiaf->dwNumActions);
+    _copy_diactionformatAtoW(&diafW, lpdiaf);
+
+    if (lpszUserName != NULL)
+    {
+        username_size = MultiByteToWideChar(CP_ACP, 0, lpszUserName, -1, NULL, 0);
+        lpszUserNameW = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR)*username_size);
+        MultiByteToWideChar(CP_ACP, 0, lpszUserName, -1, lpszUserNameW, username_size);
+    }
+
+    hr = SysKeyboardWImpl_SetActionMap(&This->base.IDirectInputDevice8W_iface, &diafW, lpszUserNameW, dwFlags);
+
+    HeapFree(GetProcessHeap(), 0, diafW.rgoAction);
+    HeapFree(GetProcessHeap(), 0, lpszUserNameW);
+
+    return hr;
+}
+
+static const IDirectInputDevice8AVtbl SysKeyboardAvt =
+{
+    IDirectInputDevice2AImpl_QueryInterface,
+    IDirectInputDevice2AImpl_AddRef,
+    IDirectInputDevice2AImpl_Release,
+    SysKeyboardAImpl_GetCapabilities,
+    IDirectInputDevice2AImpl_EnumObjects,
+    SysKeyboardAImpl_GetProperty,
+    IDirectInputDevice2AImpl_SetProperty,
+    SysKeyboardAImpl_Acquire,
+    IDirectInputDevice2AImpl_Unacquire,
+    SysKeyboardAImpl_GetDeviceState,
+    IDirectInputDevice2AImpl_GetDeviceData,
+    IDirectInputDevice2AImpl_SetDataFormat,
+    IDirectInputDevice2AImpl_SetEventNotification,
+    IDirectInputDevice2AImpl_SetCooperativeLevel,
+    SysKeyboardAImpl_GetObjectInfo,
+    SysKeyboardAImpl_GetDeviceInfo,
+    IDirectInputDevice2AImpl_RunControlPanel,
+    IDirectInputDevice2AImpl_Initialize,
+    IDirectInputDevice2AImpl_CreateEffect,
+    IDirectInputDevice2AImpl_EnumEffects,
+    IDirectInputDevice2AImpl_GetEffectInfo,
+    IDirectInputDevice2AImpl_GetForceFeedbackState,
+    IDirectInputDevice2AImpl_SendForceFeedbackCommand,
+    IDirectInputDevice2AImpl_EnumCreatedEffectObjects,
+    IDirectInputDevice2AImpl_Escape,
+    IDirectInputDevice2AImpl_Poll,
+    IDirectInputDevice2AImpl_SendDeviceData,
+    IDirectInputDevice7AImpl_EnumEffectsInFile,
+    IDirectInputDevice7AImpl_WriteEffectToFile,
+    SysKeyboardAImpl_BuildActionMap,
+    SysKeyboardAImpl_SetActionMap,
+    IDirectInputDevice8AImpl_GetImageInfo
+};
+
+static const IDirectInputDevice8WVtbl SysKeyboardWvt =
+{
+    IDirectInputDevice2WImpl_QueryInterface,
+    IDirectInputDevice2WImpl_AddRef,
+    IDirectInputDevice2WImpl_Release,
+    SysKeyboardWImpl_GetCapabilities,
+    IDirectInputDevice2WImpl_EnumObjects,
+    SysKeyboardWImpl_GetProperty,
+    IDirectInputDevice2WImpl_SetProperty,
+    SysKeyboardWImpl_Acquire,
+    IDirectInputDevice2WImpl_Unacquire,
+    SysKeyboardWImpl_GetDeviceState,
+    IDirectInputDevice2WImpl_GetDeviceData,
+    IDirectInputDevice2WImpl_SetDataFormat,
+    IDirectInputDevice2WImpl_SetEventNotification,
+    IDirectInputDevice2WImpl_SetCooperativeLevel,
+    SysKeyboardWImpl_GetObjectInfo,
+    SysKeyboardWImpl_GetDeviceInfo,
+    IDirectInputDevice2WImpl_RunControlPanel,
+    IDirectInputDevice2WImpl_Initialize,
+    IDirectInputDevice2WImpl_CreateEffect,
+    IDirectInputDevice2WImpl_EnumEffects,
+    IDirectInputDevice2WImpl_GetEffectInfo,
+    IDirectInputDevice2WImpl_GetForceFeedbackState,
+    IDirectInputDevice2WImpl_SendForceFeedbackCommand,
+    IDirectInputDevice2WImpl_EnumCreatedEffectObjects,
+    IDirectInputDevice2WImpl_Escape,
+    IDirectInputDevice2WImpl_Poll,
+    IDirectInputDevice2WImpl_SendDeviceData,
+    IDirectInputDevice7WImpl_EnumEffectsInFile,
+    IDirectInputDevice7WImpl_WriteEffectToFile,
+    SysKeyboardWImpl_BuildActionMap,
+    SysKeyboardWImpl_SetActionMap,
+    IDirectInputDevice8WImpl_GetImageInfo
+};
diff --git a/dlls/dinput8/mouse.c b/dlls/dinput8/mouse.c
new file mode 100644
index 0000000..6d3eff5
--- /dev/null
+++ b/dlls/dinput8/mouse.c
@@ -0,0 +1,940 @@
+/*		DirectInput Mouse device
+ *
+ * Copyright 1998 Marcus Meissner
+ * Copyright 1998,1999 Lionel Ulmer
+ * Copyright 2000-2001 TransGaming Technologies Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include <stdarg.h>
+#include <string.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winuser.h"
+#include "winerror.h"
+#include "winreg.h"
+#include "dinput.h"
+
+#include "dinput_private.h"
+#include "device_private.h"
+#include "wine/debug.h"
+#include "wine/unicode.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dinput);
+
+/* Wine mouse driver object instances */
+#define WINE_MOUSE_X_AXIS_INSTANCE   0
+#define WINE_MOUSE_Y_AXIS_INSTANCE   1
+#define WINE_MOUSE_Z_AXIS_INSTANCE   2
+#define WINE_MOUSE_BUTTONS_INSTANCE  3
+
+static const IDirectInputDevice8AVtbl SysMouseAvt;
+static const IDirectInputDevice8WVtbl SysMouseWvt;
+
+typedef struct SysMouseImpl SysMouseImpl;
+
+typedef enum
+{
+    WARP_DEFAULT,
+    WARP_DISABLE,
+    WARP_FORCE_ON
+} WARP_MOUSE;
+
+struct SysMouseImpl
+{
+    struct IDirectInputDeviceImpl   base;
+
+    /* SysMouseAImpl */
+    /* These are used in case of relative -> absolute transitions */
+    POINT                           org_coords;
+    BOOL                            clipped;
+    /* warping: whether we need to move mouse back to middle once we
+     * reach window borders (for e.g. shooters, "surface movement" games) */
+    BOOL                            need_warp;
+    DWORD                           last_warped;
+
+    /* This is for mouse reporting. */
+    DIMOUSESTATE2                   m_state;
+
+    WARP_MOUSE                      warp_override;
+};
+
+static inline SysMouseImpl *impl_from_IDirectInputDevice8A(IDirectInputDevice8A *iface)
+{
+    return CONTAINING_RECORD(CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8A_iface), SysMouseImpl, base);
+}
+static inline SysMouseImpl *impl_from_IDirectInputDevice8W(IDirectInputDevice8W *iface)
+{
+    return CONTAINING_RECORD(CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8W_iface), SysMouseImpl, base);
+}
+
+static inline IDirectInputDevice8W *IDirectInputDevice8W_from_impl(SysMouseImpl *This)
+{
+    return &This->base.IDirectInputDevice8W_iface;
+}
+
+static int dinput_mouse_hook( LPDIRECTINPUTDEVICE8A iface, WPARAM wparam, LPARAM lparam );
+
+const GUID DInput_Wine_Mouse_GUID = { /* 9e573ed8-7734-11d2-8d4a-23903fb6bdf7 */
+    0x9e573ed8, 0x7734, 0x11d2, {0x8d, 0x4a, 0x23, 0x90, 0x3f, 0xb6, 0xbd, 0xf7}
+};
+
+static void _dump_mouse_state(const DIMOUSESTATE2 *m_state)
+{
+    int i;
+
+    if (!TRACE_ON(dinput)) return;
+
+    TRACE("(X: %d Y: %d Z: %d", m_state->lX, m_state->lY, m_state->lZ);
+    for (i = 0; i < 5; i++) TRACE(" B%d: %02x", i, m_state->rgbButtons[i]);
+    TRACE(")\n");
+}
+
+static void fill_mouse_dideviceinstanceA(LPDIDEVICEINSTANCEA lpddi, DWORD version) {
+    DWORD dwSize;
+    DIDEVICEINSTANCEA ddi;
+    
+    dwSize = lpddi->dwSize;
+
+    TRACE("%d %p\n", dwSize, lpddi);
+    
+    memset(lpddi, 0, dwSize);
+    memset(&ddi, 0, sizeof(ddi));
+
+    ddi.dwSize = dwSize;
+    ddi.guidInstance = GUID_SysMouse;/* DInput's GUID */
+    ddi.guidProduct = DInput_Wine_Mouse_GUID; /* Vendor's GUID */
+    if (version >= 0x0800)
+        ddi.dwDevType = DI8DEVTYPE_MOUSE | (DI8DEVTYPEMOUSE_TRADITIONAL << 8);
+    else
+        ddi.dwDevType = DIDEVTYPE_MOUSE | (DIDEVTYPEMOUSE_TRADITIONAL << 8);
+    strcpy(ddi.tszInstanceName, "Mouse");
+    strcpy(ddi.tszProductName, "Wine Mouse");
+
+    memcpy(lpddi, &ddi, (dwSize < sizeof(ddi) ? dwSize : sizeof(ddi)));
+}
+
+static void fill_mouse_dideviceinstanceW(LPDIDEVICEINSTANCEW lpddi, DWORD version) {
+    DWORD dwSize;
+    DIDEVICEINSTANCEW ddi;
+    
+    dwSize = lpddi->dwSize;
+
+    TRACE("%d %p\n", dwSize, lpddi);
+    
+    memset(lpddi, 0, dwSize);
+    memset(&ddi, 0, sizeof(ddi));
+
+    ddi.dwSize = dwSize;
+    ddi.guidInstance = GUID_SysMouse;/* DInput's GUID */
+    ddi.guidProduct = DInput_Wine_Mouse_GUID; /* Vendor's GUID */
+    if (version >= 0x0800)
+        ddi.dwDevType = DI8DEVTYPE_MOUSE | (DI8DEVTYPEMOUSE_TRADITIONAL << 8);
+    else
+        ddi.dwDevType = DIDEVTYPE_MOUSE | (DIDEVTYPEMOUSE_TRADITIONAL << 8);
+    MultiByteToWideChar(CP_ACP, 0, "Mouse", -1, ddi.tszInstanceName, MAX_PATH);
+    MultiByteToWideChar(CP_ACP, 0, "Wine Mouse", -1, ddi.tszProductName, MAX_PATH);
+
+    memcpy(lpddi, &ddi, (dwSize < sizeof(ddi) ? dwSize : sizeof(ddi)));
+}
+
+static HRESULT mousedev_enum_deviceA(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEA lpddi, DWORD version, int id)
+{
+    if (id != 0)
+        return E_FAIL;
+
+    if ((dwDevType == 0) ||
+	((dwDevType == DIDEVTYPE_MOUSE) && (version < 0x0800)) ||
+	(((dwDevType == DI8DEVCLASS_POINTER) || (dwDevType == DI8DEVTYPE_MOUSE)) && (version >= 0x0800))) {
+	TRACE("Enumerating the mouse device\n");
+	
+	fill_mouse_dideviceinstanceA(lpddi, version);
+	
+	return S_OK;
+    }
+    
+    return S_FALSE;
+}
+
+static HRESULT mousedev_enum_deviceW(DWORD dwDevType, DWORD dwFlags, LPDIDEVICEINSTANCEW lpddi, DWORD version, int id)
+{
+    if (id != 0)
+        return E_FAIL;
+
+    if ((dwDevType == 0) ||
+	((dwDevType == DIDEVTYPE_MOUSE) && (version < 0x0800)) ||
+	(((dwDevType == DI8DEVCLASS_POINTER) || (dwDevType == DI8DEVTYPE_MOUSE)) && (version >= 0x0800))) {
+	TRACE("Enumerating the mouse device\n");
+	
+	fill_mouse_dideviceinstanceW(lpddi, version);
+	
+	return S_OK;
+    }
+    
+    return S_FALSE;
+}
+
+static SysMouseImpl *alloc_device(REFGUID rguid, IDirectInputImpl *dinput)
+{
+    SysMouseImpl* newDevice;
+    LPDIDATAFORMAT df = NULL;
+    unsigned i;
+    char buffer[20];
+    HKEY hkey, appkey;
+
+    newDevice = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(SysMouseImpl));
+    if (!newDevice) return NULL;
+    newDevice->base.IDirectInputDevice8A_iface.lpVtbl = &SysMouseAvt;
+    newDevice->base.IDirectInputDevice8W_iface.lpVtbl = &SysMouseWvt;
+    newDevice->base.ref = 1;
+    newDevice->base.dwCoopLevel = DISCL_NONEXCLUSIVE | DISCL_BACKGROUND;
+    newDevice->base.guid = *rguid;
+    InitializeCriticalSection(&newDevice->base.crit);
+    newDevice->base.crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": SysMouseImpl*->base.crit");
+    newDevice->base.dinput = dinput;
+    newDevice->base.event_proc = dinput_mouse_hook;
+
+    get_app_key(&hkey, &appkey);
+    if (!get_config_key(hkey, appkey, "MouseWarpOverride", buffer, sizeof(buffer)))
+    {
+        if (!strcasecmp(buffer, "disable"))
+            newDevice->warp_override = WARP_DISABLE;
+        else if (!strcasecmp(buffer, "force"))
+            newDevice->warp_override = WARP_FORCE_ON;
+    }
+    if (appkey) RegCloseKey(appkey);
+    if (hkey) RegCloseKey(hkey);
+
+    /* Create copy of default data format */
+    if (!(df = HeapAlloc(GetProcessHeap(), 0, c_dfDIMouse2.dwSize))) goto failed;
+    memcpy(df, &c_dfDIMouse2, c_dfDIMouse2.dwSize);
+    if (!(df->rgodf = HeapAlloc(GetProcessHeap(), 0, df->dwNumObjs * df->dwObjSize))) goto failed;
+    memcpy(df->rgodf, c_dfDIMouse2.rgodf, df->dwNumObjs * df->dwObjSize);
+
+    /* Because we don't do any detection yet just modify instance and type */
+    for (i = 0; i < df->dwNumObjs; i++)
+        if (DIDFT_GETTYPE(df->rgodf[i].dwType) & DIDFT_AXIS)
+            df->rgodf[i].dwType = DIDFT_MAKEINSTANCE(i) | DIDFT_RELAXIS;
+        else
+            df->rgodf[i].dwType = DIDFT_MAKEINSTANCE(i) | DIDFT_PSHBUTTON;
+
+    newDevice->base.data_format.wine_df = df;
+    IDirectInput_AddRef(&newDevice->base.dinput->IDirectInput7A_iface);
+
+    EnterCriticalSection(&dinput->crit);
+    list_add_tail(&dinput->devices_list, &newDevice->base.entry);
+    LeaveCriticalSection(&dinput->crit);
+
+    return newDevice;
+
+failed:
+    if (df) HeapFree(GetProcessHeap(), 0, df->rgodf);
+    HeapFree(GetProcessHeap(), 0, df);
+    HeapFree(GetProcessHeap(), 0, newDevice);
+    return NULL;
+}
+
+static HRESULT mousedev_create_device(IDirectInputImpl *dinput, REFGUID rguid, REFIID riid, LPVOID *pdev, int unicode)
+{
+    TRACE("%p %s %s %p %i\n", dinput, debugstr_guid(rguid), debugstr_guid(riid), pdev, unicode);
+    *pdev = NULL;
+
+    if (IsEqualGUID(&GUID_SysMouse, rguid) ||        /* Generic Mouse */
+        IsEqualGUID(&DInput_Wine_Mouse_GUID, rguid)) /* Wine Mouse */
+    {
+        SysMouseImpl *This;
+
+        if (riid == NULL)
+            ;/* nothing */
+        else if (IsEqualGUID(&IID_IDirectInputDeviceA,  riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice2A, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice7A, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice8A, riid))
+        {
+            unicode = 0;
+        }
+        else if (IsEqualGUID(&IID_IDirectInputDeviceW,  riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice2W, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice7W, riid) ||
+                 IsEqualGUID(&IID_IDirectInputDevice8W, riid))
+        {
+            unicode = 1;
+        }
+        else
+        {
+            WARN("no interface\n");
+            return DIERR_NOINTERFACE;
+        }
+
+        This = alloc_device(rguid, dinput);
+        TRACE("Created a Mouse device (%p)\n", This);
+
+        if (!This) return DIERR_OUTOFMEMORY;
+
+        if (unicode)
+            *pdev = &This->base.IDirectInputDevice8W_iface;
+        else
+            *pdev = &This->base.IDirectInputDevice8A_iface;
+
+        return DI_OK;
+    }
+
+    return DIERR_DEVICENOTREG;
+}
+
+const struct dinput_device mouse_device = {
+    "Wine mouse driver",
+    mousedev_enum_deviceA,
+    mousedev_enum_deviceW,
+    mousedev_create_device
+};
+
+/******************************************************************************
+ *	SysMouseA (DInput Mouse support)
+ */
+
+/* low-level mouse hook */
+static int dinput_mouse_hook( LPDIRECTINPUTDEVICE8A iface, WPARAM wparam, LPARAM lparam )
+{
+    MSLLHOOKSTRUCT *hook = (MSLLHOOKSTRUCT *)lparam;
+    SysMouseImpl* This = impl_from_IDirectInputDevice8A(iface);
+    int wdata = 0, inst_id = -1, ret = 0;
+
+    TRACE("msg %lx @ (%d %d)\n", wparam, hook->pt.x, hook->pt.y);
+
+    EnterCriticalSection(&This->base.crit);
+
+    switch(wparam) {
+        case WM_MOUSEMOVE:
+        {
+            POINT pt, pt1;
+
+            GetCursorPos(&pt);
+            This->m_state.lX += pt.x = hook->pt.x - pt.x;
+            This->m_state.lY += pt.y = hook->pt.y - pt.y;
+
+            if (This->base.data_format.user_df->dwFlags & DIDF_ABSAXIS)
+            {
+                pt1.x = This->m_state.lX;
+                pt1.y = This->m_state.lY;
+            } else
+                pt1 = pt;
+
+            if (pt.x)
+            {
+                inst_id = DIDFT_MAKEINSTANCE(WINE_MOUSE_X_AXIS_INSTANCE) | DIDFT_RELAXIS;
+                wdata = pt1.x;
+            }
+            if (pt.y)
+            {
+                /* Already have X, need to queue it */
+                if (inst_id != -1)
+                    queue_event(iface, inst_id,
+                                wdata, GetCurrentTime(), This->base.dinput->evsequence);
+                inst_id = DIDFT_MAKEINSTANCE(WINE_MOUSE_Y_AXIS_INSTANCE) | DIDFT_RELAXIS;
+                wdata = pt1.y;
+            }
+
+            if (pt.x || pt.y)
+            {
+                if ((This->warp_override == WARP_FORCE_ON) ||
+                    (This->warp_override != WARP_DISABLE && (This->base.dwCoopLevel & DISCL_EXCLUSIVE)))
+                    This->need_warp = TRUE;
+            }
+            break;
+        }
+        case WM_MOUSEWHEEL:
+            inst_id = DIDFT_MAKEINSTANCE(WINE_MOUSE_Z_AXIS_INSTANCE) | DIDFT_RELAXIS;
+            This->m_state.lZ += wdata = (short)HIWORD(hook->mouseData);
+            /* FarCry crashes if it gets a mouse wheel message */
+            /* FIXME: should probably filter out other messages too */
+            ret = This->clipped;
+            break;
+        case WM_LBUTTONDOWN:
+            inst_id = DIDFT_MAKEINSTANCE(WINE_MOUSE_BUTTONS_INSTANCE + 0) | DIDFT_PSHBUTTON;
+            This->m_state.rgbButtons[0] = wdata = 0x80;
+	    break;
+	case WM_LBUTTONUP:
+            inst_id = DIDFT_MAKEINSTANCE(WINE_MOUSE_BUTTONS_INSTANCE + 0) | DIDFT_PSHBUTTON;
+            This->m_state.rgbButtons[0] = wdata = 0x00;
+	    break;
+	case WM_RBUTTONDOWN:
+            inst_id = DIDFT_MAKEINSTANCE(WINE_MOUSE_BUTTONS_INSTANCE + 1) | DIDFT_PSHBUTTON;
+            This->m_state.rgbButtons[1] = wdata = 0x80;
+	    break;
+	case WM_RBUTTONUP:
+            inst_id = DIDFT_MAKEINSTANCE(WINE_MOUSE_BUTTONS_INSTANCE + 1) | DIDFT_PSHBUTTON;
+            This->m_state.rgbButtons[1] = wdata = 0x00;
+	    break;
+	case WM_MBUTTONDOWN:
+            inst_id = DIDFT_MAKEINSTANCE(WINE_MOUSE_BUTTONS_INSTANCE + 2) | DIDFT_PSHBUTTON;
+            This->m_state.rgbButtons[2] = wdata = 0x80;
+	    break;
+	case WM_MBUTTONUP:
+            inst_id = DIDFT_MAKEINSTANCE(WINE_MOUSE_BUTTONS_INSTANCE + 2) | DIDFT_PSHBUTTON;
+            This->m_state.rgbButtons[2] = wdata = 0x00;
+	    break;
+        case WM_XBUTTONDOWN:
+            inst_id = DIDFT_MAKEINSTANCE(WINE_MOUSE_BUTTONS_INSTANCE + 2 + HIWORD(hook->mouseData)) | DIDFT_PSHBUTTON;
+            This->m_state.rgbButtons[2 + HIWORD(hook->mouseData)] = wdata = 0x80;
+            break;
+        case WM_XBUTTONUP:
+            inst_id = DIDFT_MAKEINSTANCE(WINE_MOUSE_BUTTONS_INSTANCE + 2 + HIWORD(hook->mouseData)) | DIDFT_PSHBUTTON;
+            This->m_state.rgbButtons[2 + HIWORD(hook->mouseData)] = wdata = 0x00;
+            break;
+    }
+
+
+    if (inst_id != -1)
+    {
+        _dump_mouse_state(&This->m_state);
+        queue_event(iface, inst_id,
+                    wdata, GetCurrentTime(), This->base.dinput->evsequence++);
+    }
+
+    LeaveCriticalSection(&This->base.crit);
+    return ret;
+}
+
+static void warp_check( SysMouseImpl* This, BOOL force )
+{
+    DWORD now = GetCurrentTime();
+    const DWORD interval = This->clipped ? 500 : 10;
+
+    if (force || (This->need_warp && (now - This->last_warped > interval)))
+    {
+        RECT rect, new_rect;
+        POINT mapped_center;
+
+        This->last_warped = now;
+        This->need_warp = FALSE;
+        if (!GetClientRect(This->base.win, &rect)) return;
+        MapWindowPoints( This->base.win, 0, (POINT *)&rect, 2 );
+        if (!This->clipped)
+        {
+            mapped_center.x = (rect.left + rect.right) / 2;
+            mapped_center.y = (rect.top + rect.bottom) / 2;
+            TRACE("Warping mouse to %d - %d\n", mapped_center.x, mapped_center.y);
+            SetCursorPos( mapped_center.x, mapped_center.y );
+        }
+        if (This->base.dwCoopLevel & DISCL_EXCLUSIVE)
+        {
+            /* make sure we clip even if the window covers the whole screen */
+            rect.left = max( rect.left, GetSystemMetrics( SM_XVIRTUALSCREEN ) + 1 );
+            rect.top = max( rect.top, GetSystemMetrics( SM_YVIRTUALSCREEN ) + 1 );
+            rect.right = min( rect.right, rect.left + GetSystemMetrics( SM_CXVIRTUALSCREEN ) - 2 );
+            rect.bottom = min( rect.bottom, rect.top + GetSystemMetrics( SM_CYVIRTUALSCREEN ) - 2 );
+            TRACE("Clipping mouse to %s\n", wine_dbgstr_rect( &rect ));
+            ClipCursor( &rect );
+            This->clipped = GetClipCursor( &new_rect ) && EqualRect( &rect, &new_rect );
+        }
+    }
+}
+
+
+/******************************************************************************
+  *     Acquire : gets exclusive control of the mouse
+  */
+static HRESULT WINAPI SysMouseWImpl_Acquire(LPDIRECTINPUTDEVICE8W iface)
+{
+    SysMouseImpl *This = impl_from_IDirectInputDevice8W(iface);
+    POINT point;
+    HRESULT res;
+
+    TRACE("(this=%p)\n",This);
+
+    if ((res = IDirectInputDevice2WImpl_Acquire(iface)) != DI_OK) return res;
+
+    /* Init the mouse state */
+    GetCursorPos( &point );
+    if (This->base.data_format.user_df->dwFlags & DIDF_ABSAXIS)
+    {
+      This->m_state.lX = point.x;
+      This->m_state.lY = point.y;
+    } else {
+      This->m_state.lX = 0;
+      This->m_state.lY = 0;
+      This->org_coords = point;
+    }
+    This->m_state.lZ = 0;
+    This->m_state.rgbButtons[0] = GetKeyState(VK_LBUTTON) & 0x80;
+    This->m_state.rgbButtons[1] = GetKeyState(VK_RBUTTON) & 0x80;
+    This->m_state.rgbButtons[2] = GetKeyState(VK_MBUTTON) & 0x80;
+
+    if (This->base.dwCoopLevel & DISCL_EXCLUSIVE)
+    {
+        ShowCursor(FALSE); /* hide cursor */
+        warp_check( This, TRUE );
+    }
+    else if (This->warp_override == WARP_FORCE_ON)
+    {
+        /* Need a window to warp mouse in. */
+        if (!This->base.win) This->base.win = GetDesktopWindow();
+        warp_check( This, TRUE );
+    }
+    else if (This->clipped)
+    {
+        ClipCursor( NULL );
+        This->clipped = FALSE;
+    }
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI SysMouseAImpl_Acquire(LPDIRECTINPUTDEVICE8A iface)
+{
+    SysMouseImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return SysMouseWImpl_Acquire(IDirectInputDevice8W_from_impl(This));
+}
+
+/******************************************************************************
+  *     Unacquire : frees the mouse
+  */
+static HRESULT WINAPI SysMouseWImpl_Unacquire(LPDIRECTINPUTDEVICE8W iface)
+{
+    SysMouseImpl *This = impl_from_IDirectInputDevice8W(iface);
+    HRESULT res;
+
+    TRACE("(this=%p)\n",This);
+
+    if ((res = IDirectInputDevice2WImpl_Unacquire(iface)) != DI_OK) return res;
+
+    if (This->base.dwCoopLevel & DISCL_EXCLUSIVE)
+    {
+        ClipCursor(NULL);
+        ShowCursor(TRUE); /* show cursor */
+        This->clipped = FALSE;
+    }
+
+    /* And put the mouse cursor back where it was at acquire time */
+    if (This->base.dwCoopLevel & DISCL_EXCLUSIVE || This->warp_override == WARP_FORCE_ON)
+    {
+        TRACE("warping mouse back to %s\n", wine_dbgstr_point(&This->org_coords));
+        SetCursorPos(This->org_coords.x, This->org_coords.y);
+    }
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI SysMouseAImpl_Unacquire(LPDIRECTINPUTDEVICE8A iface)
+{
+    SysMouseImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return SysMouseWImpl_Unacquire(IDirectInputDevice8W_from_impl(This));
+}
+
+/******************************************************************************
+  *     GetDeviceState : returns the "state" of the mouse.
+  *
+  *   For the moment, only the "standard" return structure (DIMOUSESTATE) is
+  *   supported.
+  */
+static HRESULT WINAPI SysMouseWImpl_GetDeviceState(LPDIRECTINPUTDEVICE8W iface, DWORD len, LPVOID ptr)
+{
+    SysMouseImpl *This = impl_from_IDirectInputDevice8W(iface);
+    TRACE("(%p)->(%u,%p)\n", This, len, ptr);
+
+    if(This->base.acquired == 0) return DIERR_NOTACQUIRED;
+
+    check_dinput_events();
+
+    EnterCriticalSection(&This->base.crit);
+    _dump_mouse_state(&This->m_state);
+
+    /* Copy the current mouse state */
+    fill_DataFormat(ptr, len, &This->m_state, &This->base.data_format);
+
+    /* Initialize the buffer when in relative mode */
+    if (!(This->base.data_format.user_df->dwFlags & DIDF_ABSAXIS))
+    {
+	This->m_state.lX = 0;
+	This->m_state.lY = 0;
+	This->m_state.lZ = 0;
+    }
+    LeaveCriticalSection(&This->base.crit);
+
+    warp_check( This, FALSE );
+    return DI_OK;
+}
+
+static HRESULT WINAPI SysMouseAImpl_GetDeviceState(LPDIRECTINPUTDEVICE8A iface, DWORD len, LPVOID ptr)
+{
+    SysMouseImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return SysMouseWImpl_GetDeviceState(IDirectInputDevice8W_from_impl(This), len, ptr);
+}
+
+/******************************************************************************
+  *     GetDeviceData : gets buffered input data.
+  */
+static HRESULT WINAPI SysMouseWImpl_GetDeviceData(LPDIRECTINPUTDEVICE8W iface,
+        DWORD dodsize, LPDIDEVICEOBJECTDATA dod, LPDWORD entries, DWORD flags)
+{
+    SysMouseImpl *This = impl_from_IDirectInputDevice8W(iface);
+    HRESULT res;
+
+    res = IDirectInputDevice2WImpl_GetDeviceData(iface, dodsize, dod, entries, flags);
+    if (SUCCEEDED(res)) warp_check( This, FALSE );
+    return res;
+}
+
+static HRESULT WINAPI SysMouseAImpl_GetDeviceData(LPDIRECTINPUTDEVICE8A iface,
+        DWORD dodsize, LPDIDEVICEOBJECTDATA dod, LPDWORD entries, DWORD flags)
+{
+    SysMouseImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return SysMouseWImpl_GetDeviceData(IDirectInputDevice8W_from_impl(This), dodsize, dod, entries, flags);
+}
+
+/******************************************************************************
+  *     GetProperty : get input device properties
+  */
+static HRESULT WINAPI SysMouseWImpl_GetProperty(LPDIRECTINPUTDEVICE8W iface, REFGUID rguid, LPDIPROPHEADER pdiph)
+{
+    SysMouseImpl *This = impl_from_IDirectInputDevice8W(iface);
+
+    TRACE("(%p) %s,%p\n", This, debugstr_guid(rguid), pdiph);
+    _dump_DIPROPHEADER(pdiph);
+
+    if (IS_DIPROP(rguid)) {
+	switch (LOWORD(rguid)) {
+	    case (DWORD_PTR) DIPROP_GRANULARITY: {
+		LPDIPROPDWORD pr = (LPDIPROPDWORD) pdiph;
+		
+		if (
+		    ((pdiph->dwHow == DIPH_BYOFFSET) &&
+		     ((pdiph->dwObj == DIMOFS_X) ||
+		      (pdiph->dwObj == DIMOFS_Y)))
+		    ||
+		    ((pdiph->dwHow == DIPH_BYID) &&
+		     ((pdiph->dwObj == (DIDFT_MAKEINSTANCE(WINE_MOUSE_X_AXIS_INSTANCE) | DIDFT_RELAXIS)) ||
+		      (pdiph->dwObj == (DIDFT_MAKEINSTANCE(WINE_MOUSE_Y_AXIS_INSTANCE) | DIDFT_RELAXIS))))
+		){
+		    /* Set granularity of X/Y Axis to 1. See MSDN on DIPROP_GRANULARITY */
+		    pr->dwData = 1;
+		} else {
+		    /* We'll just assume that the app asks about the Z axis */
+		    pr->dwData = WHEEL_DELTA;
+		}
+		
+		break;
+	    }
+	      
+	    case (DWORD_PTR) DIPROP_RANGE: {
+		LPDIPROPRANGE pr = (LPDIPROPRANGE) pdiph;
+		
+		if ((pdiph->dwHow == DIPH_BYID) &&
+		    ((pdiph->dwObj == (DIDFT_MAKEINSTANCE(WINE_MOUSE_X_AXIS_INSTANCE) | DIDFT_RELAXIS)) ||
+		     (pdiph->dwObj == (DIDFT_MAKEINSTANCE(WINE_MOUSE_Y_AXIS_INSTANCE) | DIDFT_RELAXIS)))) {
+		    /* Querying the range of either the X or the Y axis.  As I do
+		       not know the range, do as if the range were
+		       unrestricted...*/
+		    pr->lMin = DIPROPRANGE_NOMIN;
+		    pr->lMax = DIPROPRANGE_NOMAX;
+		}
+		
+		break;
+	    }
+
+	    default:
+                return IDirectInputDevice2WImpl_GetProperty(iface, rguid, pdiph);
+        }
+    }
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI SysMouseAImpl_GetProperty(LPDIRECTINPUTDEVICE8A iface, REFGUID rguid, LPDIPROPHEADER pdiph)
+{
+    SysMouseImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return SysMouseWImpl_GetProperty(IDirectInputDevice8W_from_impl(This), rguid, pdiph);
+}
+
+/******************************************************************************
+  *     GetCapabilities : get the device capabilities
+  */
+static HRESULT WINAPI SysMouseWImpl_GetCapabilities(LPDIRECTINPUTDEVICE8W iface, LPDIDEVCAPS lpDIDevCaps)
+{
+    SysMouseImpl *This = impl_from_IDirectInputDevice8W(iface);
+    DIDEVCAPS devcaps;
+
+    TRACE("(this=%p,%p)\n",This,lpDIDevCaps);
+
+    if ((lpDIDevCaps->dwSize != sizeof(DIDEVCAPS)) && (lpDIDevCaps->dwSize != sizeof(DIDEVCAPS_DX3))) {
+        WARN("invalid parameter\n");
+        return DIERR_INVALIDPARAM;
+    }
+
+    devcaps.dwSize = lpDIDevCaps->dwSize;
+    devcaps.dwFlags = DIDC_ATTACHED | DIDC_EMULATED;
+    if (This->base.dinput->dwVersion >= 0x0800)
+	devcaps.dwDevType = DI8DEVTYPE_MOUSE | (DI8DEVTYPEMOUSE_TRADITIONAL << 8);
+    else
+	devcaps.dwDevType = DIDEVTYPE_MOUSE | (DIDEVTYPEMOUSE_TRADITIONAL << 8);
+    devcaps.dwAxes = 3;
+    devcaps.dwButtons = 8;
+    devcaps.dwPOVs = 0;
+    devcaps.dwFFSamplePeriod = 0;
+    devcaps.dwFFMinTimeResolution = 0;
+    devcaps.dwFirmwareRevision = 100;
+    devcaps.dwHardwareRevision = 100;
+    devcaps.dwFFDriverVersion = 0;
+
+    memcpy(lpDIDevCaps, &devcaps, lpDIDevCaps->dwSize);
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI SysMouseAImpl_GetCapabilities(LPDIRECTINPUTDEVICE8A iface, LPDIDEVCAPS lpDIDevCaps)
+{
+    SysMouseImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return SysMouseWImpl_GetCapabilities(IDirectInputDevice8W_from_impl(This), lpDIDevCaps);
+}
+
+/******************************************************************************
+  *     GetObjectInfo : get information about a device object such as a button
+  *                     or axis
+  */
+static HRESULT WINAPI SysMouseWImpl_GetObjectInfo(LPDIRECTINPUTDEVICE8W iface,
+        LPDIDEVICEOBJECTINSTANCEW pdidoi, DWORD dwObj, DWORD dwHow)
+{
+    static const WCHAR x_axisW[] = {'X','-','A','x','i','s',0};
+    static const WCHAR y_axisW[] = {'Y','-','A','x','i','s',0};
+    static const WCHAR wheelW[] = {'W','h','e','e','l',0};
+    static const WCHAR buttonW[] = {'B','u','t','t','o','n',' ','%','d',0};
+    HRESULT res;
+
+    res = IDirectInputDevice2WImpl_GetObjectInfo(iface, pdidoi, dwObj, dwHow);
+    if (res != DI_OK) return res;
+
+    if      (IsEqualGUID(&pdidoi->guidType, &GUID_XAxis)) strcpyW(pdidoi->tszName, x_axisW);
+    else if (IsEqualGUID(&pdidoi->guidType, &GUID_YAxis)) strcpyW(pdidoi->tszName, y_axisW);
+    else if (IsEqualGUID(&pdidoi->guidType, &GUID_ZAxis)) strcpyW(pdidoi->tszName, wheelW);
+    else if (pdidoi->dwType & DIDFT_BUTTON)
+        wsprintfW(pdidoi->tszName, buttonW, DIDFT_GETINSTANCE(pdidoi->dwType) - 3);
+
+    _dump_OBJECTINSTANCEW(pdidoi);
+    return res;
+}
+
+static HRESULT WINAPI SysMouseAImpl_GetObjectInfo(LPDIRECTINPUTDEVICE8A iface,
+        LPDIDEVICEOBJECTINSTANCEA pdidoi, DWORD dwObj, DWORD dwHow)
+{
+    SysMouseImpl *This = impl_from_IDirectInputDevice8A(iface);
+    HRESULT res;
+    DIDEVICEOBJECTINSTANCEW didoiW;
+    DWORD dwSize = pdidoi->dwSize;
+
+    didoiW.dwSize = sizeof(didoiW);
+    res = SysMouseWImpl_GetObjectInfo(IDirectInputDevice8W_from_impl(This), &didoiW, dwObj, dwHow);
+    if (res != DI_OK) return res;
+
+    memset(pdidoi, 0, pdidoi->dwSize);
+    memcpy(pdidoi, &didoiW, FIELD_OFFSET(DIDEVICEOBJECTINSTANCEW, tszName));
+    pdidoi->dwSize = dwSize;
+    WideCharToMultiByte(CP_ACP, 0, didoiW.tszName, -1, pdidoi->tszName,
+                        sizeof(pdidoi->tszName), NULL, NULL);
+
+    return res;
+}
+
+/******************************************************************************
+  *     GetDeviceInfo : get information about a device's identity
+  */
+static HRESULT WINAPI SysMouseAImpl_GetDeviceInfo(
+	LPDIRECTINPUTDEVICE8A iface,
+	LPDIDEVICEINSTANCEA pdidi)
+{
+    SysMouseImpl *This = impl_from_IDirectInputDevice8A(iface);
+    TRACE("(this=%p,%p)\n", This, pdidi);
+
+    if (pdidi->dwSize != sizeof(DIDEVICEINSTANCEA)) {
+        WARN(" dinput3 not supported yet...\n");
+	return DI_OK;
+    }
+
+    fill_mouse_dideviceinstanceA(pdidi, This->base.dinput->dwVersion);
+    
+    return DI_OK;
+}
+
+static HRESULT WINAPI SysMouseWImpl_GetDeviceInfo(LPDIRECTINPUTDEVICE8W iface, LPDIDEVICEINSTANCEW pdidi)
+{
+    SysMouseImpl *This = impl_from_IDirectInputDevice8W(iface);
+    TRACE("(this=%p,%p)\n", This, pdidi);
+
+    if (pdidi->dwSize != sizeof(DIDEVICEINSTANCEW)) {
+        WARN(" dinput3 not supported yet...\n");
+	return DI_OK;
+    }
+
+    fill_mouse_dideviceinstanceW(pdidi, This->base.dinput->dwVersion);
+    
+    return DI_OK;
+}
+
+static HRESULT WINAPI SysMouseWImpl_BuildActionMap(LPDIRECTINPUTDEVICE8W iface,
+                                                   LPDIACTIONFORMATW lpdiaf,
+                                                   LPCWSTR lpszUserName,
+                                                   DWORD dwFlags)
+{
+    FIXME("(%p)->(%p,%s,%08x): semi-stub !\n", iface, lpdiaf, debugstr_w(lpszUserName), dwFlags);
+
+    return _build_action_map(iface, lpdiaf, lpszUserName, dwFlags, DIMOUSE_MASK, &c_dfDIMouse2);
+}
+
+static HRESULT WINAPI SysMouseAImpl_BuildActionMap(LPDIRECTINPUTDEVICE8A iface,
+                                                   LPDIACTIONFORMATA lpdiaf,
+                                                   LPCSTR lpszUserName,
+                                                   DWORD dwFlags)
+{
+    SysMouseImpl *This = impl_from_IDirectInputDevice8A(iface);
+    DIACTIONFORMATW diafW;
+    HRESULT hr;
+    WCHAR *lpszUserNameW = NULL;
+    int username_size;
+
+    diafW.rgoAction = HeapAlloc(GetProcessHeap(), 0, sizeof(DIACTIONW)*lpdiaf->dwNumActions);
+    _copy_diactionformatAtoW(&diafW, lpdiaf);
+
+    if (lpszUserName != NULL)
+    {
+        username_size = MultiByteToWideChar(CP_ACP, 0, lpszUserName, -1, NULL, 0);
+        lpszUserNameW = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR)*username_size);
+        MultiByteToWideChar(CP_ACP, 0, lpszUserName, -1, lpszUserNameW, username_size);
+    }
+
+    hr = SysMouseWImpl_BuildActionMap(&This->base.IDirectInputDevice8W_iface, &diafW, lpszUserNameW, dwFlags);
+
+    _copy_diactionformatWtoA(lpdiaf, &diafW);
+    HeapFree(GetProcessHeap(), 0, diafW.rgoAction);
+    HeapFree(GetProcessHeap(), 0, lpszUserNameW);
+
+    return hr;
+}
+
+static HRESULT WINAPI SysMouseWImpl_SetActionMap(LPDIRECTINPUTDEVICE8W iface,
+                                                 LPDIACTIONFORMATW lpdiaf,
+                                                 LPCWSTR lpszUserName,
+                                                 DWORD dwFlags)
+{
+    FIXME("(%p)->(%p,%s,%08x): semi-stub !\n", iface, lpdiaf, debugstr_w(lpszUserName), dwFlags);
+
+    return _set_action_map(iface, lpdiaf, lpszUserName, dwFlags, &c_dfDIMouse2);
+}
+
+static HRESULT WINAPI SysMouseAImpl_SetActionMap(LPDIRECTINPUTDEVICE8A iface,
+                                                 LPDIACTIONFORMATA lpdiaf,
+                                                 LPCSTR lpszUserName,
+                                                 DWORD dwFlags)
+{
+    SysMouseImpl *This = impl_from_IDirectInputDevice8A(iface);
+    DIACTIONFORMATW diafW;
+    HRESULT hr;
+    WCHAR *lpszUserNameW = NULL;
+    int username_size;
+
+    diafW.rgoAction = HeapAlloc(GetProcessHeap(), 0, sizeof(DIACTIONW)*lpdiaf->dwNumActions);
+    _copy_diactionformatAtoW(&diafW, lpdiaf);
+
+    if (lpszUserName != NULL)
+    {
+        username_size = MultiByteToWideChar(CP_ACP, 0, lpszUserName, -1, NULL, 0);
+        lpszUserNameW = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR)*username_size);
+        MultiByteToWideChar(CP_ACP, 0, lpszUserName, -1, lpszUserNameW, username_size);
+    }
+
+    hr = SysMouseWImpl_SetActionMap(&This->base.IDirectInputDevice8W_iface, &diafW, lpszUserNameW, dwFlags);
+
+    HeapFree(GetProcessHeap(), 0, diafW.rgoAction);
+    HeapFree(GetProcessHeap(), 0, lpszUserNameW);
+
+    return hr;
+}
+
+static const IDirectInputDevice8AVtbl SysMouseAvt =
+{
+    IDirectInputDevice2AImpl_QueryInterface,
+    IDirectInputDevice2AImpl_AddRef,
+    IDirectInputDevice2AImpl_Release,
+    SysMouseAImpl_GetCapabilities,
+    IDirectInputDevice2AImpl_EnumObjects,
+    SysMouseAImpl_GetProperty,
+    IDirectInputDevice2AImpl_SetProperty,
+    SysMouseAImpl_Acquire,
+    SysMouseAImpl_Unacquire,
+    SysMouseAImpl_GetDeviceState,
+    SysMouseAImpl_GetDeviceData,
+    IDirectInputDevice2AImpl_SetDataFormat,
+    IDirectInputDevice2AImpl_SetEventNotification,
+    IDirectInputDevice2AImpl_SetCooperativeLevel,
+    SysMouseAImpl_GetObjectInfo,
+    SysMouseAImpl_GetDeviceInfo,
+    IDirectInputDevice2AImpl_RunControlPanel,
+    IDirectInputDevice2AImpl_Initialize,
+    IDirectInputDevice2AImpl_CreateEffect,
+    IDirectInputDevice2AImpl_EnumEffects,
+    IDirectInputDevice2AImpl_GetEffectInfo,
+    IDirectInputDevice2AImpl_GetForceFeedbackState,
+    IDirectInputDevice2AImpl_SendForceFeedbackCommand,
+    IDirectInputDevice2AImpl_EnumCreatedEffectObjects,
+    IDirectInputDevice2AImpl_Escape,
+    IDirectInputDevice2AImpl_Poll,
+    IDirectInputDevice2AImpl_SendDeviceData,
+    IDirectInputDevice7AImpl_EnumEffectsInFile,
+    IDirectInputDevice7AImpl_WriteEffectToFile,
+    SysMouseAImpl_BuildActionMap,
+    SysMouseAImpl_SetActionMap,
+    IDirectInputDevice8AImpl_GetImageInfo
+};
+
+static const IDirectInputDevice8WVtbl SysMouseWvt =
+{
+    IDirectInputDevice2WImpl_QueryInterface,
+    IDirectInputDevice2WImpl_AddRef,
+    IDirectInputDevice2WImpl_Release,
+    SysMouseWImpl_GetCapabilities,
+    IDirectInputDevice2WImpl_EnumObjects,
+    SysMouseWImpl_GetProperty,
+    IDirectInputDevice2WImpl_SetProperty,
+    SysMouseWImpl_Acquire,
+    SysMouseWImpl_Unacquire,
+    SysMouseWImpl_GetDeviceState,
+    SysMouseWImpl_GetDeviceData,
+    IDirectInputDevice2WImpl_SetDataFormat,
+    IDirectInputDevice2WImpl_SetEventNotification,
+    IDirectInputDevice2WImpl_SetCooperativeLevel,
+    SysMouseWImpl_GetObjectInfo,
+    SysMouseWImpl_GetDeviceInfo,
+    IDirectInputDevice2WImpl_RunControlPanel,
+    IDirectInputDevice2WImpl_Initialize,
+    IDirectInputDevice2WImpl_CreateEffect,
+    IDirectInputDevice2WImpl_EnumEffects,
+    IDirectInputDevice2WImpl_GetEffectInfo,
+    IDirectInputDevice2WImpl_GetForceFeedbackState,
+    IDirectInputDevice2WImpl_SendForceFeedbackCommand,
+    IDirectInputDevice2WImpl_EnumCreatedEffectObjects,
+    IDirectInputDevice2WImpl_Escape,
+    IDirectInputDevice2WImpl_Poll,
+    IDirectInputDevice2WImpl_SendDeviceData,
+    IDirectInputDevice7WImpl_EnumEffectsInFile,
+    IDirectInputDevice7WImpl_WriteEffectToFile,
+    SysMouseWImpl_BuildActionMap,
+    SysMouseWImpl_SetActionMap,
+    IDirectInputDevice8WImpl_GetImageInfo
+};
diff --git a/dlls/dinput8/resource.h b/dlls/dinput8/resource.h
new file mode 100644
index 0000000..e4c645b
--- /dev/null
+++ b/dlls/dinput8/resource.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2011 Lucas Fialho Zawacki
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "shlobj.h"
+
+#define IDD_CONFIGUREDEVICES                    1
+
+#define IDC_DEVICETEXT                          20
+#define IDC_RESET                               21
+#define IDC_ACTIONTEXT                          22
+#define IDC_PLAYERTEXT                          23
+#define IDC_DEVICEOBJECTSTEXT                   24
+#define IDC_CONTROLLERCOMBO                     25
+#define IDC_PLAYERCOMBO                         26
+#define IDC_ACTIONLIST                          27
+#define IDC_DEVICEOBJECTSLIST                   28
+#define IDC_CHECKBOXSORT                        29
+#define IDC_MAPPINGTEXT                         30
+#define IDS_ACTIONCOLUMN                        31
+#define IDS_OBJECTCOLUMN                        32
-- 
2.7.4

